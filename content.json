{"meta":{"title":"RiverFun","subtitle":"技不如人，也绝不甘拜下风！","description":"Hs is VERY VEGETABLE!","author":"RiverFun","url":"https://stevebraveman.github.io"},"pages":[{"title":"","date":"2019-07-08T09:18:41.910Z","updated":"2019-06-01T03:51:10.884Z","comments":true,"path":"404/index.html","permalink":"https://stevebraveman.github.io/404/index.html","excerpt":"","text":"404 - Steve_braveman 你来到了一个未知领域。。。。 回到主页 返回上一页"},{"title":"关于我","date":"2018-08-21T05:43:01.000Z","updated":"2019-08-09T02:49:16.591Z","comments":true,"path":"about/index.html","permalink":"https://stevebraveman.github.io/about/index.html","excerpt":"","text":"原ID：Steve_braveman 一个非常蒻的蒟蒻 喜欢玩CSGO和Minecraft的OIer 顺便说一句: $\\huge{\\texttt{我永远喜欢纱路和Kemomimi酱！}}$"},{"title":"archives","date":"2019-08-09T06:22:49.000Z","updated":"2019-08-09T06:23:15.031Z","comments":true,"path":"archives/index.html","permalink":"https://stevebraveman.github.io/archives/index.html","excerpt":"","text":""},{"title":"一些友链","date":"2018-08-21T05:55:37.000Z","updated":"2019-08-09T02:34:00.913Z","comments":true,"path":"links/index.html","permalink":"https://stevebraveman.github.io/links/index.html","excerpt":"","text":"同一届的dalao们屑稳稳——-Taduro魏队——-ZUTTER王 · 爸在煊——-asuldb[AFO]另一个超级dalao——-DEVILK[AFO]dalao——-SuperGoodGame超级dalao——-shzr拥有着光明未来的白佬——-bj2002数学天才——-rehtorbegnaro[AFO]巨到爆表——-hackjy一辈子也打不过的潮爷———ColorfulMist文化课の神——-snoWy机房人赢——-CiyangDP之王——-ctz块爷——-Juan_fengzhuò er爷——-Geiz-Revive 外校dalao Orz Orzalanyhq清风我已逝Arvmemset0xht37 学长学姐们DieSheepCansultRefunA·H_ 可以在下方的评论区交换友链"},{"title":"标签","date":"2018-08-21T02:45:03.000Z","updated":"2019-08-09T06:29:28.242Z","comments":false,"path":"tags/index.html","permalink":"https://stevebraveman.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"-数论-杜教筛-莫比乌斯反演- [LOJ 6491]「XXOI 2018」简单的最大公约数","slug":"97","date":"2019-08-21T13:18:32.000Z","updated":"2019-08-21T23:04:44.722Z","comments":true,"path":"2019/08/21/97/","link":"","permalink":"https://stevebraveman.github.io/2019/08/21/97/","excerpt":"","text":"题目描述Link Solution先推一波柿子： \\begin{align}\\sum_{i_1=1}^m \\sum_{i_2=1}^m \\sum_{i_3=1}^m ...\\sum_{i_n=1}^m \\gcd(i_1,i_2,i_3,...,i_n) &= \\sum_{d=1}^m \\sum_{i_1=1}^m \\sum_{i_2=1}^m \\sum_{i_3=1}^m ...\\sum_{i_n=1}^m [\\gcd(i_1,i_2,i_3,...,i_n) = d]\\\\\\\\ &= \\sum_{d=1}^m \\sum_{i_1=1}^{\\lfloor \\frac{m}{d}\\rfloor} \\sum_{i_2=1}^{\\lfloor \\frac{m}{d}\\rfloor} \\sum_{i_3=1}^{\\lfloor \\frac{m}{d}\\rfloor} ...\\sum_{i_n=1}^{\\lfloor \\frac{m}{d}\\rfloor} [\\gcd(i_1,i_2,i_3,...,i_n) = 1] \\\\\\\\&= \\sum_{d=1}^m d\\sum_{i_1=1}^{\\lfloor \\frac{m}{d}\\rfloor} \\sum_{i_2=1}^{\\lfloor \\frac{m}{d}\\rfloor} \\sum_{i_3=1}^{\\lfloor \\frac{m}{d}\\rfloor} ...\\sum_{i_n=1}^{\\lfloor \\frac{m}{d}\\rfloor} \\sum_{t|i_1,t|i_2,t|i_3,...,t|i_n} \\mu(t) \\\\\\\\ &= \\sum_{d=1}^m \\lfloor \\frac{m}{T}\\rfloor^n \\sum_{d|T} d \\mu(\\frac{T}{d}) \\\\\\\\ &= \\sum_{d=1}^m \\lfloor \\frac{m}{T}\\rfloor^n \\varphi(T) \\end{align}​然而这道题的数据范围是 $10 \\le n,m \\le 10^{11}​$，所以单纯用整除分块是不够的，所以还需要用杜教筛。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;tr1/unordered_map&gt;#define MAXN 10000010#define ull unsigned long longusing namespace std;tr1::unordered_map &lt;ull, ull&gt; h;ull phi[MAXN], p[MAXN], tot, sum[MAXN], n, m, ans;bool chk[MAXN];ull qpow(ull a, ull b) &#123; ull res = 1LL; while (b) &#123; if (b &amp; 1) res = res * a; b &gt;&gt;= 1; a = a * a; &#125; return res;&#125;void seive(ull n) &#123; phi[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!chk[i]) &#123; p[++tot] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= n; j++) &#123; chk[i * p[j]] = 1; if (i % p[j]) &#123; phi[i * p[j]] = phi[i] * phi[p[j]]; &#125; else &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; sum[i] = sum[i - 1] + phi[i]; &#125;&#125;ull djseive(ull n) &#123; if (n &lt;= 10000000) return sum[n]; if (h[n]) return h[n]; ull ans = (n &amp; 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); for (ull l = 2, r; l &lt;= n; l = r + 1) &#123; r = n / (n / l); ans -= (r - l + 1LL) * djseive(n / l); &#125; return h[n] = ans;&#125;int main() &#123; scanf(\"%llu%llu\", &amp;n, &amp;m); seive(10000000); for (ull l = 1, r; l &lt;= m; l = r + 1) &#123; r = m / (m / l); ans += (djseive(r) - djseive(l - 1)) * qpow(m / l, n); &#125; printf(\"%llu\", ans);&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"},{"name":"杜教筛","slug":"杜教筛","permalink":"https://stevebraveman.github.io/tags/杜教筛/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://stevebraveman.github.io/tags/莫比乌斯反演/"},{"name":"LOJ","slug":"LOJ","permalink":"https://stevebraveman.github.io/tags/LOJ/"}]},{"title":"-算法讲解-数论-莫比乌斯反演- 莫比乌斯反演讲解","slug":"96","date":"2019-08-20T12:13:29.000Z","updated":"2019-08-21T13:19:36.297Z","comments":true,"path":"2019/08/20/96/","link":"","permalink":"https://stevebraveman.github.io/2019/08/20/96/","excerpt":"","text":"莫比乌斯反演是一种非常实用而且装逼的算法，它以容斥为基础，来解决一些复杂的数学问题。 先给出莫比乌斯反演的公式： 设定义在自然数集合中的两个函数 $F(x)$ 和 $f(x)$，若这两个函数满足条件： F(n)=\\sum_{d|n}f(d)那么则会有： $f(n)=\\sum_{d|n}\\mu(d)F(\\frac{n}{d})$ 其中 $\\mu$ 为莫比乌斯函数，可以在我的这篇文章中了解关于莫比乌斯函数的知识。 下面我们来证明这个公式。 首先需要了解狄利克雷卷积的一些性质（注：以下出现的函数都是定义在自然数集合上的）： 设 $*$ 为狄利克雷卷积。 若有两个函数 $f$ 和 $g$，且 $f=g$，那么就有：$f * h=g * h$，其中，$h​$ 为另一个函数。 对于三个函数 $f​$、$g​$、$h​$，则会有 $f * (g * h) = (f * g) * h​$。 以上就是需要了解的知识。 $\\because F(n)=\\sum_{d|n}f(d)​$ $\\therefore F=f*I$（$I$ 为不变函数，此函数的值恒为 $1$） $\\therefore F * \\mu = f * I * \\mu$ $\\because I * \\mu = \\epsilon​$（$\\epsilon​$ 为原函数，$\\epsilon(n) = [n = 1]​$） $\\therefore F * \\mu = f * \\epsilon$ 又 $\\because f * \\epsilon = f$ $\\therefore F*\\mu=f​$ $\\therefore f(n)=\\sum_{d|n}\\mu(d) F(\\frac{n}{d})$ Q.E.D 对于一些莫比乌斯反演的题，千万别忘了一个重要的东西： \\mu * I=\\epsilon这个等式在推柿子中很有用，所以一定要记住。我就是因为忘了这个所以有好长一段时间不理解大多数式子是怎么推出来的 举个例子： 求： \\sum_{i=1}^n \\sum_{j=1}^m [\\gcd(i,j)=1]​那么这个柿子就可以这么推： \\begin{align}\\sum_{i=1}^n \\sum_{j=1}^m [\\gcd(i,j)=1] &= \\sum_{i=1}^n \\sum_{j=1}^m \\epsilon(\\gcd(i,j)) \\\\\\\\ &= \\sum_{i=1}^n \\sum_{j=1}^m \\mu*I \\\\\\\\ &= \\sum_{i=1}^n \\sum_{j=1}^m \\sum_{d|\\gcd(i,j)}\\mu(d) \\\\\\\\ &= \\sum_{i=1}^n \\sum_{j=1}^m \\sum_{d|i} \\sum_{d|j} \\mu(d) \\\\\\\\\\ &=\\sum_{d=1}^n \\mu(d) \\sum_{i=1}^n \\sum_{d|i} \\sum_{j=1}^n \\sum_{d|j} 1 \\\\\\\\ &= \\sum_{d=1} \\mu(d) \\lfloor \\frac{n}{d} \\rfloor \\lfloor \\frac{m}{d} \\rfloor \\end{align}接下来是一些关于莫比乌斯反演的练习题： [SDOI2015]约数个数和 [POI2007]ZAP-Queries YY的GCD 如果有什么讲解错误，请在下面的评论中指出（毕竟百密一疏）","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"},{"name":"算法讲解","slug":"算法讲解","permalink":"https://stevebraveman.github.io/tags/算法讲解/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://stevebraveman.github.io/tags/莫比乌斯反演/"}]},{"title":"-学习笔记-虚树- 虚树学习笔记","slug":"95","date":"2019-08-17T06:19:41.000Z","updated":"2019-08-20T01:14:58.422Z","comments":true,"path":"2019/08/17/95/","link":"","permalink":"https://stevebraveman.github.io/2019/08/17/95/","excerpt":"","text":"今天是个好日子！ 最近学了非常酷炫的虚树，感觉这个算法挺实用的。 虚树的做法就是把有用的点及其它们的LCA拎出来，无关的点给丢掉，这样就大大优化了树形dp的复杂度。 设有效节点为 $k$ 个，则建虚树的时间复杂度为 $O(k \\log n)$，在虚树上进行树形dp的时间复杂度为 $O(k)​$。 下面的代码展示了如何建虚树： 1234567891011121314151617void build(int x) &#123; if (!top) &#123; st[++top] = x; return; &#125; int lca = LCA(st[top], x); if (lca == st[top]) return; while (top &amp;&amp; id[st[top - 1]] &gt;= id[lca]) &#123; v[st[top - 1]].push_back(st[top]); top--; &#125; if (lca != st[top]) &#123; v[lca].push_back(st[top]); st[top] = lca; &#125; st[++top] = x;&#125; 上面的代码展示了如何用栈来维护这些点。 然后就是一道例题： [SDOI2011]消耗战： 这题数据范围较大，但是k较小，$O(nm)$ 的DP肯定过不去，所以考虑使用虚树优化，将复杂度降低为 $O(k)$。 献上AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define MAXN 250010#define int long longstruct Edge &#123; int v, nx, w;&#125;e[MAXN &lt;&lt; 1];int head[MAXN], ecnt, n, m, x, y, z, id[MAXN], dep[MAXN], son[MAXN], k;int si[MAXN], st[MAXN], tp, top[MAXN], fa[MAXN], tim, mi[MAXN], a[MAXN];std::vector &lt;int&gt; v[MAXN];bool cmp(int a, int b) &#123; return id[a] &lt; id[b];&#125;void add(int f, int t, int w) &#123; e[++ecnt] = (Edge) &#123;t, head[f], w&#125;; head[f] = ecnt;&#125;void dfs1(int u, int f, int d) &#123; dep[u] = d; si[u] = 1; fa[u] = f; for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (to == f) continue; mi[to] = std::min(mi[u], e[i].w); dfs1(to, u, d + 1); si[u] += si[to]; if (si[to] &gt; si[son[u]]) son[u] = to; &#125;&#125;void dfs2(int u, int topf) &#123; top[u] = topf; id[u] = ++tim; if (!son[u]) return; dfs2(son[u], topf); for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (to == fa[u] || to == son[u]) continue; dfs2(to, to); &#125;&#125;int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) std::swap(x, y); x = fa[top[x]]; &#125; if (dep[x] &gt; dep[y]) std::swap(x, y); return x;&#125;void build(int x) &#123; if (tp == 1) &#123; st[++tp] = x; return; &#125; int lca = LCA(st[tp], x); if (lca == st[tp]) return; while (tp &gt; 1 &amp;&amp; id[st[tp - 1]] &gt;= id[lca]) &#123; v[st[tp - 1]].push_back(st[tp]); tp--; // printf(\"%d -&gt; %d\\n\", st[tp - 1], st[tp]); &#125; if (lca != st[tp]) &#123; v[lca].push_back(st[tp]); st[tp] = lca; &#125; st[++tp] = x;&#125;int dp(int u) &#123; if (v[u].size() == 0) return mi[u]; int ans = 0; for (int i = 0; i &lt; (int)v[u].size(); i++) &#123; int to = v[u][i]; // printf(\"%d\\n\", to); ans += dp(to); &#125; v[u].clear(); return std::min(ans, mi[u]);&#125;signed main() &#123; scanf(\"%lld\", &amp;n); for (int i = 1; i &lt; n; i++) &#123; scanf(\"%lld%lld%lld\", &amp;x, &amp;y, &amp;z); add(x, y, z); add(y, x, z); &#125; memset(mi, 0x7f, sizeof(mi)); dfs1(1, -1, 1); dfs2(1, 1); scanf(\"%lld\", &amp;m); while (m--) &#123; scanf(\"%lld\", &amp;k); for (int i = 1; i &lt;= k; i++) &#123; scanf(\"%lld\", &amp;a[i]); &#125; std::sort(a + 1, a + 1 + k, cmp); tp = 1; st[tp] = 1; for (int i = 1; i &lt;= k; i++) &#123; build(a[i]); &#125; // puts(\"\"); // puts(\"----\"); while (tp &gt; 0) v[st[tp - 1]].push_back(st[tp]), tp--; printf(\"%lld\\n\", dp(1)); // puts(\"----\"); &#125;&#125; 原谅我写这么简短的学习笔记","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://stevebraveman.github.io/tags/学习笔记/"},{"name":"虚树","slug":"虚树","permalink":"https://stevebraveman.github.io/tags/虚树/"}]},{"title":"-数论- [CF1200C]Round Corridor","slug":"94","date":"2019-08-13T23:55:37.000Z","updated":"2019-08-14T00:09:53.395Z","comments":true,"path":"2019/08/14/94/","link":"","permalink":"https://stevebraveman.github.io/2019/08/14/94/","excerpt":"","text":"题目描述Link Solution通过观察，我们可以发现，如果两个位置之间有完整的墙挡住时，那么这两个位置就不能互相到达。 再观察，我们又可以发现，这个东西和最大公约数有关。 因此我们可以设 $g=\\gcd(n,m)$，把一号区域分成大小为 $\\frac{n}{g}$ 的块，把二号区域分成大小为 $\\frac{m}{g}$ 的块，每层区域块的个数都是 $g$。 然后判断这两个位置所在块的编号是否相同就行了。 Code1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define ll long longll n, m, a, b, g, f[3];int x, y, q;template &lt;typename T&gt;T gcd(T a, T b) &#123; if (b == 0) return a; else return gcd(b, a % b);&#125;int main() &#123; scanf(\"%I64d%I64d%d\", &amp;n, &amp;m, &amp;q); g = gcd(n, m); f[1] = n / g; f[2] = m / g; while (q--) &#123; scanf(\"%d%I64d%d%I64d\", &amp;x, &amp;a, &amp;y, &amp;b); if ((a / f[x] + ((a % f[x]) != 0)) != (b / f[y] + ((b % f[y]) != 0))) puts(\"NO\"); else puts(\"YES\"); &#125;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://stevebraveman.github.io/tags/Codeforces/"}]},{"title":"-主席树-树链剖分-LCA- [洛谷 P2633]Count on a tree","slug":"93","date":"2019-08-07T01:17:11.000Z","updated":"2019-08-09T07:13:58.558Z","comments":true,"path":"2019/08/07/93/","link":"","permalink":"https://stevebraveman.github.io/2019/08/07/93/","excerpt":"题目描述Link","text":"题目描述Link Solution为了应对这种强制在线求第K大的情况，我不得不去学了一个主席树。。。 真是恶！ 在进行DFS的时候，每递归到一个节点都在主席树上插入一下。 最后再进行树上差分就可以了。 这道题我调了两天，最后才发现竟然是求LCA时将fa[top[x]]写成了fa[x]； Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// #pragma comment(linker, \"/STACK:1024000000,1024000000\") #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define OK puts(\"OK\")#define MAXN 400010#define re registerbool p1;int a[MAXN * 20], b[MAXN], f[MAXN], ls[MAXN * 20], rs[MAXN * 20], tot = 0, rt[MAXN], lans;int siz[MAXN], id[MAXN], son[MAXN], fa[MAXN], dep[MAXN], tim, top[MAXN], len;int head[MAXN], ecnt;int _t = 0;template &lt;typename T&gt;inline void read(T &amp;x) &#123; T f = 1; x = 0; char c = getchar(); while (c &gt; '9' || c &lt; '0') &#123;if (c == '-') f = -1; c = getchar();&#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123;x = x * 10 + c - '0'; c = getchar();&#125; x *= f;&#125;struct Edge &#123; int v, nx;&#125;e[MAXN &lt;&lt; 2];inline void add(int f, int t) &#123; e[++ecnt] = (Edge) &#123;t, head[f]&#125;; head[f] = ecnt;&#125;void insert(int l, int r, int x, int &amp;y, int p) &#123; y = ++tot; a[y] = a[x] + 1; if (l == r) return; int m = (l + r) &gt;&gt; 1; if (p &lt;= m) rs[y] = rs[x], insert(l, m, ls[x], ls[y], p); else ls[y] = ls[x], insert(m + 1, r, rs[x], rs[y], p);&#125;void dfs(int ft, int u, int d) &#123; dep[u] = d; fa[u] = ft; siz[u] = 1; insert(1, len, rt[ft], rt[u], b[u]); // printf(\"%d %d %d %d %d\\n\", ft, u, b[u], d, rt[u]); for (re int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (to == ft) continue; dfs(u, to, d + 1); siz[u] += siz[to]; if (siz[son[u]] &lt; siz[to]) son[u] = to; // printf(\"%d\\n\", u); &#125;&#125;void dfs2(int u, int topf) &#123; top[u] = topf; if (!son[u]) return; dfs2(son[u], topf); for (re int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (to == fa[u] || to == son[u]) continue; dfs2(to, to); &#125;&#125;inline int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) std::swap(x, y); x = fa[top[x]]; &#125; if (dep[x] &gt; dep[y]) std::swap(x, y); return x;&#125;int ask(int l, int r, int x, int y, int la, int fala, int k) &#123; if (l == r) return l; int m = (l + r) &gt;&gt; 1; int p = a[ls[y]] + a[ls[x]] - a[ls[la]] - a[ls[fala]]; if (p &gt;= k) return ask(l, m, ls[x], ls[y], ls[la], ls[fala], k); else return ask(m + 1, r, rs[x], rs[y], rs[la], rs[fala], k - p);&#125;int n, m, l, r, k, x, y;int main() &#123; // freopen(\"data.in\", \"r\", stdin); // freopen(\"data.out\", \"w\", stdout); read(n), read(m); for (re int i = 1; i &lt;= n; i++) &#123; read(b[i]); f[i] = b[i]; &#125; std::sort(f + 1, f + 1 + n); len = std::unique(f + 1, f + 1 + n) - f - 1; for (re int i = 1; i &lt;= n; i++) &#123; b[i] = std::lower_bound(f + 1, f + 1 + len, b[i]) - f; &#125; for (re int i = 1; i &lt; n; i++) &#123; read(x), read(y); add(x, y); add(y, x); &#125; dfs(0, 1, 1); dfs2(1, 1); for (re int i = 1; i &lt;= m; i++) &#123; read(l), read(r), read(k); l = lans ^ l; int lc = LCA(l, r); printf(\"%d\\n\", lans = f[ask(1, len, rt[l], rt[r], rt[lc], rt[fa[lc]], k)]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"LCA","slug":"LCA","permalink":"https://stevebraveman.github.io/tags/LCA/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://stevebraveman.github.io/tags/树链剖分/"},{"name":"主席树","slug":"主席树","permalink":"https://stevebraveman.github.io/tags/主席树/"}]},{"title":"-多项式-NTT/FFT- 多项式板子合集","slug":"92","date":"2019-07-10T11:01:15.000Z","updated":"2019-08-08T10:42:46.859Z","comments":true,"path":"2019/07/10/92/","link":"","permalink":"https://stevebraveman.github.io/2019/07/10/92/","excerpt":"下面是多项式的一些操作，包含了NTT，求逆，求 $\\ln$，求导，求积分，求 $e^x$，开根，快速幂，三角函数和反三角函数。 多项式除法先咕着","text":"下面是多项式的一些操作，包含了NTT，求逆，求 $\\ln$，求导，求积分，求 $e^x$，开根，快速幂，三角函数和反三角函数。 多项式除法先咕着 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 400010#define MOD 998244353#define G 3#define I 86583718void read(int &amp;x) &#123; int f = 1; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') &#123;if (c == '-') f = -1; c = getchar();&#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123;x = x * 10 + c - '0'; c = getchar();&#125; x *= f;&#125;void write(int x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int qpow(int a, int b) &#123; int res = 1; while (b) &#123; if (b &amp; 1) res = (1LL * res * a) % MOD; b &gt;&gt;= 1; a = (1LL * a * a) % MOD; &#125; return res % MOD;&#125;int n, m;int a[MAXN], b[MAXN], f[MAXN], rev[MAXN];void ntt(int *a, int n, int f) &#123; for (int i = 0; i &lt; n; i++) &#123; if (1LL * i &lt; rev[i]) &#123; std::swap(a[i], a[rev[i]]); &#125; &#125; for (int i = 1; i &lt; n; i &lt;&lt;= 1) &#123; int wn = qpow(G, (MOD - 1) / ((long long)i &lt;&lt; 1)); for (int j = 0; j &lt; n; j += ((long long)i &lt;&lt; 1)) &#123; int w = 1LL; for (int k = 0; k &lt; i; ++k, w = 1LL * w * wn % MOD) &#123; int x = a[j + k], y = 1LL * w * a[j + k + i] % MOD; a[j + k] = (x + y) % MOD, a[j + k + i] = (x - y + MOD) % MOD; &#125; &#125; &#125; if (f == 1) return; int tmp = qpow(n, MOD - 2); std::reverse(a + 1, a + n); for (int i = 0; i &lt; n; i++) &#123; a[i] = 1LL * a[i] * tmp % MOD; &#125;&#125;int c[MAXN];void inv(int d, int *a, int *b) &#123; if (d == 1) &#123; b[0] = qpow(a[0], MOD - 2); return; &#125; inv((d + 1) &gt;&gt; 1, a, b); int l = 0, _n = 1; while (_n &lt; (d &lt;&lt; 1)) _n &lt;&lt;= 1, l++; for (int i = 1; i &lt; _n; i++) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (((long long)i &amp; 1) &lt;&lt; (l - 1)); &#125; for (int i = 0; i &lt; d; i++) c[i] = a[i]; for (int i = d; i &lt; _n; i++) c[i] = 0; ntt(c, _n, 1); ntt(b, _n, 1); for (int i = 0; i &lt; _n; i++) &#123; b[i] = (2 - 1LL * b[i] * c[i] % MOD + MOD) % MOD * b[i] % MOD; &#125; ntt(b, _n, -1); for (int i = d; i &lt; _n; i++) &#123; b[i] = 0; &#125; return;&#125;int d[MAXN], e[MAXN];void Deriv(int *a, int *b, int l) &#123; for (int i = 1; i &lt; l; i++) &#123; b[i - 1] = 1LL * a[i] * i % MOD; &#125; b[l - 1] = 0;&#125;void Integ(int *a, int *b, int l) &#123; for (int i = 1; i &lt; l; i++) &#123; b[i] = 1LL * a[i - 1] * qpow(i, MOD - 2) % MOD; &#125; b[0] = 0;&#125;void Ln(int *a, int *b, int k) &#123; for (int i = 0; i &lt; 2 * k; i++) d[i] = 0; inv(k, a, d); Deriv(a, e, k); int l = 0, _n = 1; while (_n &lt; (k &lt;&lt; 1)) _n &lt;&lt;= 1, l++; for (int i = 1; i &lt; _n; i++) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (((long long)i &amp; 1) &lt;&lt; (l - 1)); &#125; ntt(e, _n, 1); ntt(d, _n, 1); for (int i = 0; i &lt; _n; i++) &#123; e[i] = 1LL * e[i] * d[i] % MOD; &#125; ntt(e, _n, -1); Integ(e, b, k);&#125;int g[MAXN], h[MAXN];void Exp(int *a, int *b, int k) &#123; if (k == 1) &#123; b[0] = 1; return; &#125; Exp(a, b, (k + 1) &gt;&gt; 1); int l = 0, _n = 1; while (_n &lt; (k &lt;&lt; 1)) _n &lt;&lt;= 1, l++; for (int i = 1; i &lt; _n; i++) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (((long long)i &amp; 1) &lt;&lt; (l - 1)); &#125; for (int i = 0; i &lt; (k &lt;&lt; 1); i++) g[i] = h[i] = 0; Ln(b, g, k); for (int i = 0; i &lt; k; i++) h[i] = a[i]; ntt(b, _n, 1); ntt(h, _n, 1); ntt(g, _n, 1); for (int i = 0; i &lt; _n; i++) &#123; b[i] = 1LL * (1LL - g[i] + h[i] + MOD) * b[i] % MOD; &#125; ntt(b, _n, -1); for (int i = k; i &lt; _n; i++) &#123; b[i] = 0; &#125; return;&#125;void mult(int *a, int *b, int *c, int n) &#123; int _n = 1, l = 0; while (_n &lt; (n &lt;&lt; 1)) _n &lt;&lt;= 1, l++; for (int i = 1; i &lt; _n; i++) &#123; rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | (((1LL * i) &amp; 1) &lt;&lt; (l - 1)); &#125; ntt(a, _n, 1); ntt(b, _n, 1); for (int i = 0; i &lt; _n; i++) &#123; c[i] = 1LL * a[i] * b[i] % MOD; &#125; ntt(c, _n, -1);&#125;int fl, tt[MAXN], rr[MAXN], gg[MAXN], pp[MAXN], kk[MAXN], ss[MAXN], yy[MAXN], hh[MAXN], ww[MAXN];void clear() &#123; for (int i = 1; i &lt; (n &lt;&lt; 2); i++) &#123; b[i] = c[i] = h[i] = g[i] = d[i] = e[i] = 0; tt[i] = rr[i] = kk[i] = ss[i] = yy[i] = hh[i] = 0; &#125;&#125;void _clr() &#123; for (int i = 1; i &lt; (n &lt;&lt; 2); i++) &#123; ww[i] = pp[i] = gg[i] = tt[i] = rr[i] = kk[i] = ss[i] = yy[i] = hh[i] = 0; &#125;&#125;void sqrt(int *a, int *b, int d) &#123; clear(); Ln(a, kk, d); int inv2 = qpow(2, MOD - 2); for (int i = 0; i &lt; d; i++) &#123; kk[i] = (1LL * kk[i] * inv2) % MOD; &#125; clear(); Exp(kk, b, d);&#125;void pow(int *a, int *b, int k, int d) &#123; clear(); _clr(); Ln(a, kk, n); clear(); for (int i = 0; i &lt; d; i++) &#123; kk[i] = 1LL * kk[i] * k % MOD; &#125; Exp(kk, b, d); return;&#125;void sin(int *a, int *b, int d) &#123; clear(); _clr(); for (int i = 0; i &lt; d; i++) &#123; tt[i] = 1LL * a[i] * I % MOD; &#125; Exp(tt, rr, d); clear(); inv(d, rr, gg); for (int i = 0; i &lt; d; i++) &#123; b[i] = 1LL * (rr[i] - gg[i] + MOD) * qpow(I * 2, MOD - 2) % MOD; &#125;&#125;void cos(int *a, int *b, int d) &#123; clear(); _clr(); for (int i = 0; i &lt; d; i++) &#123; tt[i] = 1LL * a[i] * I % MOD; &#125; Exp(tt, rr, d); clear(); inv(d, rr, gg); for (int i = 0; i &lt; d; i++) &#123; b[i] = 1LL * (rr[i] + gg[i]) * qpow(2, MOD - 2) % MOD; &#125;&#125;void arcsin(int *a, int *b, int d) &#123; clear(); _clr(); for (int i = 0; i &lt; d; i++) &#123; ww[i] = gg[i] = a[i]; &#125; Deriv(a, tt, d); mult(gg, ww, pp, d); for (int i = 0; i &lt; d; i++) &#123; pp[i] = (MOD - pp[i]) % MOD; &#125; pp[0] = (pp[0] + 1) % MOD; sqrt(pp, ss, d); clear(); inv(d, ss, yy); clear(); mult(tt, yy, hh, d); clear(); Integ(hh, b, d);&#125;void arctan(int *a, int *b, int d) &#123; clear(); _clr(); for (int i = 0; i &lt; d; i++) &#123; ww[i] = gg[i] = a[i]; &#125; Deriv(a, tt, d); mult(gg, ww, pp, d); pp[0] = (1 + pp[0]) % MOD; clear(); inv(d, pp, yy); clear(); mult(tt, yy, hh, d); clear(); Integ(hh, b, d);&#125;int main() &#123; read(n), read(fl); for (int i = 0; i &lt; n; i++) &#123; read(a[i]); &#125; /* Operator */ for (int i = 0; i &lt; n; i++) &#123; write(f[i]), putchar(' '); &#125; return 0;&#125;","categories":[],"tags":[{"name":"多项式","slug":"多项式","permalink":"https://stevebraveman.github.io/tags/多项式/"},{"name":"NTT/FFT","slug":"NTT-FFT","permalink":"https://stevebraveman.github.io/tags/NTT-FFT/"}]},{"title":"-矩阵运算-矩阵乘法-分块- [洛谷 P5110]块速递推","slug":"91","date":"2019-07-03T01:14:06.000Z","updated":"2019-08-08T10:42:46.075Z","comments":true,"path":"2019/07/03/91/","link":"","permalink":"https://stevebraveman.github.io/2019/07/03/91/","excerpt":"题目描述Link","text":"题目描述Link Solution看着如此庞大的数据范围，$O(n \\log n)$ 显然过不去。 所以做这题之前可以先去做一下快速幂 2，学习一下光速幂是如何写的。 矩乘部分很简单，剩下的就是卡常了。 卡常技巧1：把 long long 换成 int。 卡常技巧2：循环展开 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define ull unsigned long long#define MOD 1000000007namespace Mker &#123; unsigned long long SA, SB, SC; void init() &#123; scanf(\"%llu%llu%llu\", &amp;SA, &amp;SB, &amp;SC); &#125; inline unsigned long long rand() &#123; SA ^= SA &lt;&lt; 32, SA ^= SA &gt;&gt; 13, SA ^= SA &lt;&lt; 1; unsigned long long t = SA; SA = SB, SB = SC, SC ^= t ^ SA; return SC; &#125;&#125;struct Mat&#123; int a[2][2]; inline void clear() &#123; memset(a, 0, sizeof(a)); &#125; inline void init() &#123; a[0][0] = a[1][0] = a[1][1] =a[0][1] = 0; a[0][0] = a[1][1] = 1; &#125;&#125;;inline Mat operator * (Mat a, Mat b) &#123; Mat c; c.a[0][0] = c.a[1][0] = c.a[0][1] = c.a[1][1] = 0; c.a[0][0] = (c.a[0][0] + 1LL * a.a[0][0] * b.a[0][0] + 1LL * a.a[0][1] * b.a[1][0]) % MOD; c.a[0][1] = (c.a[0][1] + 1LL * a.a[0][0] * b.a[0][1] + 1LL * a.a[0][1] * b.a[1][1]) % MOD; c.a[1][0] = (c.a[1][0] + 1LL * a.a[1][0] * b.a[0][0] + 1LL * a.a[1][1] * b.a[1][0]) % MOD; c.a[1][1] = (c.a[1][1] + 1LL * a.a[1][0] * b.a[0][1] + 1LL * a.a[1][1] * b.a[1][1]) % MOD; return c;&#125;inline Mat qpow(Mat a, ull n) &#123; Mat b; b.init(); while (n) &#123; if (n &amp; 1) b = b * a; n &gt;&gt;= 1; a = a * a; &#125; return b;&#125;ull sq;Mat x1[50000], x2[50000], g;int main() &#123; int t; scanf(\"%d\", &amp;t); Mker::init(); int ans = 0; Mat f, a, q; a.clear(), q.clear(); a.a[0][0] = 233, a.a[1][0] = 666; a.a[0][1] = 1; x1[0].init(), x2[0].init(); sq = sqrt(MOD - 1) + 1; a.a[1][1] = 0; g = qpow(a, sq); for (int i = 1; i &lt;= sq + 1; i++) &#123; x1[i] = x1[i - 1] * a; x2[i] = x2[i - 1] * g; &#125; while (t--) &#123; int k = (Mker::rand() - 1) % 1000000006; if (k &lt;= 1) ans ^= k; q = x1[k % sq] * x2[k / sq]; ans ^= q.a[0][0]; &#125; std::cout &lt;&lt; ans;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"分块","slug":"分块","permalink":"https://stevebraveman.github.io/tags/分块/"},{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"https://stevebraveman.github.io/tags/矩阵乘法/"}]},{"title":"-贪心- [CF484A]Bits","slug":"90","date":"2019-06-30T00:06:06.000Z","updated":"2019-08-08T10:42:44.908Z","comments":true,"path":"2019/06/30/90/","link":"","permalink":"https://stevebraveman.github.io/2019/06/30/90/","excerpt":"题目描述Link","text":"题目描述Link Solution别以为这是个A题就很简单，我差点被坑了。。。。 这题就是每一位贪心的放 $1$，如果超过 $r$ 了就 break 。 话说一开始我还想用二分来着，后来发现答案并不单调。 Code123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 100010#define ll long longint T;ll l, r, ans;int main() &#123; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%I64d%I64d\", &amp;l, &amp;r); ans = l; for (ll i = 0; i &lt; 62; i++) &#123; ll m = 1LL &lt;&lt; i; ans |= m; if (ans &gt; r) &#123; ans ^= m; break; &#125; &#125; printf(\"%I64d\\n\", ans); &#125;&#125;","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://stevebraveman.github.io/tags/贪心/"}]},{"title":"-数论-逆元- [洛谷 P4881]hby与tkw的基情","slug":"89","date":"2019-06-27T09:38:35.000Z","updated":"2019-08-08T10:42:43.016Z","comments":true,"path":"2019/06/27/89/","link":"","permalink":"https://stevebraveman.github.io/2019/06/27/89/","excerpt":"题目描述Link","text":"题目描述Link Solution先把题目转换为人话： 给定一个数字 $n$，求： \\sum^{\\lfloor \\frac{n+1}{2} \\rfloor}_{i=1}(2 \\times i-1) \\times 26 ^ i​对于求等差数列平方和等比数列的积的前 $n$ 项和我们可以用错位相减法。 设 $k=\\lfloor \\frac{n+1}{2} \\rfloor, Sk=\\sum^{\\lfloor \\frac{n+1}{2} \\rfloor}{i=1}(2 \\times i-1) \\times 26 ^ i​$。 则：$26 \\times Sk=\\sum^{\\lfloor \\frac{n+1}{2} \\rfloor}{i=1}(2 \\times i-1) \\times 26 ^ {i+1}​$ 所以： \\begin{align}25 \\times S_k &= 26 \\times S_k-S_k \\\\\\ &= \\sum^{\\lfloor \\frac{n+1}{2} \\rfloor}_{i=1}(2 \\times i-1) \\times 26 ^ {i+1}-\\sum^{k}_{i=1}(2 \\times i-1) \\times 26 ^ i \\\\\\ &= (2\\times k-1)\\times 26^k -\\frac{2 \\times 26 \\times(26^k-1)}{25}-26 \\end{align}再用快速幂和逆元随便瞎搞搞就可以了。 Code12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MOD 1000000007#define ll long longint T;ll n;ll qpow(ll a, ll b, ll p) &#123; ll res = 1; while (b) &#123; if (b &amp; 1) res = (res * a) % p; b &gt;&gt;= 1; a = (a * a) % p; &#125; return res % p;&#125;int main() &#123; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%lld\", &amp;n); n = (n + 1) / 2; printf(\"%lld\\n\", (((2 * n - 1) * qpow(26, n + 1, MOD) % MOD - 26 * (qpow(26, n, MOD) - 1) % MOD * qpow(25, MOD - 2, MOD) * 2 % MOD + 26 + MOD) % MOD) * qpow(25, MOD - 2, MOD) % MOD); &#125;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"},{"name":"逆元","slug":"逆元","permalink":"https://stevebraveman.github.io/tags/逆元/"}]},{"title":"-数论-欧拉定理- 有关无理数取余的一些想法","slug":"88","date":"2019-06-24T03:12:52.000Z","updated":"2019-08-08T10:42:32.676Z","comments":true,"path":"2019/06/24/88/","link":"","permalink":"https://stevebraveman.github.io/2019/06/24/88/","excerpt":"我们知道针对有理数取余我们可以用费马小定理（欧拉定理）或者是扩展欧几里得求逆元得到。 但是现在，我们也可以根据（扩展）欧拉定理来进行无理数取余。","text":"我们知道针对有理数取余我们可以用费马小定理（欧拉定理）或者是扩展欧几里得求逆元得到。 但是现在，我们也可以根据（扩展）欧拉定理来进行无理数取余。 因为 $a^b \\equiv a^{b \\% \\varphi(p)} \\pmod p,\\gcd(a,p)=1$。 所以可以把 $b$ 换为有理数，那么取余的对象就变成了根式。 但是这并不对所有的数据都适用，因为要满足 $\\gcd(\\varphi(p),b)=1$ ，其中 $b$ 为所要求逆元的数。 尽管存在这个，但并没有说无理数取余是完全不可能，在特殊的数据下还是可以的，比如说 $\\sqrt[3]{2} \\equiv 3 \\pmod 5$。 看，证明什么的都没有，多简洁 Update 2019.6.25 今天听说了一个叫二次剩余的东西，貌似我这个无理数取余没什么卵用了","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"},{"name":"欧拉定理","slug":"欧拉定理","permalink":"https://stevebraveman.github.io/tags/欧拉定理/"}]},{"title":"-树链剖分-线段树- [洛谷 P4116]Qtree3","slug":"87","date":"2019-06-05T06:07:59.000Z","updated":"2019-08-08T10:43:03.414Z","comments":true,"path":"2019/06/05/87/","link":"","permalink":"https://stevebraveman.github.io/2019/06/05/87/","excerpt":"题目描述Link","text":"题目描述Link Solution这道题看到别人都用了很多高端的做法，但我太菜了，所以就只好用了一个线段树做法。 这里我用了一个树链剖分的性质：从根到一个节点的路径上的序号一定是单调递增的。 根据这个性质，我们可以有如下思路： 一开始，树上所有的点的点权都赋值成 $INF$ ，如果一个点被修改成了黑点，就把这个点赋值成这个点的编号，查询的时候做区间最小值就行了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 100010#define ls(x) ((x) &lt;&lt; 1)#define rs(x) ((x) &lt;&lt; 1 | 1)#define INF 0x7fffffffstruct Edge &#123; int v, nx;&#125;e[MAXN &lt;&lt; 2];template &lt;typename Tp&gt;void swap(Tp &amp;a, Tp &amp;b) &#123; Tp t = a; a = b; b = t;&#125;template &lt;typename Tp&gt;Tp max(Tp a, Tp b) &#123; if (a &gt; b) return a; else return b;&#125;template &lt;typename Tp&gt;Tp min(Tp a, Tp b) &#123; if (a &lt; b) return a; else return b;&#125;int head[MAXN], ecnt, n, m, x, y, dep[MAXN], si[MAXN], wt[MAXN], w[MAXN];int fa[MAXN], top[MAXN], son[MAXN], cnt, r = 1, id[MAXN], nid[MAXN];void add(int f, int t) &#123; e[++ecnt] = (Edge) &#123;t, head[f]&#125;; head[f] = ecnt;&#125;struct Segtree &#123; int a[MAXN], tmin[MAXN &lt;&lt; 2]; void pd(int p) &#123; tmin[p] = min(tmin[ls(p)], tmin[rs(p)]); &#125; void build(int l, int r, int p) &#123; if (l == r) &#123; tmin[p] = INF; return; &#125; int m = (l + r) &gt;&gt; 1; build(l, m, ls(p)); build(m + 1, r, rs(p)); pd(p); &#125; void updated(int x, int l, int r, int p, int k) &#123; if (l == r) &#123; tmin[p] = k; return; &#125; int m = (l + r) &gt;&gt; 1; if (x &lt;= m) updated(x, l, m, ls(p), k); else updated(x, m + 1, r, rs(p), k); pd(p); &#125; int qmin(int x, int y, int l, int r, int p) &#123; int s = INF; if (x &lt;= l &amp;&amp; y &gt;= r) &#123; return tmin[p]; &#125; int m = (l + r) &gt;&gt; 1; if (x &lt;= m) s = min(qmin(x, y, l, m, ls(p)), s); if (y &gt; m) s = min(qmin(x, y, m + 1, r, rs(p)), s); return s; &#125; bool ask(int x, int l, int r, int p) &#123; if (l == r) &#123; return (tmin[p] == INF); &#125; int m = (l + r) &gt;&gt; 1; if (x &lt;= m) return ask(x, l, m, ls(p)); else return ask(x, m + 1, r, rs(p)); &#125;&#125;tr;void dfs1(int u, int f, int deep) &#123; dep[u] = deep; fa[u] = f; si[u] = 1; for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (to == f) continue; dfs1(to, u, deep + 1); si[u] += si[to]; if (si[to] &gt; si[son[u]]) son[u] = to; &#125;&#125;void dfs2(int u, int topf) &#123; id[u] = ++cnt; nid[cnt] = u; top[u] = topf; if (!son[u]) return; dfs2(son[u], topf); for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (fa[u] == to || to == son[u]) continue; dfs2(to, to); &#125;&#125;inline int qrs(int x, int y) &#123; int ans = INF; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); ans = min(ans, tr.qmin(id[top[x]], id[x], 1, n, 1)); x = fa[top[x]]; &#125; if (dep[x] &gt; dep[y]) swap(x, y); ans = min(tr.qmin(id[x], id[y], 1, n, 1), ans); if (ans == INF) return -1; else return nid[ans];&#125;inline void update(int x) &#123; bool ans = tr.ask(id[x], 1, n, 1); // puts(\"-----\"); // printf(\"%d\\n\", ans); // puts(\"-----\"); if (ans) &#123; tr.updated(id[x], 1, n, 1, id[x]); &#125; else &#123; tr.updated(id[x], 1, n, 1, INF); &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt; n; i++) &#123; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); add(y, x); &#125; dfs1(r, 0, 1); dfs2(r, r); tr.build(1, n, 1); // for (int i = 1; i &lt;= n; i++) &#123; // printf(\"%d \", id[i]); // &#125; // puts(\"\"); while (m--) &#123; scanf(\"%d%d\", &amp;x, &amp;y); if (!x) &#123; update(y); &#125; else &#123; printf(\"%d\\n\", qrs(1, y)); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"线段树","slug":"线段树","permalink":"https://stevebraveman.github.io/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://stevebraveman.github.io/tags/树链剖分/"}]},{"title":"-图论-拓扑排序- [CF1131D]Gourmet choice","slug":"86","date":"2019-05-26T09:27:30.000Z","updated":"2019-08-08T10:43:22.382Z","comments":true,"path":"2019/05/26/86/","link":"","permalink":"https://stevebraveman.github.io/2019/05/26/86/","excerpt":"题目描述Link","text":"题目描述Link Solution并查集 + 拓扑排序 那么我们该怎样用并查集和拓扑排序呢 思路很简单，把标有=的i和j放在同一个并查集内，然后根据题意连边，如果是&gt;，就这么连：i所在集合的标号 -&gt; j所在集合的标号，如果是&gt;那么就相反。当然，你也可以和我的意思相反，就是在赋值上有些麻烦。 连完边后，直接跑拓扑就可以了，别忘了在拓扑排序的时候给点赋值 也别忘了判断一下有没有环，如果有环，那么就不存在。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAXN 2000100char mp[1010][1010];int n, m, head[MAXN], ecnt, x, y, ent[MAXN], out[MAXN], rank[MAXN], p, deli[MAXN], fa[MAXN], ans, tot;bool vis[MAXN], ifq[MAXN];std::queue &lt;int&gt; q;struct Edge &#123; int v, nx;&#125;e[MAXN];void add(int f, int t) &#123; e[++ecnt] = (Edge) &#123;t, head[f]&#125;; head[f] = ecnt;&#125;int find(int x) &#123; if (fa[x] == x) return x; else return fa[x] = find(fa[x]);&#125;void un(int x, int y) &#123; x = find(x); y = find(y); if (x == y) return; if (rank[x] &lt;= rank[y]) &#123; fa[x] = y; if (rank[x] == rank[y]) &#123; rank[x]++; &#125; &#125; else &#123; fa[y] = x; &#125; return;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%s\", mp[i] + 1); &#125; for (int i = 1; i &lt;= n + m; i++) &#123; fa[i] = i; rank[i] = 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (mp[i][j] == '=') &#123; un(i, j + n); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; x = find(j + n); y = find(i); if (mp[i][j] == '&gt;') &#123; add(x, y); ent[y]++; &#125; if (mp[i][j] == '&lt;') &#123; add(y, x); ent[x]++; &#125; &#125; &#125; tot = n + m; for (int i = 1; i &lt;= n + m; i++) &#123; p = find(i); if (!ent[p] &amp;&amp; !ifq[p]) &#123; q.push(p); ifq[p] = 1; deli[p] = 1; deli[i] = 1; &#125; &#125; ans = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = 1; for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (vis[to]) continue; ent[to]--; if (!ent[to]) &#123; deli[to] = deli[u] + 1; q.push(to); &#125; &#125; &#125; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= n + m; i++) &#123; if (!ent[find(i)]) ans++; &#125; // for (int i = 1; i &lt;= n + m; i++) &#123; // printf(\"%d \", ent[find(i)]); // &#125; // puts(\"\"); if (tot != ans) &#123; // printf(\"%d %d\\n\", tot, ans); puts(\"No\"); return 0; &#125; puts(\"Yes\"); for (int i = 1; i &lt;= n + m; i++) &#123; int p = find(i); deli[i] = deli[p]; &#125; for (int i = 1; i &lt;= n; i++) &#123; printf(\"%d \", deli[i]); &#125; puts(\"\"); for (int i = n + 1; i &lt;= n + m; i++) &#123; printf(\"%d \", deli[i]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"https://stevebraveman.github.io/tags/图论/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://stevebraveman.github.io/tags/Codeforces/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://stevebraveman.github.io/tags/拓扑排序/"}]},{"title":"-网络流- 对于网络流24题的题解索引","slug":"85","date":"2019-05-24T11:25:01.000Z","updated":"2019-08-17T08:13:49.241Z","comments":true,"path":"2019/05/24/85/","link":"","permalink":"https://stevebraveman.github.io/2019/05/24/85/","excerpt":"这是所有的网络流24题，其中标记了我完成的和我没有完成的题","text":"这是所有的网络流24题，其中标记了我完成的和我没有完成的题 （PS:点击题解中的对勾可以传送到相应题的题解） 题目 AC 题解 飞行员配对方案问题 试题库问题 最小路径覆盖问题 [CTSC1999]家园 餐巾计划问题 软件补丁问题 太空飞行计划问题 魔术球问题 最长不下降子序列问题 航空路线问题 方格取数问题 机器人路径规划问题 圆桌问题 骑士共存问题 火星探险问题 最长k可重线段集问题 最长k可重区间集问题 汽车加油行驶问题 孤岛营救问题 深海机器人问题 数字梯形问题 分配问题 运输问题 负载平衡问题","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"网络流24题","slug":"网络流24题","permalink":"https://stevebraveman.github.io/tags/网络流24题/"}]},{"title":"-网络流-最大流-二分图- [洛谷 PP3254][网络流24题]圆桌问题","slug":"84","date":"2019-05-24T11:09:55.000Z","updated":"2019-08-08T10:43:48.546Z","comments":true,"path":"2019/05/24/84/","link":"","permalink":"https://stevebraveman.github.io/2019/05/24/84/","excerpt":"题目描述Link","text":"题目描述Link Solution建立二分图和超级源汇，将每个源点连向每个单位的编号，容量为这个单位的人数，将每个圆桌的编号连向超级汇点，容量为这个圆桌所能容纳的人的数量，再在每个单位和每个圆桌分别相连，容量为 $1$。 最后跑最大流就可以了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define MAXN 1000002#define INF 2000000000int min(int a, int b) &#123; if (a &lt; b) return a; else return b;&#125;struct Edge &#123; int v, nx, w;&#125; e[MAXN];std::queue &lt;int&gt; q;int n, m, head[MAXN], ecnt = 1, x, y, z, r, k, dep[MAXN], cur[MAXN], cnt = 1, totp = 0, tot;void add(int f, int t, int w) &#123; e[++ecnt] = (Edge) &#123;t, head[f], w&#125;; head[f] = ecnt; e[++ecnt] = (Edge) &#123;f, head[t], 0&#125;; head[t] = ecnt;&#125;bool bfs(int s, int t) &#123; memset(dep, 0x7f, sizeof(dep)); while (!q.empty()) q.pop(); for (int i = 1; i &lt;= n + m + 2; i++) &#123; cur[i] = head[i]; &#125; dep[s] = 0; q.push(s); while (!q.empty()) &#123; int v = q.front(); q.pop(); for (int i = head[v]; i; i = e[i].nx) &#123; int to = e[i].v; if (dep[to] &gt; INF &amp;&amp; e[i].w) &#123; dep[to] = dep[v] + 1; q.push(to); &#125; &#125; &#125; if (dep[t] &lt; INF) return 1; else return 0;&#125;int dfs(int u, int t, int l) &#123; if (!l || u == t) return l; int fl = 0, f; for (int i = cur[u]; i; i = e[i].nx) &#123; cur[u] = i; int to = e[i].v; if (dep[to] == dep[u] + 1 &amp;&amp; (f = dfs(to, t, min(l, e[i].w)))) &#123; fl += f; l -= f; e[i ^ 1].w += f; e[i].w -= f; if (!l) break; &#125; &#125; return fl;&#125;int Dinic(int s, int t) &#123; int maxf = 0; while (bfs(s, t)) &#123; maxf += dfs(s, t , INF); &#125; return maxf;&#125;int a[MAXN], b[MAXN];int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); totp += a[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%d\", &amp;b[i]); &#125; r = n + m + 2; k = n + m + 1; for (int i = 1; i &lt;= n; i++) &#123; add(r, i, a[i]); &#125; for (int i = n + 1; i &lt;= n + m; i++) &#123; add(i, k, b[i - n]); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = n + 1; j &lt;= n + m; j++) &#123; add(i, j, 1); &#125; &#125; tot = Dinic(r, k); if (tot != totp) &#123; puts(\"0\"); return 0; &#125; puts(\"1\"); for (int i = 1; i &lt;= n; i++) &#123; for (int j = head[i]; j; j = e[j].nx) &#123; int to = e[j].v; if (to != r &amp;&amp; e[j].w == 0) &#123; printf(\"%d \", e[j].v - n); &#125; &#125; puts(\"\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"二分图","slug":"二分图","permalink":"https://stevebraveman.github.io/tags/二分图/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"https://stevebraveman.github.io/tags/最大流/"},{"name":"网络流24题","slug":"网络流24题","permalink":"https://stevebraveman.github.io/tags/网络流24题/"}]},{"title":"-网络流-二分图-最大流-最大匹配- [洛谷 P3355][网络流24题]骑士共存问题","slug":"83","date":"2019-05-24T10:59:50.000Z","updated":"2019-08-08T10:44:05.242Z","comments":true,"path":"2019/05/24/83/","link":"","permalink":"https://stevebraveman.github.io/2019/05/24/83/","excerpt":"题目描述Link","text":"题目描述Link Solution这道题我们先对图进行黑白染色，因为国际象棋中“马”的行走方式的特殊性，使得一个黑格对应八个白格，我们就可以根据黑白格的情况来建图。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define MAXN 100020namespace STman &#123; template &lt;typename Tp&gt; inline void read(Tp &amp;x) &#123; #define C getchar() Tp f = 1;x = 0; char k = C; while (k &lt; '0' || k &gt; '9') &#123;if (k == '-') f = -1; k = C;&#125; while (k &gt;= '0' &amp;&amp; k &lt;= '9') &#123;x = x * 10 + k - '0'; k = C;&#125; x = x * f; #undef C &#125; template &lt;typename Tp&gt; inline void write(Tp x) &#123; if (x &lt; 0) putchar('-') , x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0'); &#125; template &lt;typename Tp&gt; inline Tp max(Tp a, Tp b) &#123; if (a &gt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline Tp min(Tp a, Tp b) &#123; if (a &lt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline void swap(Tp &amp;a, Tp &amp;b) &#123; Tp t = a; a = b; b = t; &#125; template &lt;typename Tp&gt; inline Tp abs(Tp &amp;a) &#123; if (a &lt; 0) return -a; else return a; &#125; inline void sp() &#123; putchar(32); &#125; inline void et() &#123; putchar(10); &#125;&#125;using namespace STman;struct Edge &#123; int v, nx;&#125;e[MAXN * 10];int head[MAXN], ecnt, n, m, tot, mtch[MAXN], ma, x, y;int vis[MAXN], dx[] = &#123;0, -1, -2, 1, 2, -1, -2, 1, 2&#125;, dy[] = &#123;0, -2, -1, -2, -1, 2, 1, 2, 1&#125;;bool mp[302][302];char s[MAXN];inline int z(int i, int j) &#123; return (i - 1) * n + j;&#125;void add(int f, int t) &#123; e[++ecnt] = (Edge) &#123;t, head[f]&#125;; head[f] = ecnt;&#125;bool Hungary(int k, int t) &#123; for (int i = head[k]; i; i = e[i].nx) &#123; int to = e[i].v; if (vis[to] != t) &#123; vis[to] = t; if (!mtch[to] || Hungary(mtch[to], t)) &#123; mtch[to] = k; return 1; &#125; &#125; &#125; return 0;&#125;int main() &#123; read(n), read(m); memset(mp, 1, sizeof(mp)); for (int i = 1; i &lt;= m; i++) &#123; read(x), read(y); mp[x][y] = 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (mp[i][j]) &#123; tot++; for (int k = 1; k &lt;= 8; k++) &#123; int tx = i + dx[k], ty = j + dy[k]; if (tx &gt; n || tx &lt; 1 || ty &gt; n || ty &lt; 1 || !mp[tx][ty]) continue; add(z(i, j), z(tx, ty)); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (mp[i][j]) &#123; if (Hungary(z(i, j), z(i, j))) ma++; &#125; &#125; &#125; write(tot - (ma &gt;&gt; 1)); return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"二分图","slug":"二分图","permalink":"https://stevebraveman.github.io/tags/二分图/"},{"name":"最大匹配","slug":"最大匹配","permalink":"https://stevebraveman.github.io/tags/最大匹配/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"https://stevebraveman.github.io/tags/最大流/"},{"name":"网络流24题","slug":"网络流24题","permalink":"https://stevebraveman.github.io/tags/网络流24题/"}]},{"title":"-数论-线段树-逆元- [洛谷 P5142]区间方差","slug":"82","date":"2019-05-24T09:36:07.000Z","updated":"2019-08-08T10:44:19.916Z","comments":true,"path":"2019/05/24/82/","link":"","permalink":"https://stevebraveman.github.io/2019/05/24/82/","excerpt":"题目描述Link","text":"题目描述Link Solution一看到区间操作，我们就想到了线段树 但是我们要处理的是这个： \\sum^r_{i=l}\\frac{(x_i-\\overline{x})^2}{n}该如何处理呢？ 让我们来一步一步化简： \\begin{align} \\sum^r_{i=l}\\frac{(x_i-\\overline{x})^2}{(r - l + 1)} &= \\frac{1}{(r - l + 1)}\\sum^r_{i=l}(x_i-\\overline{x})^2 \\\\\\ &= \\frac{1}{(r - l + 1)}\\sum^r_{i=l}(x_i ^ 2-2x\\overline{x}+\\overline{x}^2) \\\\\\ &= \\frac{1}{(r - l + 1)}\\sum^r_{i=l}x_i ^ 2-\\frac{2\\overline{x}}{(r - l + 1)}\\sum^r_{i=l} x+\\overline{x}^2 \\end{align}​然后我们就可以用线段树来维护两个操作：区间和和区间平方和。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define ls(x) ((x) &lt;&lt; 1)#define rs(x) ((x) &lt;&lt; 1 | 1)#define MAXN 100010#define ll long long#define MOD 1000000007struct Segtree &#123; ll a[MAXN], b[MAXN &lt;&lt; 2], sqr[MAXN &lt;&lt; 2]; void pd(ll p) &#123; b[p] = b[ls(p)] + b[rs(p)]; sqr[p] = sqr[ls(p)] + sqr[rs(p)]; &#125; void build(ll l, ll r, ll p) &#123; if (l == r) &#123; b[p] = a[l]; sqr[p] = a[l] * a[l] % MOD; return; &#125; ll m = (l + r) &gt;&gt; 1; build(l, m, ls(p)); build(m + 1, r, rs(p)); pd(p); &#125; void change(ll x, ll l, ll r, ll p, ll k) &#123; if (l == r) &#123; b[p] = k; sqr[p] = k * k % MOD; return; &#125; ll m = (l + r) &gt;&gt; 1; if (x &lt;= m) change(x, l, m, ls(p), k); else change(x, m + 1, r, rs(p), k); pd(p); &#125; ll asksum(ll x, ll y, ll l, ll r, ll p) &#123; ll s = 0; if (x &lt;= l &amp;&amp; y &gt;= r) &#123; return b[p]; &#125; ll m = (l + r) &gt;&gt; 1; if (x &lt;= m) s = (s + asksum(x, y, l, m, ls(p))) % MOD; if (y &gt; m) s = (s + asksum(x, y, m + 1, r, rs(p))) % MOD; return s % MOD; &#125; ll asksqr(ll x, ll y, ll l, ll r, ll p) &#123; ll s = 0; if (x &lt;= l &amp;&amp; y &gt;= r) &#123; return sqr[p] % MOD; &#125; ll m = (l + r) &gt;&gt; 1; if (x &lt;= m) s = (s + asksqr(x, y, l, m, ls(p))) % MOD; if (y &gt; m) s = (s + asksqr(x, y, m + 1, r, rs(p))) % MOD; return s % MOD; &#125;&#125; tr;ll qpow(ll a, ll b, ll mod) &#123; ll res = 1; while (b) &#123; if (b &amp; 1) res = (res * a) % mod; b &gt;&gt;= 1; a = (a * a) % MOD; &#125; return res % MOD;&#125;ll n, m, op, l, r, k, ny, ans, aver, ans2, p;int main() &#123; scanf(\"%lld%lld\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld\", &amp;tr.a[i]); &#125; tr.build(1, n, 1); while (m--) &#123; scanf(\"%lld%lld%lld\", &amp;op, &amp;l, &amp;r); if (op == 1) &#123; tr.change(l, 1, n, 1, r); &#125; else &#123; if (l == r) &#123; puts(\"0\"); continue; &#125; ans = 0; aver = 0; p = tr.asksum(l, r, 1, n, 1) % MOD; ny = qpow(r - l + 1, MOD - 2, MOD); aver = (p % MOD * ny) % MOD; ans += tr.asksqr(l, r, 1, n, 1); ans2 = 2 * (p % MOD * aver) % MOD; ans -= ans2; ans = (ans % MOD + MOD) % MOD; ans += (r - l + 1) * (aver * aver % MOD) % MOD; ans = (ans * ny) % MOD; printf(\"%lld\\n\", ans); &#125; &#125;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"},{"name":"线段树","slug":"线段树","permalink":"https://stevebraveman.github.io/tags/线段树/"},{"name":"逆元","slug":"逆元","permalink":"https://stevebraveman.github.io/tags/逆元/"}]},{"title":"-模拟退火- [洛谷 P3936]Coloring","slug":"81","date":"2019-05-21T07:23:57.000Z","updated":"2019-08-08T10:44:42.262Z","comments":true,"path":"2019/05/21/81/","link":"","permalink":"https://stevebraveman.github.io/2019/05/21/81/","excerpt":"题目描述Link","text":"题目描述Link Solution真是goushi！ 这道题让我看出了我是有多非。。。。 提交了整整6页啊，整整6页！（不过我开小号提交不怕） 其实这道题本身没什么难的，就是随机交换两数，然后在进行判断进行退火的过程就好了。 为那些处在水深火热的提交中发几个我AC时的参数（估计没啥用）： $T:1.0​$ $\\Delta T:0.99998$ 随机数种子：$19* * * *17$这玩意我不说你们也知道 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#pragma GCC optimize(3)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#define delta 0.99998#define MAXN 100010#define random(a, b) ((rand() % (b - a + 1)) + (a))int n, m, c, p[MAXN], G[100][100], tot, nowG[100][100], _p, chG[100][100];template &lt;typename Tp&gt;void swap(Tp &amp;a, Tp &amp;b) &#123; Tp t = a; a = b; b = t;&#125;int Q() &#123; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (nowG[i][j] != nowG[i][j - 1]) ans++; if (nowG[i][j] != nowG[i - 1][j]) ans++; if (nowG[i][j] != nowG[i][j + 1]) ans++; if (nowG[i][j] != nowG[i + 1][j]) ans++; &#125; &#125; return ans;&#125;void copy(bool flag) &#123; if (flag) &#123; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; chG[i][j] = nowG[i][j]; &#125; &#125; return; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; G[i][j] = chG[i][j]; &#125; &#125; return;&#125;void SA() &#123; long double t = 1.0; _p = tot; while (t &gt; 1e-14) &#123; int x1 = random(1, n); int y1 = random(1, m); int x2 = random(1, n); int y2 = random(1, m); if (nowG[x1][y1] == nowG[x2][y2]) continue; std::swap(nowG[x1][y1], nowG[x2][y2]); int now = Q(); int dt = now - _p; if (dt &lt; 0 || (exp(-dt * 1.0 / t) * RAND_MAX &gt; ((rand() % 1000000) / 1000000.0))) &#123; copy(1); _p = now; &#125; else &#123; std::swap(nowG[x1][y1], nowG[x2][y2]); &#125; if (_p &lt;= tot) &#123; tot = _p; copy(0); &#125; t *= delta; &#125;&#125;int main() &#123; srand(19260817); // srand(rand() * rand()); // srand(rand()); // srand(rand()); // srand(rand()); scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;c); for (int i = 1; i &lt;= c; i++) &#123; scanf(\"%d\", &amp;p[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; int col = rand() % c + 1; while (!p[col]) col = rand() % c + 1; G[i][j] = col; nowG[i][j] = col; p[col]--; &#125; &#125; tot = Q(); _p = tot; SA(); SA(); SA(); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; printf(\"%d \", G[i][j]); &#125; puts(\"\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"模拟退火","slug":"模拟退火","permalink":"https://stevebraveman.github.io/tags/模拟退火/"}]},{"title":"-网络流-最大流-二分图-强连通分量- [洛谷 P3731][HAOI2017]新型城市化","slug":"80","date":"2019-05-13T10:53:20.000Z","updated":"2019-08-08T10:44:58.460Z","comments":true,"path":"2019/05/13/80/","link":"","permalink":"https://stevebraveman.github.io/2019/05/13/80/","excerpt":"题目描述Link","text":"题目描述Link Solution这道题太技巧了 用人话说这道题：求出二分图最大匹配的必须边 于是这道题就简单了一半 先按照题意建好二分图，然后在用Dinic跑二分图最大匹配。 对于每一条边 $(u,v)$，如果这条边满流，那么就连新边 $v -&gt; u$，否则，连 $u -&gt; v$。 存在这样一个结论：如果边 $(x,y)$ 在最大匹配中，则 $x,y$ 不在同一强连通分量内（我不会证明）。 所以在残量网络上跑Tarjan就行了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define MAXN 1000010#define INF 2000000000struct Edge &#123; int v, nx, w;&#125;e[MAXN &lt;&lt; 2], _e[MAXN &lt;&lt; 2];struct E &#123; int x, y;&#125;a[MAXN &lt;&lt; 2];int _head[MAXN], head[MAXN], ecnt = 1, _ecnt, n, m, col[MAXN], dep[MAXN], cur[MAXN];int dfn[MAXN], low[MAXN], tim, st[MAXN], top, num, in[MAXN], r, k, cnt;bool vis[MAXN];bool cmp(E x, E y) &#123; return x.x &lt; y.x || (x.x == y.x &amp;&amp; x.y &lt; y.y);&#125;int min(int a, int b) &#123; if (a &lt; b) return a; else return b;&#125;void add(int f, int t, int w) &#123; e[++ecnt] = (Edge) &#123;t, head[f], w&#125;; head[f] = ecnt; e[++ecnt] = (Edge) &#123;f, head[t], 0&#125;; head[t] = ecnt;&#125;void _add(int f, int t) &#123; _e[++_ecnt] = (Edge) &#123;t, _head[f], 0&#125;; _head[f] = _ecnt;&#125;bool bfs(int s, int t) &#123; memset(dep, 0x7f, sizeof(dep)); dep[s] = 0; for (int i = 1; i &lt;= k; i++) &#123; cur[i] = head[i]; &#125; std::queue &lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (dep[to] &gt; INF &amp;&amp; e[i].w) &#123; dep[to] = dep[u] + 1; q.push(to); &#125; &#125; &#125; return dep[t] &lt; INF;&#125;int dfs(int s, int t, int l) &#123; if (!l || s == t) &#123; return l; &#125; int fl = 0, f; for (int i = cur[s]; i; i = e[i].nx) &#123; cur[s] = i; int to = e[i].v; if (dep[to] == dep[s] + 1 &amp;&amp; (f = dfs(to, t, min(l, e[i].w)))) &#123; fl += f; l -= f; e[i].w -= f; e[i ^ 1].w += f; if (!l) break; &#125; &#125; return fl;&#125;int Dinic(int s, int t) &#123; int maxf = 0; while (bfs(s, t)) &#123; maxf += dfs(s, t, INF); &#125; return maxf;&#125;void tarjan(int u) &#123; dfn[u] = low[u] = ++tim; st[++top] = u; vis[u] = 1; for (int i = _head[u]; i; i = _e[i].nx) &#123; int v = _e[i].v; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (vis[v]) low[u] = min(low[u], dfn[v]); &#125; if (dfn[u] == low[u]) &#123; num++; int v; do &#123; v = st[top--]; vis[v] = 0; in[v] = num; &#125; while (u != v); &#125;&#125;void dfscol(int x, int cr) &#123; col[x] = cr; for (int i = _head[x]; i; i = _e[i].nx) &#123; int to = _e[i].v; if (!col[to]) &#123; dfscol(to, 3 - cr); &#125; &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); r = n + 1; k = r + 1; for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%d%d\", &amp;a[i].x, &amp;a[i].y); _add(a[i].x, a[i].y); _add(a[i].y, a[i].x); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!col[i]) dfscol(i, 1); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (col[i] == 1) &#123; add(r, i, 1); &#125; if (col[i] == 2) &#123; add(i, k, 1); &#125; &#125; memset(_head, 0, sizeof(_head)); _ecnt = 0; memset(_e, 0, sizeof(_e)); for (int i = 1; i &lt;= m; i++) &#123; if (col[a[i].x] == 1) &#123; add(a[i].x, a[i].y, 1); &#125; if (col[a[i].y] == 1) &#123; add(a[i].y, a[i].x, 1); &#125; &#125; int tot = Dinic(r, k); // for (int i = 1; i &lt;= n; i++) &#123; // if (col[i] == 1) &#123; // for (int j = head[i]; j; j = e[j].nx) &#123; // if (!e[j].w &amp;&amp; e[j].v != r) &#123; // printf(\"%d -&gt; %d\\n\", i, e[j].v); // &#125; // &#125; // &#125; // &#125; for (int i = head[r]; i; i = e[i].nx) &#123; int to = e[i].v; if (!e[i].w) &#123; _add(to, r); &#125; if (e[i].w) &#123; _add(r, to); &#125; for (int j = head[to]; j; j = e[j].nx) &#123; int v = e[j].v; if (v == r) continue; if (e[j].w) &#123; _add(to, v); &#125; else &#123; _add(v, to); &#125; &#125; &#125; for (int i = head[k]; i; i = e[i].nx) &#123; int to = e[i].v; // printf(\"%d -- %d --&gt; %d\\n\", k, e[i].w, to); if (e[i].w) &#123; _add(k, to); // printf(\"%d -&gt; %d\\n\", to, k); &#125; if (!e[i].w) &#123; _add(to, k); // printf(\"%d -&gt; %d\\n\", k, to); &#125; &#125; for (int i = 1; i &lt;= n + 2; i++) &#123; if (!dfn[i]) tarjan(i); &#125; memset(a, 0, sizeof(a)); for (int i = 1; i &lt;= n; i++) &#123; if (col[i] == 1) &#123; for (int j = head[i]; j; j = e[j].nx) &#123; int v = e[j].v; if (v == r) continue; if (!e[j].w) &#123; a[++cnt].x = i; a[cnt].y = v; if (a[cnt].x &gt; a[cnt].y) std::swap(a[cnt].x, a[cnt].y); &#125; &#125; &#125; &#125; tot = 0; // for (int i = 1; i &lt;= n; i++) &#123; // printf(\"%d \", in[i]); // &#125; // puts(\"\"); for (int i = 1; i &lt;= cnt; i++) &#123; if (in[a[i].x] != in[a[i].y]) &#123; if (a[i].x &gt; a[i].y) std::swap(a[i].x, a[i].y); tot++; &#125; &#125; std::sort(a + 1, a + 1 + cnt, cmp); printf(\"%d\\n\", tot); for (int i = 1; i &lt;= cnt; i++) &#123; if (in[a[i].x] != in[a[i].y]) &#123; printf(\"%d %d\\n\", a[i].x, a[i].y); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"二分图","slug":"二分图","permalink":"https://stevebraveman.github.io/tags/二分图/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"https://stevebraveman.github.io/tags/最大流/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://stevebraveman.github.io/tags/强连通分量/"}]},{"title":"-网络流-费用流- [洛谷 P3356][网络流24题]火星探险问题","slug":"79","date":"2019-05-09T09:46:05.000Z","updated":"2019-08-08T10:45:32.242Z","comments":true,"path":"2019/05/09/79/","link":"","permalink":"https://stevebraveman.github.io/2019/05/09/79/","excerpt":"题目描述Link","text":"题目描述Link Solution这道题其实和这道题比较类似，只是多了有些方格不能走的的条件，所以我们就直接不建那些方格的边，其他模型和那道题一样，建完之后再跑费用流就行了。 网络流24题最毒瘤之处莫过于输出方案 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#define MAXN 1000010#define INF 2000000000struct Edge &#123; int v, nx, w, c;&#125;e[MAXN &lt;&lt; 2];int head[MAXN], b[MAXN], ecnt = 1, nc, n, m, x, y, z;int pre[MAXN], maxf, minc, dis[MAXN], la[MAXN], flow[MAXN], r, k, tot;bool vis[MAXN];template &lt;typename Tp&gt;Tp min(Tp a, Tp b) &#123; if (a &lt; b) return a; else return b;&#125;void add(int f, int t, int w, int c) &#123; e[++ecnt] = (Edge) &#123;t, head[f], w, c&#125;; head[f] = ecnt; e[++ecnt] = (Edge) &#123;f, head[t], 0, -c&#125;; head[t] = ecnt;&#125;bool spfa(int s, int t) &#123; memset(dis, 0x7f, sizeof(dis)); memset(flow, 0x7f, sizeof(flow)); memset(vis, 0, sizeof(vis)); pre[t] = -1; dis[s] = 0; vis[s] = 1; std::queue &lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int v = q.front(); q.pop(); vis[v] = 0; for (int i = head[v]; i; i = e[i].nx) &#123; int f = e[i].w; int to = e[i].v; if (f &gt; 0 &amp;&amp; dis[to] &gt; dis[v] + e[i].c) &#123; dis[to] = dis[v] + e[i].c; pre[to] = v; la[to] = i; flow[to] = min(flow[v], f); if (!vis[to]) &#123; vis[to] = 1; q.push(to); &#125; &#125; &#125; &#125; return pre[t] != -1;&#125;void mcmf(int s, int t) &#123; while (spfa(s, t)) &#123; int v = t; maxf += flow[t]; minc += flow[t] * dis[t]; while (v != s) &#123; int k = la[v]; e[k].w -= flow[t]; e[k ^ 1].w += flow[t]; v = pre[v]; &#125; &#125;&#125;int g(int i, int j) &#123; return (i - 1) * m + j;&#125;void dfs(int car, int u) &#123; if (u == g(n, m) + n * m) return; for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (e[i ^ 1].w &amp;&amp; u &lt; to + n * m) &#123; e[i ^ 1].w--; printf(\"%d %d\\n\", car, (n * m - (u - to)) == 1); return dfs(car, to + n * m); &#125; &#125;&#125;int main() &#123; scanf(\"%d%d%d\", &amp;nc, &amp;m, &amp;n); r = n * m * 2 + 1; k = r + 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf(\"%d\", &amp;x); if (x == 1) continue; add(g(i, j), g(i, j) + n * m, INF, 0); if (x == 2) &#123; add(g(i, j), g(i, j) + n * m, 1, -1); &#125; if (i &gt; 1) add(g(i - 1, j) + n * m, g(i, j), INF, 0); if (j &gt; 1) add(g(i, j - 1) + n * m, g(i, j), INF, 0); &#125; &#125; add(r, g(1, 1), nc, 0); add(g(n, m) + n * m, k, nc, 0); mcmf(r, k); for (int i = 1; i &lt;= nc; i++) &#123; dfs(i, g(1, 1) + n * m); &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"网络流24题","slug":"网络流24题","permalink":"https://stevebraveman.github.io/tags/网络流24题/"},{"name":"费用流","slug":"费用流","permalink":"https://stevebraveman.github.io/tags/费用流/"}]},{"title":"-网络流-费用流- [洛谷 P3965][TJOI2013]循环格","slug":"78","date":"2019-04-29T08:34:23.000Z","updated":"2019-08-08T10:45:49.451Z","comments":true,"path":"2019/04/29/78/","link":"","permalink":"https://stevebraveman.github.io/2019/04/29/78/","excerpt":"题目描述Link","text":"题目描述Link Solution这道题我们可以先将其拆点，把每个点拆成 $x$ 和 $x’$，然后将源点连向每个 $x$ ，将每个 $x’$ 连向汇点，最后根据题目中的所给的方向连边，设一个点 $x$ 指向点 $y$，那么就把 $x$ 和 $y’$ 连一条流量为 $1$，费用为 $0$ 的边，在从这个点向其它 $3$ 个方向连一条流量为 $1$ 费用为 $1$ 的边，再跑最小费用最大流就可以了。 PS：min 和 max 函数写错进然还能过样例 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAXN 1001000template &lt;typename Tp&gt;Tp min(Tp a, Tp b) &#123; if (a &lt; b) return a; else return b;&#125;struct Edge &#123; int v, nx, w, c;&#125;e[MAXN &lt;&lt; 2];int head[MAXN], ecnt = 1, n, m, x, y, dis[MAXN], flow[MAXN], pre[MAXN];int la[MAXN], maxf, minc, z, c, r, k, g[20][20], cnt;bool vis[MAXN];char a[20][20];void add(int f, int t, int w, int c) &#123; e[++ecnt] = (Edge) &#123;t, head[f], w, c&#125;; head[f] = ecnt; e[++ecnt] = (Edge) &#123;f, head[t], 0, -c&#125;; head[t] = ecnt;&#125;bool spfa(int s, int t) &#123; memset(dis, 0x7f, sizeof(dis)); memset(vis, 0, sizeof(vis)); memset(flow, 0x7f, sizeof(flow)); pre[t] = -1; dis[s] = 0; std::queue &lt;int&gt; q; q.push(s); vis[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = 0; for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (dis[to] &gt; dis[u] + e[i].c &amp;&amp; e[i].w) &#123; dis[to] = dis[u] + e[i].c; pre[to] = u; la[to] = i; flow[to] = min(flow[u], e[i].w); if (!vis[to]) &#123; vis[to] = 1; q.push(to); &#125; &#125; &#125; &#125; return pre[t] != -1;&#125;void mcmf(int s, int t) &#123; while (spfa(s, t)) &#123; maxf += flow[t]; minc += flow[t] * dis[t]; int v = t; while (v != s) &#123; int k = la[v]; e[k].w -= flow[t]; e[k ^ 1].w += flow[t]; v = pre[v]; &#125; &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); r = 2 * n * m + 1; k = r + 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; std::cin &gt;&gt; a[i][j]; g[i][j] = ++cnt; &#125; &#125; for (int i = 1; i &lt;= n * m; i++) &#123; add(r, i, 1, 0); add(i + n * m, k, 1, 0); &#125; for (int i = 1; i &lt;= m; i++) &#123; g[0][i] = g[n][i]; g[n + 1][i] = g[1][i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; g[i][0] = g[i][m]; g[i][m + 1] = g[i][1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (a[i][j] == 'U') add(g[i][j], g[i - 1][j] + n * m, 1, 0); else add(g[i][j], g[i - 1][j] + n * m, 1, 1); if (a[i][j] == 'D') add(g[i][j], g[i + 1][j] + n * m, 1, 0); else add(g[i][j], g[i + 1][j] + n * m, 1, 1); if (a[i][j] == 'L') add(g[i][j], g[i][j - 1] + n * m, 1, 0); else add(g[i][j], g[i][j - 1] + n * m, 1, 1); if (a[i][j] == 'R') add(g[i][j], g[i][j + 1] + n * m, 1, 0); else add(g[i][j], g[i][j + 1] + n * m, 1, 1); &#125; &#125; // puts(\"OK\"); mcmf(r, k); printf(\"%d\", minc); return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"费用流","slug":"费用流","permalink":"https://stevebraveman.github.io/tags/费用流/"}]},{"title":"-学习笔记-树套树- 树套树学习笔记","slug":"77","date":"2019-04-24T00:35:32.000Z","updated":"2019-08-08T10:46:16.276Z","comments":true,"path":"2019/04/24/77/","link":"","permalink":"https://stevebraveman.github.io/2019/04/24/77/","excerpt":"我学了很酷很炫的算法，我失败了","text":"我学了很酷很炫的算法，我失败了 其实各类树套树都差不多，在这里主要说线段树套平衡树 线段树套一个平衡树，就是在线段树里的每个节点都开一个平衡树来存储这个节点所表示区间里的所有的数（如图所示）。 因此，建树这样建： 12345678910void build(int l, int r, int p) &#123; for (int i = l; i &lt;= r; i++) &#123; insert(rt[p], a[i]); &#125; if (l != r) &#123; int m = (l + r) &gt;&gt; 1; build(l, m, ls(p)); build(m + 1, r, rs(p)); &#125;&#125; 建树的时间复杂度为 $O(n \\log ^ 2 n)$。 关于建树的时间复杂度让我们来分析一下： 首先，对于线段树的每一层，都有 $n$ 个数被插入，而平衡树的插入操作时间复杂度是 $O(\\log n)$ 的，因此，线段树每层的时间复杂度为 $O(n \\log n)$ 的，并且，线段树至多有 $\\log n$ 层，所以总的建树时间复杂度为 $O(n \\log ^ 2 n)$。 下面讲一下动态查询区间第K大。 这是最最常见的用法，其实现原理就是在这个区间里进行二分。 虽然动态查询第K大用树状数组+整体二分也能做，但是树套树可以强制在线 1234567891011int RgKth(int x, int y, int l, int r, int k, int p) &#123; int ql = 0, qr = 100000000; while (ql &lt; qr) &#123; int m = (ql + qr + 1) &gt;&gt; 1; if (RgRk(x, y, 1, n, m, 1) &lt; k) &#123; // 查询这个数在这个区间内的排名 ql = m; &#125; else qr = m - 1; &#125; return qr;&#125; 此操作时间复杂度为 $O(n \\log^3 n)$。 动态查询第K大还有一种常见的写法是树状数组套主席树，这种方法虽然时间复杂度小，但是空间复杂度较大，在这里不进行讲解其实就是自己不会 动态查询第K大例题： Dynamic Rankings [ZJOI2013]K大数查询 线段树套平衡树板子题：【模板】二逼平衡树（树套树） Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222// 线段树套Treap#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#define MAXN 2000020#define INF 0x7fffffff#define ls(x) ((x) &lt;&lt; 1)#define rs(x) ((x) &lt;&lt; 1 | 1)int max(int a, int b) &#123; if (a &gt; b) return a; else return b;&#125;int min(int a, int b) &#123; if (a &lt; b) return a; else return b;&#125;struct Treap &#123; int l, r; int val, dat; int cnt, size;&#125;a[MAXN];int tot, n, m;int New(int val) &#123; a[++tot].val = val; a[tot].dat = rand(); a[tot].cnt = a[tot].size = 1; return tot;&#125;void update(int p) &#123; a[p].size = a[a[p].l].size + a[a[p].r].size + a[p].cnt;&#125;int FindR(int p, int val) &#123; // printf(\"%d %d %d\\n\", p, a[p].val, val); if (p == 0) return 0; if (val == a[p].val) return a[a[p].l].size; else if (val &lt; a[p].val) return FindR(a[p].l, val); else return FindR(a[p].r, val) + a[a[p].l].size + a[p].cnt;&#125;void zig(int &amp;p) &#123; int q = a[p].l; a[p].l = a[q].r, a[q].r = p, p = q; update(a[p].r), update(p);&#125;void zag(int &amp;p) &#123; int q = a[p].r; a[p].r = a[q].l, a[q].l = p, p = q; update(a[p].l), update(p);&#125;void insert(int &amp;p, int val) &#123; if (p == 0) &#123; p = New(val); return; &#125; if (val == a[p].val) &#123; a[p].cnt++, update(p); return; &#125; if (val &lt; a[p].val) &#123; insert(a[p].l, val); if (a[p].dat &lt; a[a[p].l].dat) zig(p); &#125; else &#123; insert(a[p].r, val); if (a[p].dat &lt; a[a[p].r].dat) zag(p); &#125; update(p);&#125;int Pre(int p, int val) &#123; if (!p) &#123; return -INF; &#125; if (a[p].val &gt;= val) &#123; return Pre(a[p].l, val); &#125; else &#123; return max(a[p].val, Pre(a[p].r, val)); &#125;&#125;int Next(int p, int val) &#123; if (!p) &#123; return INF; &#125; if (a[p].val &lt;= val) &#123; return Next(a[p].r, val); &#125; else &#123; return min(a[p].val, Next(a[p].l, val)); &#125;&#125;void Remove(int &amp;p, int val) &#123; if (p == 0) return; if (val == a[p].val) &#123; if (a[p].cnt &gt; 1) &#123; a[p].cnt--, update(p); return; &#125; if (a[p].l || a[p].r) &#123; if (a[p].r == 0 || a[a[p].l].dat &gt; a[a[p].r].dat) zig(p), Remove(a[p].r, val); else zag(p), Remove(a[p].l, val); update(p); &#125; else p = 0; return; &#125; val &lt; a[p].val ? Remove(a[p].l, val) : Remove(a[p].r, val); update(p);&#125;struct Segtree &#123; int a[MAXN], b[MAXN], rt[MAXN]; void build(int l, int r, int p) &#123; for (int i = l; i &lt;= r; i++) &#123; insert(rt[p], a[i]); &#125; if (l != r) &#123; int m = (l + r) &gt;&gt; 1; build(l, m, ls(p)); build(m + 1, r, rs(p)); &#125; &#125; void change(int x, int l, int r, int k, int p) &#123; Remove(rt[p], a[x]); insert(rt[p], k); if (l == r) &#123; return; &#125; int m = (l + r) &gt;&gt; 1; if (x &lt;= m) change(x, l, m, k, ls(p)); else change(x, m + 1, r, k, rs(p)); &#125; int RgRk(int x, int y, int l, int r, int k, int p) &#123; if (l &gt; y || r &lt; x) &#123; return 0; &#125; // printf(\"%d\\n\", p); if (l &gt;= x &amp;&amp; y &gt;= r) &#123; return FindR(rt[p], k); &#125; else &#123; int m = (l + r) &gt;&gt; 1; return RgRk(x, y, l, m, k, ls(p)) + RgRk(x, y, m + 1, r, k, rs(p)); &#125; &#125; int RgKth(int x, int y, int l, int r, int k, int p) &#123; int ql = 0, qr = 100000000; while (ql &lt; qr) &#123; int m = (ql + qr + 1) &gt;&gt; 1; if (RgRk(x, y, 1, n, m, 1) &lt; k) &#123; ql = m; &#125; else qr = m - 1; &#125; return qr; &#125; int RgPre(int x, int y, int l, int r, int k, int p) &#123; if (l &gt; y || r &lt; x) &#123; return -INF; &#125; if (l &gt;= x &amp;&amp; y &gt;= r) &#123; return Pre(rt[p], k); &#125; else &#123; int m = (l + r) &gt;&gt; 1; return max(RgPre(x, y, l, m, k, ls(p)), RgPre(x, y, m + 1, r, k, rs(p))); &#125; &#125; int RgNext(int x, int y, int l, int r, int k, int p) &#123; if (l &gt; y || r &lt; x) &#123; return INF; &#125; if (l &gt;= x &amp;&amp; y &gt;= r) &#123; return Next(rt[p], k); &#125; else &#123; int m = (l + r) &gt;&gt; 1; return min(RgNext(x, y, l, m, k, ls(p)), RgNext(x, y, m + 1, r, k, rs(p))); &#125; &#125;&#125;tr;int op, l, r, k;int main() &#123; srand(time(NULL)); scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;tr.a[i]); &#125; tr.build(1, n, 1); while (m--) &#123; scanf(\"%d\", &amp;op); switch (op) &#123; case 1: &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); printf(\"%d\\n\", tr.RgRk(l, r, 1, n, k, 1) + 1); break; &#125; case 2: &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); printf(\"%d\\n\", tr.RgKth(l, r, 1, n, k, 1)); break; &#125; case 3: &#123; scanf(\"%d%d\", &amp;l, &amp;r); tr.change(l, 1, n, r, 1); tr.a[l] = r; break; &#125; case 4: &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); printf(\"%d\\n\", tr.RgPre(l, r, 1, n, k, 1)); break; &#125; case 5: &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); printf(\"%d\\n\", tr.RgNext(l, r, 1, n, k, 1)); break; &#125; &#125; &#125;&#125; 如果我又学了新的树套树，到时候再更。","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://stevebraveman.github.io/tags/学习笔记/"},{"name":"树套树","slug":"树套树","permalink":"https://stevebraveman.github.io/tags/树套树/"}]},{"title":"-网络流-费用流- [洛谷 P4329][COCI2006-2007#1] Bond","slug":"76","date":"2019-04-23T13:47:47.000Z","updated":"2019-08-08T10:46:25.361Z","comments":true,"path":"2019/04/23/76/","link":"","permalink":"https://stevebraveman.github.io/2019/04/23/76/","excerpt":"题目描述Link","text":"题目描述Link Solution首先，能够很容易看出来，这是个二分图最大权匹配的模型 但是唯一不同的是，求的是乘积而不是和 所以我们可以运用 $\\log$ 的性质：$\\log ab = \\log a + \\log b$ 来把这道题转换为和的形式 如果担心精度会炸，那就开 $\\texttt{long double}$ 最后跑一遍费用流就行了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define MAXN 100010struct Edge &#123; int v, nx, fl; long double w;&#125;e[MAXN];int n, m, s, t, head[MAXN], ecnt = 1, flow[MAXN], maxf, la[MAXN], pre[MAXN], x, y, z, f;long double dis[MAXN], minc, k;bool vis[MAXN];template &lt;typename Tp&gt;Tp min(Tp a, Tp b) &#123; if (a &lt; b) return a; else return b;&#125;std::queue &lt;int&gt; q;void add(int f, int t, int fl, long double w) &#123; e[++ecnt] = (Edge) &#123;t, head[f], fl, w&#125;; head[f] = ecnt; e[++ecnt] = (Edge) &#123;f, head[t], 0, -w&#125;; head[t] = ecnt;&#125;bool spfa(int s, int t) &#123; for (int i = 1; i &lt;= 2 * n + 2; i++) &#123; dis[i] = 9999999.9; &#125; memset(flow, 0x7f, sizeof(flow)); memset(vis, 0, sizeof(vis)); q.push(s); dis[s] = 0.0; vis[s] = 1; pre[t] = -1; while (!q.empty()) &#123; int v = q.front(); q.pop(); vis[v] = 0; for (int i = head[v]; i; i = e[i].nx) &#123; int f = e[i].fl; int to = e[i].v; if (f &gt; 0 &amp;&amp; dis[to] &gt; dis[v] + e[i].w) &#123; dis[to] = dis[v] + e[i].w; pre[to] = v; la[to] = i; flow[to] = min(flow[v], f); if (!vis[to]) &#123; vis[to] = 1; q.push(to); &#125; &#125; &#125; &#125; return pre[t] != -1;&#125;void mcmf(int s, int t) &#123; while (spfa(s, t)) &#123; int v = t; minc += (long double)flow[t] * dis[t]; while (v != s) &#123; int k = la[v]; e[k].fl -= flow[t]; e[k ^ 1].fl += flow[t]; v = pre[v]; &#125; &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); s = 2 * n + 1; t = s + 1; for (int i = 1; i &lt;= n; i++) &#123; add(s, i, 1, 0.0); add(i + n, t, 1, 0.0); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; scanf(\"%d\", &amp;x); k = (long double)x / 100.0; k = log2(k); add(i, j + n, 1, -k); &#125; &#125; mcmf(s, t); if (minc == 0.00) &#123; printf(\"0.00000000\\n\"); return 0; &#125; printf(\"%.6f\\n\", pow(2, -minc) * 100.0); return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"费用流","slug":"费用流","permalink":"https://stevebraveman.github.io/tags/费用流/"}]},{"title":"-数论-莫比乌斯反演-容斥- [SP26017]GCDMAT - GCD OF MATRIX","slug":"75","date":"2019-04-18T00:20:07.000Z","updated":"2019-08-08T10:46:35.472Z","comments":true,"path":"2019/04/18/75/","link":"","permalink":"https://stevebraveman.github.io/2019/04/18/75/","excerpt":"题目描述Link","text":"题目描述Link Solution其实如果这道题没有容斥的操作就是这样： \\sum_{i = 1}^n \\sum_{j = 1}^m \\gcd(i, j)然后我们可以推一下： \\sum_{i = 1}^n \\sum_{j = 1}^m \\gcd(i, j)​\\sum_{d = 1}^n \\sum_{i = 1}^n \\sum_{j = 1}^m [\\gcd(i, j) == d]\\sum_{d = 1}^n \\sum_{i = 1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum_{j = 1}^{\\lfloor \\frac{m}{d} \\rfloor} [\\gcd(i ,j) == 1] ​\\sum_{d = 1}^n \\sum_{i = 1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum_{j = 1}^{\\lfloor \\frac{m}{d} \\rfloor} \\sum_{d | \\gcd(i, j)} \\mu(d)​\\sum_{d = 1}^n \\sum_{a = 1}^n \\mu(a) {\\lfloor \\frac{n}{ad} \\rfloor}{\\lfloor \\frac{m}{ad} \\rfloor}​设 $T=ad​$ \\sum_{T = 1}^n {\\lfloor \\frac{n}{T} \\rfloor}{\\lfloor \\frac{m}{T} \\rfloor} \\sum_{d | T} d \\mu({\\lfloor \\frac{T}{d} \\rfloor})​因为 $\\sum_{d | T} d \\mu({\\lfloor \\frac{T}{d} \\rfloor})​$ 这部分是狄利克雷卷积的形式，而 $id * \\mu = \\varphi​$ 所以线性筛一遍欧拉函数再用整除分块就行了。 最后再用容斥瞎搞搞就可以了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 500010#define MOD 1000000007#define ll long long#define int long longint p[MAXN + 10], tot, phi[MAXN + 10], T, g[MAXN + 10], answ;bool chk[MAXN + 10];template &lt;typename Tp&gt;Tp min(Tp a, Tp b) &#123; if (a &lt; b) return a; else return b;&#125;template &lt;typename Tp&gt;Tp max(Tp a, Tp b) &#123; if (a &gt; b) return a; else return b;&#125;void sieve() &#123; phi[1] = 1; chk[1] = true; for (int i = 2; i &lt;= MAXN; i++) &#123; if (!chk[i]) &#123; p[++tot] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= MAXN; j++) &#123; chk[i * p[j]] = 1; if (!(i % p[j])) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; phi[i * p[j]] = phi[i] * phi[p[j]]; &#125; &#125; for (int i = 1; i &lt;= MAXN; i++) &#123; g[i] = (g[i - 1] + phi[i]) % MOD; &#125;&#125;int sum(int x, int y) &#123; int n = min(x, y); int m = max(x, y); ll ans = 0; for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ans += (((n / l) % MOD * (m / l) % MOD) % MOD) * ((g[r] - g[l - 1] + MOD) % MOD) % MOD; &#125; return (ans % MOD);&#125;int a, b, c, d, n, m;signed main() &#123; sieve(); scanf(\"%lld\", &amp;T); scanf(\"%lld%lld\", &amp;n, &amp;m); while (T--) &#123; scanf(\"%lld%lld%lld%lld\", &amp;a, &amp;b, &amp;c, &amp;d); answ = (sum(c, d) + sum(a - 1, b - 1) - sum(c, b - 1) - sum(d, a - 1) + 2 * MOD) % MOD; printf(\"%lld\\n\", answ % MOD); &#125;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"},{"name":"容斥","slug":"容斥","permalink":"https://stevebraveman.github.io/tags/容斥/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://stevebraveman.github.io/tags/莫比乌斯反演/"},{"name":"SPOJ","slug":"SPOJ","permalink":"https://stevebraveman.github.io/tags/SPOJ/"}]},{"title":"-整体二分-树状数组- [洛谷 P2617]Dynamic Rankings","slug":"74","date":"2019-04-15T08:59:17.000Z","updated":"2019-08-08T10:46:44.141Z","comments":true,"path":"2019/04/15/74/","link":"","permalink":"https://stevebraveman.github.io/2019/04/15/74/","excerpt":"题目描述Link Solution这题我们用整体二分。","text":"题目描述Link Solution这题我们用整体二分。 为什么不用主席树套树状数组呢？最主要的原因就是我不会。因为主席树再套一个树状数组空间开销有些大，故不用主席树套树状数组虽然我写的整体二分空间占用也小不到那里去 我们只需要把修改操作拆成删除、赋值两个操作就可以了，剩下的就是普通的整体二分查第K大了。 而且别忘了用树状数组维护修改操作。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 200010#define INF 1000000000struct rec &#123; int op, x, y, z;&#125; q[MAXN &lt;&lt; 2], lq[MAXN &lt;&lt; 2], rq[MAXN &lt;&lt; 2];int n, m, t, c[MAXN], ans[MAXN], id, a[MAXN];int ask(int x) &#123; int y = 0; for (; x; x -= x &amp; -x) y += c[x]; return y;&#125;void change(int x, int y) &#123; for (; x &lt;= n; x += x &amp; -x) c[x] += y;&#125;void solve(int lval, int rval, int st, int ed) &#123; if (st &gt; ed) return; if (lval == rval) &#123; for (int i = st; i &lt;= ed; i++) &#123; if (q[i].op &gt; 0) ans[q[i].op] = lval; &#125; return; &#125; int mid = (lval + rval) &gt;&gt; 1; int lt = 0, rt = 0; for (int i = st; i &lt;= ed; i++) &#123; if (q[i].op == 0) &#123; if (q[i].y &lt;= mid) change(q[i].x, 1), lq[++lt] = q[i]; else rq[++rt] = q[i]; &#125; if (q[i].op == -1) &#123; if (q[i].y &lt;= mid) change(q[i].x, -1), lq[++lt] = q[i]; else rq[++rt] = q[i]; &#125; if (q[i].op &gt; 0)&#123; int cnt = ask(q[i].y) - ask(q[i].x - 1); if (cnt &gt;= q[i].z) lq[++lt] = q[i]; else q[i].z -= cnt, rq[++rt] = q[i]; &#125; &#125; for (int i = ed; i &gt;= st; i--) &#123; if (q[i].op == 0 &amp;&amp; q[i].y &lt;= mid) change(q[i].x, -1); if (q[i].op == -1 &amp;&amp; q[i].y &lt;= mid) change(q[i].x, 1); &#125; for (int i = 1; i &lt;= lt; i++) q[st + i - 1] = lq[i]; for (int i = 1; i &lt;= rt; i++) q[st + lt + i - 1] = rq[i]; solve(lval, mid, st, st + lt - 1); solve(mid + 1, rval, st + lt, ed);&#125;int l, r, k;char op[2];int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; int val; scanf(\"%d\", &amp;val); a[i] = val; q[++t].op = 0, q[t].x = i, q[t].y = val; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%s%d%d\", op, &amp;l, &amp;r); if (op[0] == 'Q') &#123; scanf(\"%d\", &amp;k); q[++t].op = ++id, q[t].x = l, q[t].y = r, q[t].z = k; &#125; else &#123; q[++t].op = -1, q[t].x = l, q[t].y = a[l]; q[++t].op = 0, q[t].x = l, q[t].y = r; a[l] = r; &#125; &#125; solve(-INF, INF, 1, t); for (int i = 1; i &lt;= id; i++) &#123; printf(\"%d\\n\", ans[i]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"树状数组","slug":"树状数组","permalink":"https://stevebraveman.github.io/tags/树状数组/"},{"name":"整体二分","slug":"整体二分","permalink":"https://stevebraveman.github.io/tags/整体二分/"}]},{"title":"-DP-贪心- [洛谷 5275]思路题(ak)","slug":"73","date":"2019-04-02T09:47:08.000Z","updated":"2019-08-08T10:46:53.603Z","comments":true,"path":"2019/04/02/73/","link":"","permalink":"https://stevebraveman.github.io/2019/04/02/73/","excerpt":"题目描述Link","text":"题目描述Link Solution这道题的做法就是先按照a的大小排序，然后将此题转换为LIS问题，得用 $O(n \\log n)​$ 的算法 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 100010struct num &#123; int a, b, id;&#125;a[MAXN];int n, d[MAXN], g[MAXN], top, k[MAXN], len;bool cmp(num a, num b) &#123; return a.b &gt; b.b || ((a.b == b.b) &amp;&amp; a.a &lt; b.a);&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i].a); a[i].id = i; &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i].b); &#125; std::sort(a + 1, a + 1 + n, cmp); for (int i = 1; i &lt;= n; i++) &#123; if (a[i].a &gt;= d[top]) d[++top] = a[i].a, g[a[i].id] = top; else &#123; int j = std::upper_bound(d + 1, d + 1 + top, a[i].a) - d; d[j] = a[i].a; g[a[i].id] = j; &#125; &#125; printf(\"%d\\n\", top); len = top; for (int i = n; i &gt;= 1; i--) &#123; if (g[a[i].id] == len)&#123; k[len--] = a[i].id; &#125; if (len &lt; 1) &#123; break; &#125; &#125; for (int i = 1; i &lt;= top; i++) &#123; printf(\"%d \", k[i]); &#125;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"DP","slug":"DP","permalink":"https://stevebraveman.github.io/tags/DP/"},{"name":"贪心","slug":"贪心","permalink":"https://stevebraveman.github.io/tags/贪心/"}]},{"title":"-数论-杜教筛- [BZOJ 4916]神犇和蒟蒻","slug":"72","date":"2019-03-26T12:17:10.000Z","updated":"2019-08-08T10:47:08.090Z","comments":true,"path":"2019/03/26/72/","link":"","permalink":"https://stevebraveman.github.io/2019/03/26/72/","excerpt":"题目描述Link","text":"题目描述Link Solution第一个根本不用筛，答案永远都是1 现在来解决第二个： 我们先把 $\\varphi(x ^ 2)$ 化简一下 我们知道，欧拉函数是这样计算的： \\varphi(x) = x \\prod \\frac{p_i - 1}{p_i}所以设 $x = p_1 ^ {a_1} p_2 ^ {a_2} p_3 ^ {a_3}…p_i ^ {a_i}$ 所以有 x ^ 2 = p_1 ^ {2a_1} p_2 ^ {2a_2} p_3 ^ {2a_3}...p_i ^ {2a_i}所以 \\varphi(x ^ 2) = x \\cdot x \\prod_{i=1}^n \\frac{p_i - 1}{p_i}\\varphi(x ^ 2) = x \\cdot \\varphi(x)于是第二个就变成了 \\sum_{i = 1}^n i \\cdot \\varphi(i)然后就可以用杜教筛了。 设 $f(i) = i \\cdot \\varphi(i)$，$g(n) = \\sum_{i = 1}^n f(i)$ 因为 $id = f * id$ 所以 g(n) = \\sum_{i = 1} ^ n i ^ 2 - \\sum_{i = 1} ^ n i \\cdot \\varphi(\\lfloor \\frac{n}{i} \\rfloor) Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;tr1/unordered_map&gt;#define MAXN 5001000#define MOD 1000000007#define ll long long#define re register#define int long longusing namespace std;tr1::unordered_map&lt;ll, ll&gt; ans2;int p[MAXN], phi[MAXN], tot, t, n;ll pre2[MAXN], kk, tt;bool chk[MAXN];ll qpow(ll a, ll b, ll m) &#123; ll res = 1; while (b) &#123; if (b &amp; 1) res = (res * a) % m; b &gt;&gt;= 1; a = (a * a) % m; &#125; return res % m;&#125;void getshai() &#123; phi[1] = 1; chk[1] = 1; for (int i = 2; i &lt;= MAXN; i++) &#123; if (!chk[i]) &#123; p[++tot] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= MAXN; j++) &#123; chk[i * p[j]] = 1; if (i % p[j]) &#123; phi[i * p[j]] = phi[i] * phi[p[j]]; &#125; else &#123; phi[i * p[j]] = p[j] * phi[i]; break; &#125; &#125; &#125; for (int i = 1; i &lt;= MAXN; i++) &#123; pre2[i] = pre2[i - 1] + (ll)(phi[i] * i) % MOD; pre2[i] %= MOD; &#125;&#125;ll sum(ll a) &#123; return a * (a + 1) % MOD * (2 * a + 1) % MOD * kk % MOD;&#125;ll getphi(ll x) &#123; if (x &lt;= MAXN) return pre2[x]; if (ans2[x]) return ans2[x]; ll ans = sum(x); for (re ll l = 2, r; l &lt;= x; l = r + 1) &#123; r = x / (x / l); ans -= 1LL * (r - l + 1LL) * (l + r) % MOD * tt % MOD * getphi(x / l); ans += MOD; ans %= MOD; &#125; return ans2[x] = ans;&#125;signed main() &#123; getshai(); scanf(\"%d\", &amp;n); kk = qpow(6, MOD - 2, MOD); tt = qpow(2, MOD - 2, MOD); puts(\"1\"); printf(\"%lld\", getphi((ll)n));&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://stevebraveman.github.io/tags/BZOJ/"},{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"},{"name":"杜教筛","slug":"杜教筛","permalink":"https://stevebraveman.github.io/tags/杜教筛/"}]},{"title":"-数论-卷积- 关于积性函数的汇总以及常用的卷积","slug":"71","date":"2019-03-18T05:48:02.000Z","updated":"2019-08-08T10:47:17.772Z","comments":true,"path":"2019/03/18/71/","link":"","permalink":"https://stevebraveman.github.io/2019/03/18/71/","excerpt":"积性函数的定义对于一个函数 $f(x)​$，有互质的两数 $a,b​$，如果函数具有 $f(a b) = f(a) f(b)​$的性质，那么此类型的函数被称为积性函数。 完全积性函数：若一个积性函数 $f(x)$，具有 $f(x ^ k) = f^k(x)$，那么此函数成为完全积性函数。","text":"积性函数的定义对于一个函数 $f(x)​$，有互质的两数 $a,b​$，如果函数具有 $f(a b) = f(a) f(b)​$的性质，那么此类型的函数被称为积性函数。 完全积性函数：若一个积性函数 $f(x)$，具有 $f(x ^ k) = f^k(x)$，那么此函数成为完全积性函数。 常见的积性函数1.$\\varphi (x)$：欧拉函数，表示小于 $x$ 且与 $x$ 互质的数的个数。 2.$\\mu (x)$：莫比乌斯函数，关于非平方数的质因子数目的函数。 莫比乌斯函数这样计算： \\mu(x) = \\begin{cases} 1 \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (x = 1) \\\\\\\\ (-1) ^ k \\ \\ (x = p_1p_2p_3...p_k) \\\\\\\\ 0 \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\texttt{其他情况}\\end{cases}3.$d(x)​$：约数个数函数，表示 $x​$ 的约数个数。 4.$\\sigma(x)​$：约数和函数，表示 $x​$ 的各约数之和。 5.$I(x)​$：不变函数，此函数的值恒为1，此函数是完全积性函数 6.$\\epsilon(x)$：元函数，此函数的计算方式为：若 $x = 1$，$\\epsilon(x) = 1$，若 $x &gt; 1$，$\\epsilon(x) = 0$，此函数为完全积性函数。 7.$id(x)$：单位函数，计算方式为 $id(x) = x$ ，此函数为完全积性函数。 8.$idk(x)$：幂函数，计算方式为 $idk(x) = x ^ k$，此函数为完全积性函数。 9.$\\lambda(x)$：刘维尔函数，计算方式：设 $\\Omega(x)$ 为 $x$ 的质因子的数目，则 $\\lambda(x) = (-1) ^ {\\Omega(x)}$ 一些积性函数常用的性质1. \\sum_{d | n} \\mu(d) = \\begin{cases} 1 (n = 1) \\\\\\\\ 0 (n > 1) \\end{cases}​2. \\sum_{d^2 | n} \\mu(\\frac{n}{d^2}) = \\lambda(n)​3. \\sum_{d | n}\\frac{\\mu(d)}{d} = \\frac{\\varphi(n)}{n}4. \\sum_{d | n} \\varphi(n) = n5. 对于任意积性函数 $f(x)$，都有 $f*\\epsilon=f$ 一些常用的卷积1.$I * \\varphi = id$ 2.$\\mu * I = \\epsilon$ 3.$id * \\mu = \\varphi$ 4.$\\mu * d = I$ 5.$id * \\mu = \\varphi * \\epsilon$","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"},{"name":"卷积","slug":"卷积","permalink":"https://stevebraveman.github.io/tags/卷积/"}]},{"title":"-树链剖分- 树链剖分详解","slug":"70","date":"2019-03-16T00:02:38.000Z","updated":"2019-08-08T10:47:29.492Z","comments":true,"path":"2019/03/16/70/","link":"","permalink":"https://stevebraveman.github.io/2019/03/16/70/","excerpt":"如果有个题目，要求你在数列上区间求和，支持修改。 那么这道题就是很简单的线段树板子题，对吧？ 但是，这个世界是残酷的。为了不让题目那么简单，邪恶的出题人会把序列上的转换到树上，使题目难度增加一倍甚至几倍。 这样一看，完了，线段树可处理不了树上的操作啊，顿时感到人生苦短，失去了活下去的勇气。 那么，一个神奇的而又强大的东西——树链剖分可以解决上述问题。","text":"如果有个题目，要求你在数列上区间求和，支持修改。 那么这道题就是很简单的线段树板子题，对吧？ 但是，这个世界是残酷的。为了不让题目那么简单，邪恶的出题人会把序列上的转换到树上，使题目难度增加一倍甚至几倍。 这样一看，完了，线段树可处理不了树上的操作啊，顿时感到人生苦短，失去了活下去的勇气。 那么，一个神奇的而又强大的东西——树链剖分可以解决上述问题。 前置知识：DFS序、线段树。 啥，你不会线段树？序列上的问题都不会处理就想处理树上的问题？你快醒醒！ 变量的定义（当然这都是根据个人喜好来定义变量的名称，但作用都是一样的）： 1234567int dep[MAXN]; // 每个节点的深度int si[MAXN]; // 每个节点的子树大小int w[MAXN]; // 每个节点的权值int fa[MAXN]; // 每个节点的父亲int top[MAXN]; // 每个节点所属的链的顶端节点int son[MAXN]; // 每个节点的重儿子int id[MAXN]; // 每个节点的标号 下面进入正题： 让我们先来看这幅图： 显然这是一棵树。 那么我们该如何处理这棵树使它能够转换为序列上的问题呢。 我们可以把这棵树剖分一下，剖分成一些不同的链，分为重链和轻链。 什么是重链？就是把重儿子连在一起形成的链。 所以轻链也就是把轻儿子连在一起形成的链。 那什么又是重儿子呢？就是在一个节点的所有儿子中，子树最大的那个。当然，可能会出现具有相同大小子树的情况，我们只需要任选一个就行了。 轻儿子就是就是一个节点除重儿子外的所有儿子 还是这棵树： 上图已经用红线标出了所有重链，红色正方形的节点是重儿子，为了方便处理，我们把根节点也算作重儿子。 现在问题来了，该如何求出重儿子、轻儿子、重链、轻链呢？ 下面放程序： 123456789101112void dfs1(int u, int f, int deep) &#123; dep[u] = deep; //记录深度 fa[u] = f; //记录父节点 si[u] = 1; //子树初始化 for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (to == f) continue; dfs1(to, u, deep + 1); si[u] += si[to]; //求出这个节点子树的大小 if (si[to] &gt; si[son[u]]) son[u] = to; //更新重儿子 &#125;&#125; 是不是很巧妙？好像不是一个dfs就解决完轻重儿子的问题，下面再来个dfs来解决轻重链的问题： 123456789101112void dfs2(int u, int topf) &#123; id[u] = ++cnt; //处理DFS序 wt[cnt] = w[u]; top[u] = topf; if (!son[u]) return; dfs2(son[u], topf); // 顺着重儿子找重链 for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (fa[u] == to || to == son[u]) continue; dfs2(to, to); // 顺着轻儿子找轻链 &#125;&#125; 更为巧妙的是，上面这个程序保证每条链内的标号是连续的 至此，树链剖分结束 等一下，已经把这棵树处理完了，该如何用树链剖分解决树上的操作呢。 处理树上的操作分为三个问题： 1.单点的操作 直接线段树单点修改就行了。 2.子树的操作 让我们回忆一下DFS序的过程：每次都是搜到底再回溯。 所以我们可以得出一条结论：在子树中，每个节点的标号是连续的。 然后用线段区间修改就行了 3.路径上的操作 这才是重点所在，树链剖分就是擅长处理这种操作！ 我们既然已经划分出轻重链了，那么我们现在同等对待他们。 先给出程序： 123456789inline void query(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); // 操作 x = fa[top[x]]; &#125; if (dep[x] &gt; dep[y]) swap(x, y); // 操作&#125; 别看这程序短小，但这是树链剖分的精华所在！浓缩的都是精华 下面开始解读程序 while (top[x] != top[y])这句是什么意思呢？ 如果这两个点不在一条链上，那就不断跳，知道跳到同一条链上为止。 if (dep[top[x]] &lt; dep[top[y]]) swap(x, y);这又是什么意思呢？ 还是这张图： 如果我们要处理从节点6到节点5的操作，会发现节点5所在链的顶端正好与节点6所在链的中间相连。 如果我们不加上面这句话，很可能就会跳到其它无关紧要的节点上，并且陷入死循环。 if (dep[x] &gt; dep[y]) swap(x, y); 这句话就是为了处理当x,y跳到了同一条链上的时候该如何处理（也就是求出两点的LCA）。 于是我们也可以上述程序写出求LCA的程序： 12345678inline int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); x = fa[top[x]]; &#125; if (dep[x] &gt; dep[y]) swap(x, y); return x;&#125; 最后，说一些关于树链剖分时间复杂度的问题。 树链剖分的复杂度真的很优秀，查询一次最坏复杂度是 $\\log n$，而大多数情况下跑不满。同机房的Juan_feng对树链剖分的时间复杂度做出了证明： 任何一个点到根节点至多经过$\\log$条轻边。 因为每个点如果经过一条轻边走向他的父亲，那么他的父亲的siz就至少是这个节点的2倍，所以最多经过log条轻边 终于，树链剖分完毕！ 下面是几道例题： [NOI2015]软件包管理器 [SDOI2011]染色 [HAOI2015]树上操作 如果写得有问题可在下方评论回复QWQ","categories":[],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"https://stevebraveman.github.io/tags/树链剖分/"},{"name":"算法讲解","slug":"算法讲解","permalink":"https://stevebraveman.github.io/tags/算法讲解/"}]},{"title":"-图论-最短路- [洛谷 P2243]电路维修","slug":"69","date":"2019-03-13T12:47:44.000Z","updated":"2019-08-08T10:47:43.799Z","comments":true,"path":"2019/03/13/69/","link":"","permalink":"https://stevebraveman.github.io/2019/03/13/69/","excerpt":"题目描述Link","text":"题目描述Link Solution打死也不用纯搜索 这题我们可以考虑最短路 如果一个字符是’\\’，那么我们可以从左上到右下连一条权值为零的边，表示从左上到右下不需要旋转，从右上到左下连一条权值为1的边，表示需要旋转；如果是’/‘，那么则相反 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define MAXN 1001000struct Edge &#123; int v, nx, w;&#125;e[MAXN &lt;&lt; 2];int head[MAXN], ecnt, n, m, x, y, dis[MAXN], T;bool vis[MAXN];char ele[MAXN];void add(int f, int t, int w) &#123; e[++ecnt] = (Edge) &#123;t, head[f], w&#125;; head[f] = ecnt;&#125;struct node &#123; int id, w;&#125;;bool operator &lt; (node a, node b) &#123; return a.w &gt; b.w;&#125;void dijkstra(int s) &#123; memset(dis, 0x7f, sizeof(dis)); memset(vis, 0, sizeof(vis)); std::priority_queue &lt;node&gt; q; dis[s] = 0; q.push((node) &#123;s, 0&#125;); while (!q.empty()) &#123; node v = q.top(); q.pop(); int u = v.id; if (vis[u]) continue; vis[u] = 1; for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (dis[to] &gt; dis[u] + e[i].w) &#123; dis[to] = dis[u] + e[i].w; q.push((node) &#123;to, dis[to]&#125;); &#125; &#125; &#125;&#125;int g(int i, int j) &#123; return (i - 1) * (m + 1) + j;&#125;int main() &#123; scanf(\"%d\", &amp;T); while (T--) &#123; memset(head, 0, sizeof(head)); memset(dis, 0x7f, sizeof(dis)); ecnt = 0; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%s\", ele + 1); for (int j = 1; j &lt;= m; j++) &#123; if (ele[j] == '/') &#123; add(g(i, j), g(i + 1, j + 1), 1); add(g(i + 1, j + 1), g(i, j), 1); add(g(i + 1, j), g(i, j + 1), 0); add(g(i, j + 1), g(i + 1, j), 0); &#125; else &#123; add(g(i, j), g(i + 1, j + 1), 0); add(g(i + 1, j + 1), g(i, j), 0); add(g(i + 1, j), g(i, j + 1), 1); add(g(i, j + 1), g(i + 1, j), 1); &#125; &#125; &#125; dijkstra(g(1, 1)); if (dis[g(n + 1, m + 1)] &gt; 2000000000) &#123; puts(\"NO SOLUTION\"); continue; &#125; printf(\"%d\\n\", dis[g(n + 1, m + 1)]); &#125;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"图论","slug":"图论","permalink":"https://stevebraveman.github.io/tags/图论/"},{"name":"最短路","slug":"最短路","permalink":"https://stevebraveman.github.io/tags/最短路/"}]},{"title":"-二分- [洛谷 P3939]数颜色","slug":"68","date":"2019-03-06T11:09:38.000Z","updated":"2019-08-09T07:39:30.009Z","comments":true,"path":"2019/03/06/68/","link":"","permalink":"https://stevebraveman.github.io/2019/03/06/68/","excerpt":"题目描述Link","text":"题目描述Link Solution先声明一下，以后的题解不再粘贴题面。 这道题我们可以用vector存下每种颜色所在的位置，然后再二分一下就可以了，甚至连离散化都不需要。 Code123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define MAXN 300010std::vector&lt;int&gt; v[MAXN];int n, m, op, l, r, x, a[MAXN];int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;a[i]); v[a[i]].push_back(i); &#125; while (m--) &#123; scanf(\"%d\", &amp;op); if (op == 1) &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;x); int pos = std::upper_bound(v[x].begin(), v[x].end(), r) - std::lower_bound(v[x].begin(), v[x].end(), l); printf(\"%d\\n\", pos); &#125; if (op == 2) &#123; scanf(\"%d\", &amp;x); int ll = a[x], rr = a[x + 1]; std::swap(a[x], a[x + 1]); if (a[x] == a[x + 1]) continue; int pos = std::lower_bound(v[ll].begin(), v[ll].end(), x) - v[ll].begin(); int _pos = std::lower_bound(v[rr].begin(), v[rr].end(), x + 1) - v[rr].begin(); v[ll][pos] = x + 1; v[rr][_pos] = x; &#125; &#125;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"二分","slug":"二分","permalink":"https://stevebraveman.github.io/tags/二分/"}]},{"title":"-其它- RiverFun常犯的SB错误合集[不定期更新]","slug":"67","date":"2019-03-06T03:42:09.000Z","updated":"2019-08-23T03:22:45.088Z","comments":true,"path":"2019/03/06/67/","link":"","permalink":"https://stevebraveman.github.io/2019/03/06/67/","excerpt":"注：错误代码都是用我的码风写的","text":"注：错误代码都是用我的码风写的 11234int min(int a, int b) &#123; if (a &lt; b) return b; else return b;&#125; 212345for (int i = 1; i &lt;= n; i++) &#123; for (int i = 1; i &lt;= m; i++) &#123; &#125;&#125; 3123456789void build(int l, int r, int p) &#123; if (l == r) &#123; b[p] = a[l]; &#125; int m = (l + r) &gt;&gt; 1; build(l, m, ls(p)); build(m + 1, r, ls(p)); pd(p);&#125; 4123int mian() &#123; // 曾经常犯，现在不怎么犯了&#125; 51234int a, b, c;int main() &#123; scanf(\"%d%d%d\", a, b, c);&#125; 61234int find(int x) &#123; if (fa[x] = x) return x; else return fa[x] = find(fa[x]);&#125; 7123int main() &#123; printf(\"%d\", &amp;a);&#125; 812345int main() &#123; for (int i = n; i &lt;= 1; i--) &#123; /* */ &#125;&#125; 91234char n;int main() &#123; scanf(\"%d\", &amp;n);&#125; 1012345void dfs(int u) &#123; for (int i = head[u]; i; i++) &#123; // &#125;&#125; 1112345678910//建图时int x, y, z;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); add(x, y, z); add(y, x, z); &#125;&#125; 12123456789//树剖求LCA时inline int LCA(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) std::swap(x, y); x = fa[x]; &#125; if (dep[x] &gt; dep[y]) std::swap(x, y); return x;&#125; 1312345678910//向Trie中插入字符串void insert(char *s) &#123; int p = 0; for (int i = 0; s[i]; i++) &#123; int k = s[i] - 'a'; if (!tr[i][k]) tr[i][k] = ++tot; p = tr[i][k]; &#125; ed[p]++;&#125; 141234// 整除分块for (int l = 1, r; l &lt;= n; l++) &#123; //&#125;","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"https://stevebraveman.github.io/tags/其它/"}]},{"title":"-分块-数论- [CF920F]SUM and REPLACE","slug":"66","date":"2019-03-05T13:54:16.000Z","updated":"2019-08-08T10:48:15.126Z","comments":true,"path":"2019/03/05/66/","link":"","permalink":"https://stevebraveman.github.io/2019/03/05/66/","excerpt":"题目描述给你一个数组$a_i$​，$D(x)$为$x$的约数个数 两种操作： 1.将$[l,r]$的$a_i$替换为$D(a_i)$ 2.输出$\\sum^r_{i=l}a_i$","text":"题目描述给你一个数组$a_i$​，$D(x)$为$x$的约数个数 两种操作： 1.将$[l,r]$的$a_i$替换为$D(a_i)$ 2.输出$\\sum^r_{i=l}a_i$ 输入样例7 66 4 1 10 3 2 42 1 72 4 51 3 52 4 41 5 72 1 7 输出样例3013422 Solution这道题和上帝造题七分钟2有点相似，只不过是把区间开放方成了区间改约数个数。 标记是块内是否每个数都小于等于2。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define MAXN 3010002#define MX 1000100#define ll long longusing namespace std;int b[MAXN], n, sq, m;ll s[MAXN], a[MAXN];bool v[MAXN];bool chk[MX];int p[MX], d[MX], tot, num[MX];inline int max(int a, int b) &#123; if (a &gt; b) return a; else return b;&#125;inline int min(int a, int b) &#123; if (a &lt; b) return a; else return b;&#125;void getd() &#123; chk[1] = 0; d[1] = 1; for (int i = 2; i &lt;= MX; i++) &#123; if (!chk[i]) &#123; p[++tot] = i; d[i] = 2; num[i] = 1; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= MX; j++) &#123; chk[i * p[j]] = 1; if (!(i % p[j])) &#123; num[i * p[j]] = num[i] + 1; d[i * p[j]] = d[i] / (num[i] + 1) * (num[i * p[j]] + 1); break; &#125; else &#123; d[i * p[j]] = d[i] * d[p[j]]; num[i * p[j]] = 1; &#125; &#125; &#125;&#125;inline void quarysqrt(int x) &#123; if (v[x]) return; v[x] = 1; a[x] = 0; for (int i = (x - 1) * sq + 1; i &lt;= x * sq; i++) &#123; s[i] = d[s[i]]; a[x] += s[i]; if (s[i] &gt; 2) v[x] = 0; &#125;&#125;inline void add(int x, int y) &#123; if (v[b[x]] == 0) &#123; for (int i = x; i &lt;= min(b[x] * sq, y); i++) &#123; a[b[x]] -= s[i]; s[i] = d[s[i]]; a[b[x]] += s[i]; &#125; v[b[x]] = 1; for (int i = (b[x] - 1) * sq + 1; i &lt;= b[x] * sq; i++) &#123; if (s[i] &gt; 2) &#123; v[b[x]] = 0; break; &#125; &#125; &#125; if (b[x] != b[y] &amp;&amp; v[b[y]] == 0) &#123; for (int i = (b[y] - 1) * sq + 1; i &lt;= y; i++) &#123; a[b[y]] -= s[i]; s[i] = d[s[i]]; a[b[y]] += s[i]; &#125; v[b[y]] = 1; for (int i = (b[y] - 1) * sq + 1; i &lt;= b[y] * sq; i++) &#123; if (s[i] &gt; 2) &#123; v[b[y]] = 0; break; &#125; &#125; &#125; for (int i = b[x] + 1; i &lt;= b[y] - 1; i++) &#123; quarysqrt(i); &#125;&#125;ll getsum(int x , int y) &#123; ll ans = 0; for (int i = x; i &lt;= min(b[x] * sq , y); i++) &#123; ans += s[i]; &#125; if (b[x] != b[y]) &#123; for (int i = (b[y] - 1) * sq + 1; i &lt;= y; i++) &#123; ans += s[i]; &#125; &#125; for (int i = b[x] + 1; i &lt; b[y]; i++) &#123; ans += a[i]; &#125; return ans;&#125;int main() &#123; memset(v, 0, sizeof (v)); scanf(\"%d%d\", &amp;n, &amp;m); getd(); sq = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%lld\", &amp;s[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; b[i] = (i - 1) / sq + 1; a[b[i]] += s[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; int x, y, c; scanf(\"%d%d%d\", &amp;c, &amp;x, &amp;y); if (x &gt; y) &#123; swap(x, y); &#125; if (c == 1) &#123; add(x, y); &#125; else printf(\"%lld\\n\", getsum(x, y)); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"},{"name":"分块","slug":"分块","permalink":"https://stevebraveman.github.io/tags/分块/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://stevebraveman.github.io/tags/Codeforces/"}]},{"title":"-网络流-最小割- [洛谷 P2777][网络流24题]方格取数问题","slug":"65","date":"2019-03-05T13:46:56.000Z","updated":"2019-08-08T10:48:43.267Z","comments":true,"path":"2019/03/05/65/","link":"","permalink":"https://stevebraveman.github.io/2019/03/05/65/","excerpt":"题目背景none! 题目描述在一个有 m*n 个方格的棋盘中，每个方格中有一个正整数。现要从方格中取数，使任意 2 个数所在方格没有公共边，且取出的数的总和最大。试设计一个满足要求的取数算法。对于给定的方格棋盘，按照取数要求编程找出总和最大的数。","text":"题目背景none! 题目描述在一个有 m*n 个方格的棋盘中，每个方格中有一个正整数。现要从方格中取数，使任意 2 个数所在方格没有公共边，且取出的数的总和最大。试设计一个满足要求的取数算法。对于给定的方格棋盘，按照取数要求编程找出总和最大的数。 输入格式第 1 行有 2 个正整数 m 和 n，分别表示棋盘的行数和列数。接下来的 m 行，每行有 n 个正整数，表示棋盘方格中的数。 输出格式程序运行结束时，将取数的最大总和输出 输入样例3 31 2 33 2 32 3 1 输出样例11 说明m,n&lt;=100 Solution这道题我们考虑最小割。 先把这张图黑白染色管他对不对，先染色再说，然后把源点都连向黑点，白点都连向汇点，容量为这个点的数值。 最后再根据黑白点的情况想四周连边就行了。 我绝对不会告诉你我因为手写min函数错了改了好长时间QAQ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define MAXN 1100100#define INF 2000000000int min(int a, int b) &#123; if (a &lt; b) return a; else return b;&#125;struct Edge &#123; int v, nx, w;&#125;e[MAXN &lt;&lt; 2];std::queue &lt;int&gt; q;int n, m, head[MAXN], ecnt = 1, x, y, z, r, k, dep[MAXN], cur[MAXN], tot;void add(int f, int t, int w) &#123; e[++ecnt] = (Edge) &#123;t, head[f], w&#125;; head[f] = ecnt; e[++ecnt] = (Edge) &#123;f, head[t], 0&#125;; head[t] = ecnt;&#125;bool bfs(int s, int t) &#123; memset(dep, 0x7f, sizeof(dep)); while (!q.empty()) q.pop(); for (int i = 1; i &lt;= n * m + m * n + 2; i++) &#123; cur[i] = head[i]; &#125; dep[s] = 0; q.push(s); while (!q.empty()) &#123; int v = q.front(); q.pop(); for (int i = head[v]; i; i = e[i].nx) &#123; int to = e[i].v; if (dep[to] &gt; INF &amp;&amp; e[i].w) &#123; dep[to] = dep[v] + 1; q.push(to); &#125; &#125; &#125; if (dep[t] &lt; INF) return 1; else return 0;&#125;int dfs(int u, int t, int l) &#123; if (!l || u == t) return l; int fl = 0, f; for (int i = cur[u]; i; i = e[i].nx) &#123; cur[u] = i; int to = e[i].v; if (dep[to] == dep[u] + 1 &amp;&amp; (f = dfs(to, t, min(l, e[i].w)))) &#123; fl += f; l -= f; e[i ^ 1].w += f; e[i].w -= f; if (!l) break; &#125; &#125; return fl;&#125;int Dinic(int s, int t) &#123; int maxf = 0; while (bfs(s, t)) &#123; maxf += dfs(s, t, INF); &#125; return maxf;&#125;int g(int i, int j) &#123; return i * m + j;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); r = n * m + m * n + 1; k = r + 1; tot = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf(\"%d\", &amp;x); tot += x; int id = g(i, j); if ((i + j) &amp; 1) &#123; add(r, id, x); if (i &gt; 1) add(id, g(i - 1, j), INF); if (j &gt; 1) add(id, g(i, j - 1), INF); if (i &lt; n) add(id, g(i + 1, j), INF); if (j &lt; m) add(id, g(i, j + 1), INF); &#125; else &#123; add(id, k, x); &#125; &#125; &#125; printf(\"%d\\n\", tot - Dinic(r, k)); return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"最小割","slug":"最小割","permalink":"https://stevebraveman.github.io/tags/最小割/"},{"name":"网络流24题","slug":"网络流24题","permalink":"https://stevebraveman.github.io/tags/网络流24题/"}]},{"title":"-网络流-费用流- [洛谷 P2045]方格取数加强版","slug":"64","date":"2019-03-04T03:37:03.000Z","updated":"2019-08-08T10:48:52.566Z","comments":true,"path":"2019/03/04/64/","link":"","permalink":"https://stevebraveman.github.io/2019/03/04/64/","excerpt":"题目描述给出一个n*n的矩阵,每一格有一个非负整数Aij,(Aij &lt;= 1000)现在从(1,1)出发,可以往右或者往下走,最后到达(n,n),每达到一格,把该格子的数取出来,该格子的数就变成0,这样一共走K次,现在要求K次所达到的方格的数的和最大","text":"题目描述给出一个n*n的矩阵,每一格有一个非负整数Aij,(Aij &lt;= 1000)现在从(1,1)出发,可以往右或者往下走,最后到达(n,n),每达到一格,把该格子的数取出来,该格子的数就变成0,这样一共走K次,现在要求K次所达到的方格的数的和最大 输入格式第一行两个数n,k（1&lt;=n&lt;=50, 0&lt;=k&lt;=10） 接下来n行,每行n个数,分别表示矩阵的每个格子的数 输出格式一个数,为最大和 输入样例3 11 2 30 2 11 4 2 输出样例11 说明每个格子中的数不超过1000 Solution这个题目要求走k次，每走一次将经过方格中的数取出，取过的数不能再取 显然DP做不了，如果能做请私聊我 那么，我们就要拿出终极武器——网络流中的费用流。 那么该如何建模呢？ 先拆点，将每个点拆成两个点 因为题目要求从(1,1)开始，从(n,n)结束，那么就可以将源点连向(1,1)，将(n,n)连向汇点。 因为只能向下走和向右走，所以就将每个点向右和向下连边。 对于有数的点建一条边流量为1，费用为这个数。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define MAXN 100010#define INF 2000000000struct Edge &#123; int v, nx, fl, w;&#125;e[MAXN];int n, m, r, k, head[MAXN], dis[MAXN], ecnt = 1, flow[MAXN], maxf, minc, la[MAXN], pre[MAXN], x, y, z, f, mp[60][60];bool vis[MAXN];std::queue &lt;int&gt; q;int min(int a, int b) &#123; if (a &lt; b) return a; else return b;&#125;void add(int f, int t, int fl, int w) &#123; e[++ecnt] = (Edge) &#123;t, head[f], fl, w&#125;; head[f] = ecnt; e[++ecnt] = (Edge) &#123;f, head[t], 0, -w&#125;; head[t] = ecnt;&#125;bool spfa(int s, int t) &#123; memset(dis, 0x7f, sizeof(dis)); memset(flow, 0x7f, sizeof(flow)); memset(vis, 0, sizeof(vis)); q.push(s); dis[s] = 0; vis[s] = 1; pre[t] = -1; while (!q.empty()) &#123; int v = q.front(); q.pop(); vis[v] = 0; for (int i = head[v]; i; i = e[i].nx) &#123; int f = e[i].fl; int to = e[i].v; if (f &gt; 0 &amp;&amp; dis[to] &gt; dis[v] + e[i].w) &#123; dis[to] = dis[v] + e[i].w; pre[to] = v; la[to] = i; flow[to] = min(flow[v], f); if (!vis[to]) &#123; vis[to] = 1; q.push(to); &#125; &#125; &#125; &#125; return pre[t] != -1;&#125;int g(int i, int j) &#123; return (i - 1) * n + j;&#125;void mcmf(int s, int t) &#123; while (spfa(s, t)) &#123; int v = t; maxf += flow[t]; minc += flow[t] * dis[t]; while (v != s) &#123; int k = la[v]; e[k].fl -= flow[t]; e[k ^ 1].fl += flow[t]; v = pre[v]; &#125; &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); r = 2 * n * n + 1; k = 2 * n * n + 2; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; scanf(\"%d\", &amp;mp[i][j]); &#125; &#125; add(r, g(1, 1), m, 0); add(g(n, n) + n * n, k, m, 0); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; add(g(i, j), g(i, j) + n * n, 1, -mp[i][j]); add(g(i, j), g(i, j) + n * n, INF, 0); if (i &lt; n) &#123; add(g(i, j) + n * n, g(i + 1, j), INF, 0); &#125; if (j &lt; n) &#123; add(g(i, j) + n * n, g(i, j + 1), INF, 0); &#125; &#125; &#125; mcmf(r, k); printf(\"%d\\n\", -minc); return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"费用流","slug":"费用流","permalink":"https://stevebraveman.github.io/tags/费用流/"}]},{"title":"-网络流-最大流- [洛谷 P5192]Zoj3229 Shoot the Bullet|东方文花帖","slug":"63","date":"2019-03-02T12:24:22.000Z","updated":"2019-08-08T10:49:07.134Z","comments":true,"path":"2019/03/02/63/","link":"","permalink":"https://stevebraveman.github.io/2019/03/02/63/","excerpt":"题目背景Translated by @chen_zhe 幻想乡是一个被博丽大结界和虚幻与现实的境界所包围起来的一个美妙的地方。这里人和其他生物，例如妖怪、妖精等核平共处。 射命丸文（Syameimaru Aya）是一只鸦天狗，拥有操纵风的能力，已经活了千岁以上，是《文文。新闻》的主编，拥有着一本叫做《文花帖》的手账，记录幻想乡各地的大新闻。她不仅是天狗中速度最快的鸦天狗，思考能力非常强，以别人的几倍的思考速度思考，也拥有幻想乡最高等级的力量。 （译者内心O.S.：远古的东方众都那么硬核科普的吗）","text":"题目背景Translated by @chen_zhe 幻想乡是一个被博丽大结界和虚幻与现实的境界所包围起来的一个美妙的地方。这里人和其他生物，例如妖怪、妖精等核平共处。 射命丸文（Syameimaru Aya）是一只鸦天狗，拥有操纵风的能力，已经活了千岁以上，是《文文。新闻》的主编，拥有着一本叫做《文花帖》的手账，记录幻想乡各地的大新闻。她不仅是天狗中速度最快的鸦天狗，思考能力非常强，以别人的几倍的思考速度思考，也拥有幻想乡最高等级的力量。 （译者内心O.S.：远古的东方众都那么硬核科普的吗） 题目描述（附注：文花帖8-8 西行寺幽幽子 「死蝶浮月」） 在接下来的$n$天中，射命丸文将要拍摄幻想乡的少女的照片并且从中为第$x$个少女拍摄GxGxGx​张照片刊登在《文文。新闻》上。在第$k$天的时候文文有$C_k$个取材对象，且对于每个取材对象拍的照片必须在闭区间$[L{ki},R{k_i}]$中。如果过少，文文就搞不出大新文；如果过多，就会有少女很安格瑞。 除此之外，因为拍照设备的原因，对于第$i$天，每天的拍照数量不能超过$D_i$张。在满足这些限定的条件下，文文希望拍到的照片尽可能地多。 由于文文需要去取材，因此她把这个任务交给了你，让你帮她去解决。 输入格式本题不定组数据，确保数据组数不超过$10$ 第一行输入两个整数$n$和$m$，分别表示有$n$天，有$m$位少女。其中$n \\leq 365,m \\leq 1000$ 接下来一行，有$m$个数字$G_1 \\cdots G_m$，对于每一个$G_x$，都满足$G_x \\in [0,10^5]$。 再接下来$n$段，每一段的第一行有两个整数$C,D(1 \\leq C \\leq 300, 0 \\leq D \\leq 30000)$ 接下来有$C$行，每一行有三个整数$T,L,R(0 \\leq T &lt; m, 0 \\leq L \\leq R \\leq 100)$ 输出格式如果无法满足文文的需求，那么请输出-1 否则请输出在满足需求的情况下，文文最多能拍多少张照片。 注意每输出完一组数据之后，中间要空一行。 输入样例2 312 12 123 180 3 91 3 92 3 93 180 3 91 3 92 3 9 输出样例36 Solution终于可以有一篇黑题的题解辣！至少在写题解时这题是黑的 下面进入正题： 有源汇的上下界网络最大流 这道题有一个很明显的地方告诉你要用有上下界网络流： 且对于每个取材对象拍的照片必须在闭区间$[L{k_i},R{k_i}]$中 那么怎么求有源汇的上下界网络最大流呢？ 我们抛开有源汇的最大流，先搞无源汇的上下界网络可行流 关于无源汇的上下界网络可行流的证明及做法，个人讲得不太清楚，可参考这篇博客（其实就是我懒得写） 现在问题来了，如果你已经求出了可行流，那么该怎样求有源汇的网络最大流呢？ 这个很简单，只需要连一条从源点到汇点容量为INF的边，然后再在残量网络跑一边最大流就可以了。具体证明见百度 最后我们就可以根据题意建边了表示读题用了20min Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAXN 1000100#define INF 2000000000#define clear(x) memset(x, 0, sizeof(x));struct Edge &#123; int v, nx, w;&#125; e[MAXN];int min(int a, int b) &#123; if (a &lt; b) return a; else return b;&#125;int head[MAXN], ecnt = 1, n, m, p, x, _l, _r;int dep[MAXN], cur[MAXN], di[MAXN], r, k, ans, tot, _s, _t, _c, _d;void add(int f, int t, int w) &#123; e[++ecnt] = (Edge)&#123; t, head[f], w &#125;; head[f] = ecnt; e[++ecnt] = (Edge)&#123; f, head[t], 0 &#125;; head[t] = ecnt;&#125;bool bfs(int s, int t) &#123; memset(dep, 0x7f, sizeof(dep)); for (int i = 1; i &lt;= k; i++) &#123; cur[i] = head[i]; &#125; std::queue&lt;int&gt; q; q.push(s); dep[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (dep[to] &gt; INF &amp;&amp; e[i].w) &#123; dep[to] = dep[u] + 1; q.push(to); &#125; &#125; &#125; return dep[t] &lt; INF;&#125;int dfs(int s, int t, int l) &#123; if (!l || s == t) return l; int fl = 0, f; for (int i = cur[s]; i; i = e[i].nx) &#123; cur[s] = i; int to = e[i].v; if (dep[to] == dep[s] + 1 &amp;&amp; (f = dfs(to, t, min(l, e[i].w)))) &#123; fl += f; l -= f; e[i].w -= f; e[i ^ 1].w += f; if (!l) break; &#125; &#125; return fl;&#125;int Dinic(int s, int t) &#123; int maxf = 0; while (bfs(s, t)) &#123; maxf += dfs(s, t, INF); &#125; return maxf;&#125;int main() &#123; while (scanf(\"%d%d\", &amp;m, &amp;n) != EOF) &#123; _s = n + m + 1; _t = _s + 1; r = _t + 1; k = r + 1; clear(head); clear(di); ecnt = 1; ans = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;p); add(i, _t, INF); di[i] -= p; di[_t] += p; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%d%d\", &amp;_c, &amp;_d); add(_s, i + n, _d); for (int j = 1; j &lt;= _c; j++) &#123; scanf(\"%d%d%d\", &amp;x, &amp;_l, &amp;_r); x++; add(i + n, x, _r - _l); di[i + n] -= _l; di[x] += _l; &#125; &#125; for (int i = 1; i &lt;= n + m + 2; i++) &#123; if (di[i] &gt; 0) &#123; ans += di[i]; add(r, i, di[i]); &#125; else &#123; add(i, k, -di[i]); &#125; &#125; add(_t, _s, INF); tot = Dinic(r, k); if (tot != ans) puts(\"-1\"); else &#123; printf(\"%d\\n\", Dinic(_s, _t)); &#125; puts(\"\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"https://stevebraveman.github.io/tags/最大流/"}]},{"title":"-LCT- [BZOJ 2843]极地旅行社","slug":"62","date":"2019-02-18T06:34:59.000Z","updated":"2019-08-08T10:49:17.325Z","comments":true,"path":"2019/02/18/62/","link":"","permalink":"https://stevebraveman.github.io/2019/02/18/62/","excerpt":"题目描述不久之前，Mirko建立了一个旅行社，名叫“极地之梦”。这家旅行社在北极附近购买了N座冰岛，并且提供观光服务。当地最受欢迎的当然是帝企鹅了，这些小家伙经常成群结队的游走在各个冰岛之间。Mirko的旅行社遭受一次重大打击，以至于观光游轮已经不划算了。","text":"题目描述不久之前，Mirko建立了一个旅行社，名叫“极地之梦”。这家旅行社在北极附近购买了N座冰岛，并且提供观光服务。当地最受欢迎的当然是帝企鹅了，这些小家伙经常成群结队的游走在各个冰岛之间。Mirko的旅行社遭受一次重大打击，以至于观光游轮已经不划算了。旅行社将在冰岛之间建造大桥，并用观光巴士来运载游客。Mirko希望开发一个电脑程序来管理这些大桥的建造过程，以免有不可预料的错误发生。这些冰岛从1到N标号。一开始时这些岛屿没有大桥连接，并且所有岛上的帝企鹅数量都是知道的。每座岛上的企鹅数量虽然会有所改变，但是始终在[0, 1000]之间。你的程序需要处理以下三种命令：1.”bridge A B”——在A与B之间建立一座大桥（A与B是不同的岛屿）。由于经费限制，这项命令被接受，当且仅当A与B不联通。若这项命令被接受，你的程序需要输出”yes”，之后会建造这座大桥。否则，你的程序需要输出”no”。2.”penguins A X”——根据可靠消息，岛屿A此时的帝企鹅数量变为X。这项命令只是用来提供信息的，你的程序不需要回应。3.”excursion A B”——一个旅行团希望从A出发到B。若A与B连通，你的程序需要输出这个旅行团一路上所能看到的帝企鹅数量（包括起点A与终点B），若不联通，你的程序需要输出”impossible”。 输入格式第一行一个正整数N，表示冰岛的数量。第二行N个范围[0, 1000]的整数，为每座岛屿初始的帝企鹅数量。第三行一个正整数M，表示命令的数量。接下来M行即命令，为题目描述所示。1&lt;=N&lt;=30000,1&lt;=M&lt;=100000 输出格式对于每个bridge命令与excursion命令，输出一行，为题目描述所示。 输入样例54 2 4 5 610excursion 1 1excursion 1 2bridge 1 2excursion 1 2bridge 3 4bridge 3 5excursion 4 5bridge 1 3excursion 2 4excursion 2 5 输出样例impossibleyes6yesyes15yes1516 Solution最近刚学了一个Link-Cut Tree，于是找了几个题练习。 这道题是道LCT裸题，就是修改操作有些麻烦，需要splay一下在修改。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define ls(x) c[x][0]#define rs(x) c[x][1]#define MAXN 100010int si[MAXN], val[MAXN], st[MAXN], c[MAXN][2], f[MAXN];bool r[MAXN];int n, m, u, v;char op[10];bool ifr(int p) &#123; return ls(f[p]) == p || rs(f[p]) == p;&#125;void pd(int p) &#123; si[p] = si[ls(p)] + si[rs(p)] + val[p];&#125;void flit(int p) &#123; int t = ls(p); ls(p) = rs(p); rs(p) = t; r[p] ^= 1;&#125;void pushd(int p) &#123; if (r[p]) &#123; if (ls(p)) flit(ls(p)); if (rs(p)) flit(rs(p)); r[p] = 0; &#125;&#125;void rotate(int p) &#123; int x = f[p], y = f[x], k = rs(x) == p, w = c[p][!k]; if (ifr(x)) c[y][c[y][1] == x] = p; c[p][!k] = x; c[x][k] = w; if (w) f[w] = x; f[x] = p; f[p] = y; pd(x);&#125;void splay(int p) &#123; int y = p, z = 0; st[++z] = y; while (ifr(y)) st[++z] = y = f[y]; while (z) pushd(st[z--]); while (ifr(p)) &#123; y = f[p]; z = f[y]; if (ifr(y)) &#123; rotate((ls(y) == p) ^ (ls(z) == y) ? p : y); &#125; rotate(p); &#125; pd(p);&#125;void access(int p) &#123; for (int i = 0; p; p = f[i = p]) &#123; splay(p); rs(p) = i; pd(p); &#125;&#125;void makeroot(int p) &#123; access(p); splay(p); flit(p);&#125;int findr(int p) &#123; access(p); splay(p); while (ls(p)) &#123; pushd(p); p = ls(p); &#125; splay(p); return p;&#125;void split(int x, int y) &#123; makeroot(x); access(y); splay(y);&#125;bool link(int x, int y) &#123; makeroot(x); if (findr(y) != x) &#123; f[x] = y; return 1; &#125; return 0;&#125;void cut(int x, int y) &#123; makeroot(x); if (findr(y) == x &amp;&amp; f[y] == x &amp;&amp; !ls(y)) &#123; f[y] = rs(x) = 0; pd(x); &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;val[i]); &#125; scanf(\"%d\", &amp;m); while (m--) &#123; scanf(\"%s%d%d\", op, &amp;u, &amp;v); if (op[0] == 'b') &#123; if (link(u, v)) &#123; puts(\"yes\"); &#125; else &#123; puts(\"no\"); &#125; &#125; if (op[0] == 'p') &#123; splay(u); val[u] = v; pd(u); &#125; if (op[0] == 'e') &#123; if (findr(u) == findr(v)) &#123; split(u, v); printf(\"%d\\n\", si[v]); &#125; else &#123; puts(\"impossible\"); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://stevebraveman.github.io/tags/BZOJ/"},{"name":"LCT","slug":"LCT","permalink":"https://stevebraveman.github.io/tags/LCT/"}]},{"title":"-树链剖分-线段树- [洛谷 P3950]部落冲突","slug":"61","date":"2019-02-17T01:00:29.000Z","updated":"2019-08-09T07:30:02.812Z","comments":true,"path":"2019/02/17/61/","link":"","permalink":"https://stevebraveman.github.io/2019/02/17/61/","excerpt":"题目背景在一个叫做Travian的世界里，生活着各个大大小小的部落。其中最为强大的是罗马、高卢和日耳曼。他们之间为了争夺资源和土地，进行了无数次的战斗。期间诞生了众多家喻户晓的英雄人物，也留下了许多可歌可泣的动人故事。 其中，在大大小小的部落之间，会有一些道路相连，这些道路是Travian世界里的重要枢纽，简单起见，你可以把这些部落与部落之间相连的道路看作一颗树，可见每条道路对于Travian世界的重要程度。有了这些道路，建筑工人就可以通过这些道路进行友好外交啦。","text":"题目背景在一个叫做Travian的世界里，生活着各个大大小小的部落。其中最为强大的是罗马、高卢和日耳曼。他们之间为了争夺资源和土地，进行了无数次的战斗。期间诞生了众多家喻户晓的英雄人物，也留下了许多可歌可泣的动人故事。 其中，在大大小小的部落之间，会有一些道路相连，这些道路是Travian世界里的重要枢纽，简单起见，你可以把这些部落与部落之间相连的道路看作一颗树，可见每条道路对于Travian世界的重要程度。有了这些道路，建筑工人就可以通过这些道路进行友好外交啦。 然而，事情并不会像想象的那样美好，由于资源的匮乏，相邻的部落（由一条道路相连的部落）之间经常会发生大大小小的冲突事件，更有甚者，会升级为部落之间的大型战争。 为了避免误伤，每当两个相邻的部落之间发生大型战争之时，这两个部落间的道路是不允许通行的，对于一些强大的部落，甚至能与多个相邻的部落同时开战，同样的，这些战争地带的道路十分危险，是不可通行的。 天下之势，分久必合，当两个部落经历了不打不相识的苦战之后，他们可以签订停战协议（暂时停战，以后依旧可能再次开战），这样，两个部落之间的道路又会重新恢复为可通行状态，建筑工人们又可以经过此地购买最新的大本营设计图纸来强大自己的部落了。 为了简单起见，我们把各大战争事件按发起的时间顺序依次编号（最先发起的战争编号就为 1，第二次战争编号就为 2，以此类推），当两个部落停战之时，则会直接告诉你这场战争的编号，然后这场战争就载入了史册，不复存在了，当然，这并不会影响到其他战争的编号。 建筑工人十分讨厌战争，因为战争，想从一个部落到另一个部落进行友好交流的建筑工人可能就此白跑一趟。所以，在他们出发之前，都会向你问问能不能到达他们想去的部落。 题目描述简单起见，你就是要处理下面三件事，所有的事件都是按照时间顺序给出的。 1.（Q p q）从第 p 个部落出发的建筑工人想知道能否到达第 q 个部落了，你要回答的便是（Yes/No），注意大小写 2.（C p q）第 p 个部落与第 q 个部落开战了，保证他们一定是相邻的部落，且目前处于停战（未开战）状态 3.（U x） 第 x 次发生的战争结束了，它将永远的被载入史册，不复存在（保证这个消息不会告诉你多次） 输入格式第一行两个数 n 和 m， n 代表了一共有 n 个部落，m 代表了以上三种事件发生的总数 接下来的 n - 1 行，每行两个数 p , q，代表了第 p 个部落与第 q 个部落之间有一条道路相连 接下来的 mmm 行，每行表示一件事，详见题目描述 输出格式每行一个“Yes”或者“No”，表示从第 ppp 个部落出发的建筑工人能否到达第 q 个部落 输入样例5 91 22 33 44 5Q 1 4C 2 1C 4 3Q 3 1Q 1 5U 1U 2C 4 3Q 3 4 输出样例YesNoNoNo Solution这道题我第一眼看的是LCT，但后来想一想发现我不会LCT，就只好用树剖了。 我们可以把边权传到深度较深的点上，如果这条边断了，那么这条边的权加一，如果又连上了，那么就把边权减一。 查询时看看这条路径上的和是否为零就行了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 600010#define ls(x) ((x) &lt;&lt; 1)#define rs(x) ((x) &lt;&lt; 1 | 1)struct Edge &#123; int v, nx;&#125;e[MAXN];int head[MAXN], ecnt, n, m, x[MAXN], y[MAXN], dep[MAXN], si[MAXN], wt[MAXN], w[MAXN], _x, _y;int fa[MAXN], top[MAXN], son[MAXN], cnt, r = 1, id[MAXN], ccnt;char op;void add(int f, int t) &#123; e[++ecnt] = (Edge) &#123;t, head[f]&#125;; head[f] = ecnt;&#125;struct Segtree &#123; int a[MAXN], b[MAXN &lt;&lt; 2], tmax[MAXN &lt;&lt; 2]; void pd(int p) &#123; b[p] = b[ls(p)] + b[rs(p)]; &#125; void build(int l, int r, int p) &#123; if (l == r) &#123; b[p] = a[l]; return; &#125; int m = (l + r) &gt;&gt; 1; build(l, m, ls(p)); build(m + 1, r, rs(p)); pd(p); &#125; void updated(int x, int l, int r, int p, int k) &#123; if (l == r) &#123; b[p] += k; return; &#125; int m = (l + r) &gt;&gt; 1; if (x &lt;= m) updated(x, l, m, ls(p), k); else updated(x, m + 1, r, rs(p), k); pd(p); &#125; int qsum(int x, int y, int l, int r, int p) &#123; int s = 0; if (x &lt;= l &amp;&amp; y &gt;= r) &#123; return b[p]; &#125; int m = (l + r) &gt;&gt; 1; if (x &lt;= m) s += qsum(x, y, l, m, ls(p)); if (y &gt; m) s += qsum(x, y, m + 1, r, rs(p)); return s; &#125;&#125; tree;void dfs1(int u, int f, int deep) &#123; dep[u] = deep; fa[u] = f; si[u] = 1; for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (to == f) continue; dfs1(to, u, deep + 1); si[u] += si[to]; if (si[to] &gt; si[son[u]]) son[u] = to; &#125;&#125;void dfs2(int u, int topf) &#123; id[u] = ++cnt; wt[cnt] = w[u]; top[u] = topf; if (!son[u]) return; dfs2(son[u], topf); for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (fa[u] == to || to == son[u]) continue; dfs2(to, to); &#125;&#125;inline int qrs(int x, int y) &#123; int ans = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) std::swap(x, y); ans += tree.qsum(id[top[x]], id[x], 1, n, 1); x = fa[top[x]]; &#125; if (dep[x] &gt; dep[y]) std::swap(x, y); ans += tree.qsum(id[x] + 1, id[y], 1, n, 1); return ans;&#125;inline void change(int x, int k) &#123; tree.updated(id[x], 1, n, 1, k);&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt; n; i++) &#123; scanf(\"%d%d\", &amp;_x, &amp;_y); add(_x, _y); add(_y, _x); &#125; dfs1(r, -1, 1); dfs2(r, r); while (m--) &#123; std::cin &gt;&gt; op; if (op == 'C') &#123; ccnt++; scanf(\"%d%d\", &amp;x[ccnt], &amp;y[ccnt]); if (dep[x[ccnt]] &lt; dep[y[ccnt]]) std::swap(x[ccnt], y[ccnt]); change(x[ccnt], 1); &#125; if (op == 'Q') &#123; scanf(\"%d%d\", &amp;_x, &amp;_y); if (qrs(_x, _y)) &#123; puts(\"No\"); &#125; else &#123; puts(\"Yes\"); &#125; &#125; if (op == 'U') &#123; scanf(\"%d\", &amp;_x); change(x[_x], -1); &#125; &#125;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"线段树","slug":"线段树","permalink":"https://stevebraveman.github.io/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://stevebraveman.github.io/tags/树链剖分/"}]},{"title":"-网络流-最大流-二分图-最大匹配- [洛谷 P2756][网络流24题]飞行员配对方案问题","slug":"59","date":"2019-01-22T13:58:00.000Z","updated":"2019-08-08T10:49:46.392Z","comments":true,"path":"2019/01/22/59/","link":"","permalink":"https://stevebraveman.github.io/2019/01/22/59/","excerpt":"题目背景第二次界大战时期.. 题目描述英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的2 名飞行员，其中1 名是英国飞行员，另1名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。如何选择配对飞行的飞行员才能使一次派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。","text":"题目背景第二次界大战时期.. 题目描述英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的2 名飞行员，其中1 名是英国飞行员，另1名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。如何选择配对飞行的飞行员才能使一次派出最多的飞机。对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。 对于给定的外籍飞行员与英国飞行员的配合情况，编程找出一个最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。 输入格式第 1 行有 2 个正整数 m 和 n。n 是皇家空军的飞行员总数(n&lt;100)；m 是外籍飞行员数(m&lt;=n)。外籍飞行员编号为 1~m；英国飞行员编号为 m+1~n。 接下来每行有 2 个正整数 i 和 j，表示外籍飞行员 i 可以和英国飞行员 j 配合。最后以 2个-1 结束。 输出格式第 1 行是最佳飞行员配对方案一次能派出的最多的飞机数 M。接下来 M 行是最佳飞行员配对方案。每行有 2个正整数 i 和 j，表示在最佳飞行员配对方案中，飞行员 i 和飞行员 j 配对。如果所求的最佳飞行员配对方案不存在，则输出‘No Solution!’。 输入样例5 101 71 82 62 92 103 73 84 74 85 10-1 -1 输出样例41 72 93 85 10 Solution把源点都连向皇家空军，把外籍飞行员连向汇点，然后再根据题意连边。 当时这道题我其实用的是匈牙利做的 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define MAXN 1002#define INF 2000000000namespace STman &#123; template &lt;typename Tp&gt; inline void read(Tp &amp;x) &#123; #define C getchar() Tp f = 1; x = 0; char k = C; while (k &lt; '0' || k &gt; '9') &#123; if (k == '-') f = -1; k = C; &#125; while (k &gt;= '0' &amp;&amp; k &lt;= '9') &#123; x = x * 10 + k - '0'; k = C; &#125; x = x * f; #undef C &#125; template &lt;typename Tp&gt; inline void write(Tp x) &#123; if (x &lt; 0) putchar('-') , x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0'); &#125; template &lt;typename Tp&gt; inline Tp max(Tp a , Tp b) &#123; if (a &gt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline Tp min(Tp a , Tp b) &#123; if (a &lt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline void swap(Tp &amp;a , Tp &amp;b) &#123; Tp t = a; a = b; b = a; &#125; template &lt;typename Tp&gt; inline Tp abs(Tp &amp;a) &#123; if (a &lt; 0) return -a; else return a; &#125; inline void sp() &#123; putchar(32); &#125; inline void et() &#123; putchar(10); &#125;&#125;using namespace STman;struct Edge &#123; int v , nx;&#125;e[MAXN];int mc[MAXN] , vis[MAXN] , n , m , ans , x , y , head[MAXN] , ecnt;void add(int f , int t) &#123; e[++ecnt] = (Edge) &#123;t , head[f]&#125;; head[f] = ecnt;&#125;bool Hungary(int k) &#123; for (int i = head[k] ; i ; i = e[i].nx) &#123; int to = e[i].v; if (!vis[to]) &#123; vis[to] = 1; if (!mc[to] || Hungary(mc[to])) &#123; mc[to] = k; return 1; &#125; &#125; &#125; return 0;&#125;int main() &#123; read(m) , read(n); read(x) , read(y); while (x != -1 &amp;&amp; y != -1) &#123; read(x) , read(y); add(x , y); &#125; for (int i = 1 ; i &lt;= m ; i++) &#123; ans += Hungary(i); memset(vis , 0 , sizeof(vis)); &#125; write(ans) , et(); for (int i = m + 1 ; i &lt;= n ; i++) &#123; if (mc[i]) write(mc[i]) , sp() , write(i) , et(); &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"二分图","slug":"二分图","permalink":"https://stevebraveman.github.io/tags/二分图/"},{"name":"最大匹配","slug":"最大匹配","permalink":"https://stevebraveman.github.io/tags/最大匹配/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"https://stevebraveman.github.io/tags/最大流/"},{"name":"网络流24题","slug":"网络流24题","permalink":"https://stevebraveman.github.io/tags/网络流24题/"}]},{"title":"-网络流-最大流-二分图- [洛谷 P2764][网络流24题]最小路径覆盖问题","slug":"60","date":"2019-01-22T13:58:00.000Z","updated":"2019-08-08T10:49:26.587Z","comments":true,"path":"2019/01/22/60/","link":"","permalink":"https://stevebraveman.github.io/2019/01/22/60/","excerpt":"题目描述给定有向图G=(V,E)。设P 是G 的一个简单路（顶点不相交）的集合。如果V 中每个顶点恰好在P 的一条路上，则称P是G 的一个路径覆盖。P 中路径可以从V 的任何一个顶点开始，长度也是任意的，特别地，可以为0。G 的最小路径覆盖是G 的所含路径条数最少的路径覆盖。设计一个有效算法求一个有向无环图G 的最小路径覆盖。","text":"题目描述给定有向图G=(V,E)。设P 是G 的一个简单路（顶点不相交）的集合。如果V 中每个顶点恰好在P 的一条路上，则称P是G 的一个路径覆盖。P 中路径可以从V 的任何一个顶点开始，长度也是任意的，特别地，可以为0。G 的最小路径覆盖是G 的所含路径条数最少的路径覆盖。设计一个有效算法求一个有向无环图G 的最小路径覆盖。 输入格式件第1 行有2个正整数n和m。n是给定有向无环图G 的顶点数，m是G 的边数。接下来的m行，每行有2 个正整数i和j，表示一条有向边(i,j)。输出格式 从第1 行开始，每行输出一条路径。文件的最后一行是最少路径数。 输入样例11 121 21 31 42 53 64 75 86 97 108 119 1110 11 输出样例1 4 7 10 112 5 83 6 93 说明1&lt;=n&lt;=150,1&lt;=m&lt;=6000 Solution其实原题面有个提示但是我懒得粘贴图片_(:з」∠)_ 这道题拆点 把每个点拆成两个点，然后根据题意连图即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define MAXN 1000100#define INF 2000000000int min(int a, int b) &#123; if (a &lt; b) return a; else return b;&#125;struct Edge &#123; int v, nx, w;&#125;e[MAXN];std::queue &lt;int&gt; q;int head[MAXN], ecnt = 1, n, m, x, y, dep[MAXN], cur[MAXN], nex[MAXN], r, k;bool vis[MAXN];void add(int f, int t, int w) &#123; e[++ecnt] = (Edge) &#123;t, head[f], w&#125;; head[f] = ecnt; e[++ecnt] = (Edge) &#123;f, head[t], 0&#125;; head[t] = ecnt;&#125;bool bfs(int s, int t) &#123; memset(dep, 0x7f, sizeof(dep)); while (!q.empty()) q.pop(); for (int i = 1; i &lt;= n * n + 2; i++) &#123; cur[i] = head[i]; &#125; dep[s] = 0; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (dep[to] &gt; INF &amp;&amp; e[i].w) &#123; dep[to] = dep[u] + 1; q.push(to); &#125; &#125; &#125; if (dep[t] &lt; INF) return 1; else return 0;&#125;int dfs(int s, int t, int l) &#123; if (!l || s == t) &#123; return l; &#125; int fl = 0, f; for (int i = cur[s]; i; i = e[i].nx) &#123; cur[s] = i; int to = e[i].v; if (dep[to] == dep[s] + 1 &amp;&amp; (f = dfs(to, t, min(l, e[i].w)))) &#123; l -= f; fl += f; e[i].w -= f; e[i ^ 1].w += f; if (!l) break; &#125; &#125; return fl;&#125;int Dinic(int s, int t) &#123; int maxf = 0; while (bfs(s, t)) &#123; maxf += dfs(s, t, INF); &#125; return maxf;&#125;void find(int x) &#123; printf(\"%d \", x); vis[x] = true; if (nex[x]) find(nex[x]);&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); r = n * 2 + 1; k = n * 2 + 2; for (int i = 1; i &lt;= n; i++) &#123; add(r, i, 1); add(i + n, k, 1); &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y + n, 1); &#125; int tot = n - Dinic(r, k); for (int i = 1; i &lt;= n; i++) &#123; for (int j = head[i]; j; j = e[j].nx) &#123; if (!e[j].w &amp;&amp; e[j].v != r) &#123; nex[i] = e[j].v - n; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i]) &#123; find(i); puts(\"\"); &#125; &#125; printf(\"%d\", tot);&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"二分图","slug":"二分图","permalink":"https://stevebraveman.github.io/tags/二分图/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"https://stevebraveman.github.io/tags/最大流/"},{"name":"网络流24题","slug":"网络流24题","permalink":"https://stevebraveman.github.io/tags/网络流24题/"}]},{"title":"-网络流-二分图-最大流-最大匹配- [洛谷 P4055][JSOI2009]游戏","slug":"58","date":"2019-01-20T13:58:00.000Z","updated":"2019-08-08T10:49:57.168Z","comments":true,"path":"2019/01/20/58/","link":"","permalink":"https://stevebraveman.github.io/2019/01/20/58/","excerpt":"题目描述 小AA和小YY得到了《喜羊羊和灰太狼》的电影票，都很想去观看，但是电影票只有一张，于是他们用智力游戏决定胜负，赢得游戏的人可以获得电影票。 在N*M的迷宫中有一个棋子，小AA首先任意选择棋子放置的位置。然后，小YY和小AA轮流将棋子移动到相邻的格子里。游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。","text":"题目描述 小AA和小YY得到了《喜羊羊和灰太狼》的电影票，都很想去观看，但是电影票只有一张，于是他们用智力游戏决定胜负，赢得游戏的人可以获得电影票。 在N*M的迷宫中有一个棋子，小AA首先任意选择棋子放置的位置。然后，小YY和小AA轮流将棋子移动到相邻的格子里。游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。 例如下图所示的迷宫，迷宫中”.”表示棋子可以经过的格子，而”#”表示棋子不可以经过的格子： .##… .若小AA将棋子放置在(1,1)，则小 AA 则无论如何都无法赢得游戏。 而若小AA将棋子放置在(3,2)或(2,3)，则小AA能够赢得游戏。例如，小AA将棋子放置在(3,2)，小YY只能将它移动到(2,2)，此时小AA再将棋子移动到(2,3)，就赢得了游戏。 小AA和小YY都是绝顶聪明的小朋友，且从不失误。小AA到底能不能赢得这场游戏，从而得到珍贵的电影票呢？ 输入格式输入数据首先输入两个整数 N,M，表示了迷宫的边长。接下来 N 行，每行 M 个字符，描述了迷宫。 输出格式若小 AA 能够赢得游戏，则输出一行”WIN”，然后输出所有可以赢得游戏的起始位置，按行优先顺序输出，每行一个。 否则输出一行”LOSE”（不包含引号）。 输入样例3 3.##… .输出样例WIN2 33 2 说明对30%的数据，有1&lt;=n,m&lt;=5 对100%的数据，有1&lt;=n,m&lt;=100 Solution这道题我么可以进行黑白染色，然后连边用最大流跑最大匹配，如果是完美匹配就无论如何小A也无法胜利，否则，就会出现一些小A能到达的点但是小Y却无法到达。 输出方案害死人 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define MAXN 10010001#define INF 2000000000struct Edge &#123; int v, nx, w;&#125;e[MAXN];int min(int a, int b) &#123; if (a &lt; b) return a; else return b;&#125;int head[MAXN], ecnt = 1, n, m, x, y, dep[MAXN], cur[MAXN], map[210][210], wb[210][210], r, k, cnt;int find[MAXN];bool vis[MAXN], wh[MAXN];void add(int f, int t, int w) &#123; e[++ecnt] = (Edge) &#123;t, head[f], w&#125;; head[f] = ecnt; e[++ecnt] = (Edge) &#123;f, head[t], 0&#125;; head[t] = ecnt;&#125;int g(int i, int j) &#123; return (i - 1) * m + j;&#125;std::queue &lt;int&gt; q;bool bfs(int s, int t) &#123; memset(dep, 0x7f, sizeof(dep)); dep[s] = 0; while (!q.empty()) q.pop(); q.push(s); for (int i = 1; i &lt;= n * m + 2; i++) &#123; cur[i] = head[i]; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (dep[to] &gt; INF &amp;&amp; e[i].w) &#123; dep[to] = dep[u] + 1; q.push(to); &#125; &#125; &#125; if (dep[t] &gt; INF) return 0; else return 1;&#125;int dfs(int s, int t, int l) &#123; if (!l || s == t) return l; int fl = 0, f; for (int i = cur[s]; i; i = e[i].nx) &#123; int to = e[i].v; cur[s] = i; if (dep[to] == dep[s] + 1 &amp;&amp; (f = dfs(to, t, min(l, e[i].w)))) &#123; l -= f; fl += f; e[i].w -= f; e[i ^ 1].w += f; if (!l) break; &#125; &#125; return fl;&#125;int Dinic(int s, int t) &#123; int maxf = 0; while (bfs(s, t)) &#123; maxf += dfs(s, t, INF); &#125; return maxf;&#125;void dfs(int now, int l) &#123; if (vis[now]) return ; vis[now] = 1; if (wh[now] == l) &#123; find[now] = 1; &#125; for (int i = head[now]; i; i = e[i].nx) &#123; if (e[i].w == l) dfs(e[i].v, l); &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); r = n * m + 1; k = n * m + 2; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; char a; std::cin &gt;&gt; a; if (a == '.') &#123; map[i][j] = 1; cnt++; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; wb[i][1] = wb[i - 1][1] ^ 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 2; j &lt;= m; j++) &#123; wb[i][j] = wb[i][j - 1] ^ 1; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (map[i][j] &amp;&amp; wb[i][j]) &#123; add(r ,g(i , j), 1); wh[g(i, j)] = 1; if (map[i + 1][j]) add(g(i, j), g(i + 1, j), 1); if (map[i - 1][j]) add(g(i, j), g(i - 1, j), 1); if (map[i][j + 1]) add(g(i, j), g(i, j + 1), 1); if (map[i][j - 1]) add(g(i, j), g(i, j - 1), 1); &#125; if (map[i][j] &amp;&amp; !wb[i][j]) &#123; add(g(i, j), k, 1); &#125; &#125; &#125; int tot = Dinic(r, k); if (cnt == tot) &#123; puts(\"LOSE\"); return 0; &#125; puts(\"WIN\"); dfs(r, 1); dfs(k, 0); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (find[g(i, j)]) &#123; printf(\"%d %d\\n\", i, j); &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"二分图","slug":"二分图","permalink":"https://stevebraveman.github.io/tags/二分图/"},{"name":"最大匹配","slug":"最大匹配","permalink":"https://stevebraveman.github.io/tags/最大匹配/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"https://stevebraveman.github.io/tags/最大流/"}]},{"title":"-网络流-最大流-二分图- [洛谷 P1402]酒店之王","slug":"57","date":"2019-01-08T13:58:00.000Z","updated":"2019-08-09T07:39:41.588Z","comments":true,"path":"2019/01/08/57/","link":"","permalink":"https://stevebraveman.github.io/2019/01/08/57/","excerpt":"题目描述XX酒店的老板想成为酒店之王，本着这种希望，第一步要将酒店变得人性化。由于很多来住店的旅客有自己喜好的房间色调、阳光等，也有自己所爱的菜，但是该酒店只有p间房间，一天只有固定的q道不同的菜。 有一天来了n个客人，每个客人说出了自己喜欢哪些房间，喜欢哪道菜。但是很不幸，可能做不到让所有顾客满意（满意的条件是住进喜欢的房间，吃到喜欢的菜）。 这里要怎么分配，能使最多顾客满意呢？","text":"题目描述XX酒店的老板想成为酒店之王，本着这种希望，第一步要将酒店变得人性化。由于很多来住店的旅客有自己喜好的房间色调、阳光等，也有自己所爱的菜，但是该酒店只有p间房间，一天只有固定的q道不同的菜。 有一天来了n个客人，每个客人说出了自己喜欢哪些房间，喜欢哪道菜。但是很不幸，可能做不到让所有顾客满意（满意的条件是住进喜欢的房间，吃到喜欢的菜）。 这里要怎么分配，能使最多顾客满意呢？ 输入格式第一行给出三个正整数表示n,p,q(&lt;=100)。 之后n行，每行p个数包含0或1，第i个数表示喜不喜欢第i个房间（1表示喜欢，0表示不喜欢）。 之后n行，每行q个数，表示喜不喜欢第i道菜。 输出格式最大的顾客满意数。 输入样例2 2 21 01 01 11 1 输出样例1 Solution其实这道题应该是三分图匹配，但是匈牙利只能应付二分图的情况，所以说我们可以用网络流拆点跑最大流解决。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define MAXN 1000002#define INF 2000000000int min(int a, int b) &#123; if (a &lt; b) return a; else return b;&#125;struct Edge &#123; int v, nx, w;&#125;e[MAXN];std::queue &lt;int&gt; q;int n, m, head[MAXN], ecnt = 1, x, y, z, r, k, dep[MAXN], cur[MAXN], qe, p;void add(int f, int t, int w) &#123; e[++ecnt] = (Edge) &#123;t, head[f] , w&#125;; head[f] = ecnt; e[++ecnt] = (Edge) &#123;f, head[t], 0&#125;; head[t] = ecnt;&#125;bool bfs(int s, int t) &#123; memset(dep, 0x7f, sizeof(dep)); while (!q.empty()) q.pop(); for (int i = 1; i &lt;= (n + n + qe + p + 2); i++) &#123; cur[i] = head[i]; &#125; dep[s] = 0; q.push(s); while (!q.empty()) &#123; int v = q.front(); q.pop(); for (int i = head[v]; i; i = e[i].nx) &#123; int to = e[i].v; if (dep[to] &gt; INF &amp;&amp; e[i].w) &#123; dep[to] = dep[v] + 1; q.push(to); &#125; &#125; &#125; if (dep[t] &lt; INF) return 1; else return 0;&#125;int dfs(int u, int t, int l) &#123; if (!l || u == t) return l; int fl = 0 , f; for (int i = cur[u]; i; i = e[i].nx) &#123; cur[u] = i; int to = e[i].v; if (dep[to] == dep[u] + 1 &amp;&amp; (f = dfs(to, t, min(l, e[i].w)))) &#123; fl += f; l -= f; e[i ^ 1].w += f; e[i].w -= f; if (!l) break; &#125; &#125; return fl;&#125;int Dinic(int s, int t) &#123; int maxf = 0; while (bfs(s, t)) &#123; maxf += dfs(s, t, INF); &#125; return maxf;&#125;int main() &#123; scanf(\"%d%d%d\", &amp;n, &amp;p, &amp;qe); r = n + n + p + qe + 1; k = n + n + p + qe + 2; for (int i = 1; i &lt;= p; i++) &#123; add(r, i, 1); &#125; for (int i = 1; i &lt;= qe; i++) &#123; add(p + i, k, 1); &#125; for (int i = 1; i &lt;= n; i++) &#123; add(i + p + qe, i + p + qe + n, 1); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= p; j++) &#123; scanf(\"%d\", &amp;x); if (x == 1) &#123; add(j, i + p + qe, 1); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= qe; j++) &#123; scanf(\"%d\", &amp;x); if (x == 1) &#123; add(i + p + qe + n, j + p, 1); &#125; &#125; &#125; printf(\"%d\\n\", Dinic(r, k)); return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"二分图","slug":"二分图","permalink":"https://stevebraveman.github.io/tags/二分图/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"https://stevebraveman.github.io/tags/最大流/"}]},{"title":"-网络流-最大流- [洛谷 P2891][USACO07OPEN]吃饭Dining","slug":"56","date":"2019-01-07T11:13:00.000Z","updated":"2019-08-08T10:50:11.661Z","comments":true,"path":"2019/01/07/56/","link":"","permalink":"https://stevebraveman.github.io/2019/01/07/56/","excerpt":"题目描述Cows are such finicky eaters. Each cow has a preference for certain foods and drinks, and she will consume no others. Farmer John has cooked fabulous meals for his cows, but he forgot to check his menu against their preferences. Although he might not be able to stuff everybody, he wants to give a complete meal of both food and drink to as many cows as possible. Farmer John has cooked F (1 ≤ F ≤ 100) types of foods and prepared D (1 ≤ D ≤ 100) types of drinks. Each of his N (1 ≤ N ≤ 100) cows has decided whether she is willing to eat a particular food or drink a particular drink. Farmer John must assign a food type and a drink type to each cow to maximize the number of cows who get both.","text":"题目描述Cows are such finicky eaters. Each cow has a preference for certain foods and drinks, and she will consume no others. Farmer John has cooked fabulous meals for his cows, but he forgot to check his menu against their preferences. Although he might not be able to stuff everybody, he wants to give a complete meal of both food and drink to as many cows as possible. Farmer John has cooked F (1 ≤ F ≤ 100) types of foods and prepared D (1 ≤ D ≤ 100) types of drinks. Each of his N (1 ≤ N ≤ 100) cows has decided whether she is willing to eat a particular food or drink a particular drink. Farmer John must assign a food type and a drink type to each cow to maximize the number of cows who get both. Each dish or drink can only be consumed by one cow (i.e., once food type 2 is assigned to a cow, no other cow can be assigned food type 2). 有F种食物和D种饮料，每种食物或饮料只能供一头牛享用，且每头牛只享用一种食物和一种饮料。现在有n头牛，每头牛都有自己喜欢的食物种类列表和饮料种类列表，问最多能使几头牛同时享用到自己喜欢的食物和饮料。（1 &lt;= f &lt;= 100, 1 &lt;= d &lt;= 100, 1 &lt;= n &lt;= 100） 输入格式Line 1: Three space-separated integers: N, F, and D Lines 2..N+1: Each line i starts with a two integers Fi and Di, the number of dishes that cow i likes and the number of drinks that cow i likes. The next Fi integers denote the dishes that cow i will eat, and the Di integers following that denote the drinks that cow i will drink. 输出格式Line 1: A single integer that is the maximum number of cows that can be fed both food and drink that conform to their wishes 输入样例4 3 32 2 1 2 3 12 2 2 3 1 22 2 1 3 1 22 1 1 3 3 输出样例3 说明One way to satisfy three cows is: Cow 1: no meal Cow 2: Food #2, Drink #2 Cow 3: Food #1, Drink #1 Cow 4: Food #3, Drink #3 The pigeon-hole principle tells us we can do no better since there are only three kinds of food or drink. Other test data sets are more challenging, of course. Solution这道题很多人把它说成是三分图最大匹配，但是这道题把它拆成两个二分图然后再进行匹配很不好做，于是就可以用网络流的最大流解决，把牛进行拆点，然后再根据题意连边就行了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define MAXN 1000002#define INF 2000000000int min(int a, int b) &#123; if (a &lt; b) return a; else return b;&#125;struct Edge &#123; int v, nx, w;&#125; e[MAXN];std::queue &lt;int&gt; q;int n, m, head[MAXN], ecnt = 1, x, y, z, r, k, dep[MAXN], cur[MAXN], cnt = 1, totp = 0, tot, xi, yi, c;void add(int f, int t, int w) &#123; e[++ecnt] = (Edge) &#123;t, head[f], w&#125;; head[f] = ecnt; e[++ecnt] = (Edge) &#123;f, head[t], 0&#125;; head[t] = ecnt;&#125;bool bfs(int s, int t) &#123; memset(dep, 0x7f, sizeof(dep)); while (!q.empty()) q.pop(); for (int i = 1; i &lt;= n + m + c + n + 2; i++) &#123; cur[i] = head[i]; &#125; dep[s] = 0; q.push(s); while (!q.empty()) &#123; int v = q.front(); q.pop(); for (int i = head[v]; i; i = e[i].nx) &#123; int to = e[i].v; if (dep[to] &gt; INF &amp;&amp; e[i].w) &#123; dep[to] = dep[v] + 1; q.push(to); &#125; &#125; &#125; if (dep[t] &lt; INF) return 1; else return 0;&#125;int dfs(int u, int t, int l) &#123; if (!l || u == t) return l; int fl = 0, f; for (int i = cur[u]; i; i = e[i].nx) &#123; cur[u] = i; int to = e[i].v; if (dep[to] == dep[u] + 1 &amp;&amp; (f = dfs(to, t, min(l, e[i].w)))) &#123; fl += f; l -= f; e[i ^ 1].w += f; e[i].w -= f; if (!l) break; &#125; &#125; return fl;&#125;int Dinic(int s, int t) &#123; int maxf = 0; while (bfs(s, t)) &#123; maxf += dfs(s, t , INF); &#125; return maxf;&#125;int a[MAXN], b[MAXN];int main() &#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;c); r = 2 * n + m + c + 1; k = 2 * n + m + c + 2; for (int i = 1; i &lt;= m; i++) &#123; add(r, i, 1); &#125; for (int i = 1; i &lt;= c; i++) &#123; add(m + i, k, 1); &#125; for (int i = 1; i &lt;= n; i++) &#123; add(i + c + m, i + c + m + n, 1); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d%d\", &amp;x, &amp;y); for (int j = 1; j &lt;= x; j++) &#123; scanf(\"%d\", &amp;xi); add(xi, i + c + m, 1); &#125; for (int j = 1; j &lt;= y; j++) &#123; scanf(\"%d\", &amp;yi); add(i + c + m + n, yi + m, 1); &#125; &#125; tot = Dinic(r, k); printf(\"%d\\n\", tot); return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"https://stevebraveman.github.io/tags/最大流/"}]},{"title":"-网络流-最小割- [洛谷 P2057][SHOI2007]善意的投票","slug":"55","date":"2019-01-06T07:03:00.000Z","updated":"2019-08-08T10:50:24.015Z","comments":true,"path":"2019/01/06/55/","link":"","permalink":"https://stevebraveman.github.io/2019/01/06/55/","excerpt":"题目描述幼儿园里有n个小朋友打算通过投票来决定睡不睡午觉。对他们来说，这个问题并不是很重要，于是他们决定发扬谦让精神。虽然每个人都有自己的主见，但是为了照顾一下自己朋友的想法，他们也可以投和自己本来意愿相反的票。我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。","text":"题目描述幼儿园里有n个小朋友打算通过投票来决定睡不睡午觉。对他们来说，这个问题并不是很重要，于是他们决定发扬谦让精神。虽然每个人都有自己的主见，但是为了照顾一下自己朋友的想法，他们也可以投和自己本来意愿相反的票。我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。 我们的问题就是，每位小朋友应该怎样投票，才能使冲突数最小？ 输入格式文件的第一行只有两个整数n，m，保证有2≤n≤300，1≤m≤n(n-1)/2。其中n代表总人数，m代表好朋友的对数。文件第二行有n个整数，第i个整数代表第i个小朋友的意愿，当它为1时表示同意睡觉，当它为0时表示反对睡觉。接下来文件还有m行，每行有两个整数i，j。表示i，j是一对好朋友，我们保证任何两对i，j不会重复。 输出格式只需要输出一个整数，即可能的最小冲突数。 输入样例3 31 0 01 21 33 2 输出样例1 说明2≤n≤300，1≤m≤n(n-1)/2。 Solution这道题这么建模： 把源点都连向同意睡觉的人，再把所有不同意睡觉的人都连向汇点，再在朋友之间连边。 于是这道题就成了最小割。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define MAXN 1000002#define INF 2000000000int min(int a, int b) &#123; if (a &lt; b) return a; else return b;&#125;struct Edge &#123; int v, nx, w;&#125; e[MAXN];std::queue &lt;int&gt; q;int n, m, head[MAXN], ecnt = 1, x, y, z, r, k, dep[MAXN], cur[MAXN], cnt = 1, totp = 0, tot, c, p, g;void add(int f, int t, int w) &#123; e[++ecnt] = (Edge) &#123;t, head[f], w&#125;; head[f] = ecnt; e[++ecnt] = (Edge) &#123;f, head[t], 0&#125;; head[t] = ecnt;&#125;bool bfs(int s, int t) &#123; memset(dep, 0x7f, sizeof(dep)); while (!q.empty()) q.pop(); for (int i = 1; i &lt;= n + 2; i++) &#123; cur[i] = head[i]; &#125; dep[s] = 0; q.push(s); while (!q.empty()) &#123; int v = q.front(); q.pop(); for (int i = head[v]; i; i = e[i].nx) &#123; int to = e[i].v; if (dep[to] &gt; INF &amp;&amp; e[i].w) &#123; dep[to] = dep[v] + 1; q.push(to); &#125; &#125; &#125; if (dep[t] &lt; INF) return 1; else return 0;&#125;int dfs(int u, int t, int l) &#123; if (!l || u == t) return l; int fl = 0, f; for (int i = cur[u]; i; i = e[i].nx) &#123; cur[u] = i; int to = e[i].v; if (dep[to] == dep[u] + 1 &amp;&amp; (f = dfs(to, t, min(l, e[i].w)))) &#123; fl += f; l -= f; e[i ^ 1].w += f; e[i].w -= f; if (!l) break; &#125; &#125; return fl;&#125;int Dinic(int s, int t) &#123; int maxf = 0; while (bfs(s, t)) &#123; maxf += dfs(s, t , INF); &#125; return maxf;&#125;int h(int i, int j) &#123; return (i - 1) * m + j;&#125;char a, b;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); r = n + 1; k = n + 2; for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;x); if (x == 1) &#123; add(r, i, 1); &#125; else &#123; add(i, k, 1); &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y, 1); add(y, x, 1); &#125; tot = Dinic(r, k); printf(\"%d\\n\", tot); return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"最小割","slug":"最小割","permalink":"https://stevebraveman.github.io/tags/最小割/"}]},{"title":"-网络流-最小割- [洛谷 P4001][BJOI2006]狼抓兔子","slug":"54","date":"2018-12-29T08:31:00.000Z","updated":"2019-08-08T10:50:42.109Z","comments":true,"path":"2018/12/29/54/","link":"","permalink":"https://stevebraveman.github.io/2018/12/29/54/","excerpt":"题目描述现在小朋友们最喜欢的”喜羊羊与灰太狼”,话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形：","text":"题目描述现在小朋友们最喜欢的”喜羊羊与灰太狼”,话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形： 左上角点为(1,1),右下角点为(N,M)(上图中N=3,M=4).有以下三种类型的道路 1:(x,y)&lt;==&gt;(x+1,y) 2:(x,y)&lt;==&gt;(x,y+1) 3:(x,y)&lt;==&gt;(x+1,y+1) 道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的. 左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角(1,1)的窝里，现在它们要跑到右下角(N,M)的窝中去，狼王开始伏击这些兔子.当然为了保险起见，如果一条道路上最多通过的兔子数为K，狼王需要安排同样数量的K只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦。 输入格式第一行为N,M.表示网格的大小，N,M均小于等于1000. 接下来分三部分 第一部分共N行，每行M-1个数，表示横向道路的权值. 第二部分共N-1行，每行M个数，表示纵向道路的权值. 第三部分共N-1行，每行M-1个数，表示斜向道路的权值. 输出格式输出一个整数，表示参与伏击的狼的最小数量. 输入样例3 45 6 44 3 17 5 35 6 7 88 7 6 55 5 56 6 6 输出样例14 Solution这道题显然最小割。 于是这道题就变成板子题了 但是代码放在BZOJ上过不去，请忽略 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define MAXN 10000100#define INF 2000000000namespace STman &#123; inline char gc()&#123; #ifdef ONLINE_JUDGE static char now[1 &lt;&lt; 16], *S, *T; if (T == S) &#123;T = (S = now) + fread(now, 1, 1 &lt;&lt; 16, stdin); if (T == S) return EOF;&#125; return *S++; #else return getchar(); #endif &#125; template &lt;typename Tp&gt; inline void read(Tp &amp;x) &#123; Tp f = 1;x = 0; char k = gc(); while (k &lt; '0' || k &gt; '9') &#123;if (k == '-') f = -1;k = gc();&#125; while (k &gt;= '0' &amp;&amp; k &lt;= '9') &#123;x = x * 10 + k - '0';k = gc();&#125; x = x * f; &#125; template &lt;typename Tp&gt; inline void write(Tp x) &#123; if (x &lt; 0) putchar('-') , x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0'); &#125; template &lt;typename Tp&gt; inline Tp max(Tp a , Tp b) &#123; if (a &gt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline Tp min(Tp a , Tp b) &#123; if (a &lt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline void swap(Tp &amp;a , Tp &amp;b) &#123; Tp t = a; a = b; b = t; &#125; template &lt;typename Tp&gt; inline Tp abs(Tp &amp;a) &#123; if (a &lt; 0) return -a; else return a; &#125; inline void sp() &#123; putchar(32); &#125; inline void et() &#123; putchar(10); &#125;&#125;using namespace STman;struct Edge &#123; int v, nx, w;&#125;e[MAXN];std::queue &lt;int&gt; q;int head[MAXN], ecnt = 1, n, m, x, dep[MAXN], cur[MAXN], r, k;inline int g(int i, int j) &#123; return (i - 1) * m + j;&#125;void add(int f, int t, int w) &#123; e[++ecnt] = (Edge) &#123;t, head[f], w&#125;; head[f] = ecnt; e[++ecnt] = (Edge) &#123;f, head[t], w&#125;; head[t] = ecnt;&#125;inline bool bfs(int s, int t) &#123; memset(dep, 0, sizeof(dep)); while (!q.empty()) q.pop(); for (int i = 1; i &lt;= n * m; i++) &#123; cur[i] = head[i]; &#125; dep[s] = 1; q.push(s); while (!q.empty()) &#123; int v = q.front(); q.pop(); for (int i = head[v]; i; i = e[i].nx) &#123; int to = e[i].v; if (dep[to] == 0 &amp;&amp; e[i].w &gt; 0) &#123; dep[to] = dep[v] + 1; q.push(to); &#125; &#125; &#125; if (dep[t] &gt; 0) return 1; else return 0;&#125;int dfs(int u, int t, int l) &#123; if (!l || u == t) return l; int fl = 0 , f; for (int i = cur[u]; i; i = e[i].nx) &#123; cur[u] = i; int to = e[i].v; if (dep[to] == dep[u] + 1 &amp;&amp; (f = dfs(to, t, min(l, e[i].w)))) &#123; fl += f; l -= f; e[i ^ 1].w += f; e[i].w -= f; if (!l) break; &#125; &#125; return fl;&#125;int Dinic(int s , int t) &#123; int maxf = 0; while (bfs(s , t)) &#123; maxf += dfs(s , t , INF); &#125; return maxf;&#125;int main() &#123; read(n), read(m); r = g(1, 1); k = g(n, m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; m; j++) &#123; read(x); add(g(i, j), g(i, j + 1), x); &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; read(x); add(g(i, j), g(i + 1, j), x); &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 1; j &lt; m; j++) &#123; read(x); add(g(i, j), g(i + 1, j + 1), x); &#125; &#125; write(Dinic(r, k)); return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"最小割","slug":"最小割","permalink":"https://stevebraveman.github.io/tags/最小割/"}]},{"title":"-数论-扩展欧几里得-BSGS- [BZOJ 2242][SDOI2011]计算器","slug":"53","date":"2018-12-28T11:20:00.000Z","updated":"2019-08-08T10:51:30.959Z","comments":true,"path":"2018/12/28/53/","link":"","permalink":"https://stevebraveman.github.io/2018/12/28/53/","excerpt":"题目描述你被要求设计一个计算器完成以下三项任务： 1、给定y、z、p，计算y^z mod p 的值； 2、给定y、z、p，计算满足xy ≡z(mod p)的最小非负整数x； 3、给定y、z、p，计算满足y^x ≡z(mod p)的最小非负整数x。 为了拿到奖品，全力以赴吧！","text":"题目描述你被要求设计一个计算器完成以下三项任务： 1、给定y、z、p，计算y^z mod p 的值； 2、给定y、z、p，计算满足xy ≡z(mod p)的最小非负整数x； 3、给定y、z、p，计算满足y^x ≡z(mod p)的最小非负整数x。 为了拿到奖品，全力以赴吧！ 输入格式输入文件calc.in 包含多组数据。 第一行包含两个正整数T、K，分别表示数据组数和询问类型（对于一个测试点内的所有数 据，询问类型相同）。 以下T 行每行包含三个正整数y、z、p，描述一个询问。 输出格式输出文件calc.out 包括T 行. 对于每个询问，输出一行答案。 对于询问类型2 和3，如果不存在满足条件的，则输出“Orz, I cannot find x!”。 输入样例3 12 1 32 2 32 3 3 输出样例212 说明【数据规模和约定】 对于100%的数据，1&lt;=y,z,p&lt;=10^9，P为质数，1&lt;=T&lt;=10。 Solution对于操作1，我们用快速幂 对于操作2，我们用扩展欧几里得 对于操作3，我们用BSGS（北上广深） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#define ll long longll qpow(ll a , ll b , ll m) &#123; ll res = 1; while (b) &#123; if (b &amp; 1) res = (res * a) % m; b &gt;&gt;= 1; a = (a * a) % m; &#125; return res % m;&#125;ll exgcd(ll a , ll b , ll &amp;x , ll &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; ll d = exgcd(b , a % b , x , y); ll z = x; x = y; y = z - y * (a / b); return d;&#125;bool le(ll a , ll b , ll c , ll &amp;x , ll &amp;y) &#123; ll d = exgcd(a , b , x , y); if (c % d) return 0; ll k = c / d; x *= k; y *= k; return 1;&#125;ll bsgs(ll a , ll b , ll p) &#123; std::map &lt;ll , ll&gt; h; h.clear(); b %= p; ll t = sqrt(p) + 1; for (int i = 0 ; i &lt; t ; i++) &#123; ll v = b * qpow(a , i , p) % p; h[v] = i; &#125; a = qpow(a , t , p); if (a == 0) return (b == 0) ? 1 : -1; for (int i = 0 ; i &lt;= t ; i++) &#123; int v = qpow(a , i , p); int j = h.find(v) == h.end() ? -1 : h[v]; if (j &gt;= 0 &amp;&amp; i * t - j &gt;= 0) return i * t - j; &#125; return -1;&#125;ll n , y , z , k , m , x , flag , p;int main() &#123; scanf(\"%lld%lld\" , &amp;n , &amp;flag); for (int i = 1 ; i &lt;= n ; i++) &#123; scanf(\"%lld%lld%lld\" , &amp;y , &amp;z , &amp;p); if (flag == 1) &#123; printf(\"%lld\" , qpow(y , z , p)); &#125; if (flag == 2) &#123; if (le(y , p , z , x , m)) &#123; printf(\"%lld\" , (x % p + p) % p); &#125; else &#123; printf(\"Orz, I cannot find x!\"); &#125; &#125; if (flag == 3) &#123; if (bsgs(y , z , p) == -1) &#123; printf(\"Orz, I cannot find x!\"); &#125; else &#123; printf(\"%lld\" , bsgs(y , z , p)); &#125; &#125; puts(\"\"); &#125;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://stevebraveman.github.io/tags/BZOJ/"},{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"https://stevebraveman.github.io/tags/扩展欧几里得/"},{"name":"BSGS","slug":"BSGS","permalink":"https://stevebraveman.github.io/tags/BSGS/"}]},{"title":"-树链剖分-线段树- [洛谷 P2146][NOI2015]软件包管理器","slug":"52","date":"2018-12-20T13:13:00.000Z","updated":"2019-08-08T10:52:35.218Z","comments":true,"path":"2018/12/20/52/","link":"","permalink":"https://stevebraveman.github.io/2018/12/20/52/","excerpt":"题目描述Linux用户和OSX用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu使用的apt-get，Fedora/CentOS使用的yum，以及OSX下可用的homebrew都是优秀的软件包管理器。","text":"题目描述Linux用户和OSX用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu使用的apt-get，Fedora/CentOS使用的yum，以及OSX下可用的homebrew都是优秀的软件包管理器。 你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包A依赖软件包B，那么安装软件包A以前，必须先安装软件包B。同时，如果想要卸载软件包B，则必须卸载软件包A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除0号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而0号软件包不依赖任何一个软件包。依赖关系不存在环（若有m(m≥2)个软件包A1,A2,A3,⋯,Am，其中A1依赖A2，A2依赖A3，A3依赖A4，……，A[m-1]依赖Am，而Am依赖A1，则称这m个软件包的依赖关系构成环），当然也不会有一个软件包依赖自己。 现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为0。 输入格式从文件manager.in中读入数据。 输入文件的第1行包含1个整数n，表示软件包的总数。软件包从0开始编号。 随后一行包含n−1个整数，相邻整数之间用单个空格隔开，分别表示1,2,3,⋯,n−2,n−1号软件包依赖的软件包的编号。 接下来一行包含1个整数q，表示询问的总数。之后q行，每行1个询问。询问分为两种： install x：表示安装软件包x uninstall x：表示卸载软件包x 你需要维护每个软件包的安装状态，一开始所有的软件包都处于未安装状态。 对于每个操作，你需要输出这步操作会改变多少个软件包的安装状态，随后应用这个操作（即改变你维护的安装状态）。 输出格式输出到文件manager.out中。 输出文件包括q行。 输出文件的第i行输出1个整数，为第i步操作中改变安装状态的软件包数。 输入样例70 0 0 1 1 55install 5install 6uninstall 1install 4uninstall 0 输出样例31323 Solution如果用1表示已安装，0表示未安装，那么先将这道题转换成人话： 操作install：统计x到根节点路径上为0的节点个数并输出，并把这一路径上的节点都赋值为1 操作uninstall：统计以x为根的子树的节点为1的个数，并把这个子树上的节点都赋值为0 然后这道题就很好理解了。 如何解决第一个操作呢，很简单，先统计出节点为1的个数，再用x的深度-节点为1的个数，然后再用线段树的区间覆盖就可以了 那么第二个操作呢，也很简单，直接统计子树上1的个数，然后再覆盖。 下面是愉快的代码时间： Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define ls(x) ((x) &lt;&lt; 1)#define rs(x) ((x) &lt;&lt; 1 | 1)#define INF 0x7fffffff#define MAXN 5000000#define abs(x) ((x) &lt; 0 ? (-x) : (x))int max(int a, int b) &#123; if (a &gt; b) return a; else return b;&#125;void swap(int &amp;x, int &amp;y) &#123; int t = x; x = y; y = t;&#125;struct Edge &#123; int v, nx;&#125;e[MAXN];int head[MAXN], ecnt, n, m, x, y, dep[MAXN], si[MAXN], wt[MAXN], w[MAXN], fat[MAXN];int fa[MAXN], top[MAXN], son[MAXN], cnt, r = 1, id[MAXN], f[MAXN];void add(int f, int t) &#123; e[++ecnt] = (Edge) &#123;t, head[f]&#125;; head[f] = ecnt;&#125;struct Segtree &#123; int a[MAXN], b[MAXN &lt;&lt; 2], lazy[MAXN &lt;&lt; 2]; void pd(int p) &#123; b[p] = b[ls(p)] + b[rs(p)]; &#125; void build(int l, int r, int p) &#123; lazy[p] = -1; if (l == r) &#123; b[p] = a[l]; return; &#125; int m = (l + r) &gt;&gt; 1; build(l, m, ls(p)); build(m + 1, r, rs(p)); pd(p); &#125; void f(int p, int l, int r, int k) &#123; lazy[p] = k; b[p] = k * (r - l + 1); return; &#125; void pushd(int p, int l, int r) &#123; if (lazy[p] != -1) &#123; int m = (l + r) &gt;&gt; 1; f(ls(p), l, m, lazy[p]); f(rs(p), m + 1, r, lazy[p]); lazy[p] = -1; &#125; &#125; void updater(int x, int y, int l, int r, int p, int k) &#123; if (x &lt;= l &amp;&amp; y &gt;= r) &#123; lazy[p] = k; b[p] = k * (r - l + 1); return; &#125; pushd(p, l, r); int m = (l + r) &gt;&gt; 1; if (x &lt;= m) updater(x, y, l, m, ls(p), k); if (y &gt; m) updater(x, y, m + 1, r, rs(p), k); pd(p); &#125; int qsum(int x, int y, int l, int r, int p) &#123; int s = 0; if (x &lt;= l &amp;&amp; y &gt;= r) &#123; return b[p]; &#125; int m = (l + r) &gt;&gt; 1; pushd(p, l, r); if (x &lt;= m) s += qsum(x, y, l, m, ls(p)); if (y &gt; m) s += qsum(x, y, m + 1, r, rs(p)); return s; &#125;&#125;tree;void dfs1(int u, int f, int deep) &#123; dep[u] = deep; fa[u] = f; si[u] = 1; for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (to == f) continue; dfs1(to, u, deep + 1); si[u] += si[to]; if (si[to] &gt; si[son[u]]) son[u] = to; &#125;&#125;void dfs2(int u, int topf) &#123; id[u] = ++cnt; wt[cnt] = w[u]; top[u] = topf; if (!son[u]) return; dfs2(son[u], topf); for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (fa[u] == to || to == son[u]) continue; dfs2(to, to); &#125;&#125;inline void upr(int x, int y, int k) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); tree.updater(id[top[x]], id[x], 1, n, 1, k); x = fa[top[x]]; &#125; if (dep[x] &gt; dep[y]) swap(x, y); tree.updater(id[x], id[y], 1, n, 1, k);&#125;inline int tq(int x, int y) &#123; int ans = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); ans += tree.qsum(id[top[x]], id[x], 1, n, 1); x = fa[top[x]]; &#125; if (dep[x] &gt; dep[y]) swap(x, y); ans += tree.qsum(id[x], id[y], 1, n, 1); return ans;&#125;inline void ups(int x, int k) &#123; tree.updater(id[x], id[x] + si[x] - 1, 1, n, 1, k);&#125;inline int qs(int x) &#123; return tree.qsum(id[x], id[x] + si[x] - 1, 1, n, 1);&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 2; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;x); x++; fat[i]++; add(i, x); add(x, i); &#125; dfs1(r, -1, 1); dfs2(r, r); tree.build(1, n, 1); scanf(\"%d\", &amp;m); while (m--) &#123; char op[20]; scanf(\"%s\", op); if (op[0] == 'i') &#123; scanf(\"%d\", &amp;x); x++; printf(\"%d\\n\", dep[x] - tq(x, r)); upr(x, r, 1); &#125; if (op[0] == 'u') &#123; scanf(\"%d\", &amp;x); x++; printf(\"%d\\n\", qs(x)); ups(x, 0); &#125; &#125;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"线段树","slug":"线段树","permalink":"https://stevebraveman.github.io/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://stevebraveman.github.io/tags/树链剖分/"}]},{"title":"-强连通分量-图论- [洛谷 P2860][USACO06JAN]冗余路径Redundant Paths","slug":"51","date":"2018-12-12T12:36:00.000Z","updated":"2019-08-09T07:39:55.557Z","comments":true,"path":"2018/12/12/51/","link":"","permalink":"https://stevebraveman.github.io/2018/12/12/51/","excerpt":"题目描述In order to get from one of the F (1 &lt;= F &lt;= 5,000) grazing fields (which are numbered 1..F) to another field, Bessie and the rest of the herd are forced to cross near the Tree of Rotten Apples. The cows are now tired of often being forced to take a particular path and want to build some new paths so that they will always have a choice of at least two separate routes between any pair of fields. They currently have at least one route between each pair of fields and want to have at least two. Of course, they can only travel on Official Paths when they move from one field to another. Given a description of the current set of R (F-1 &lt;= R &lt;= 10,000) paths that each connect exactly two different fields, determine the minimum number of new paths (each of which connects exactly two fields) that must be built so that there are at least two separate routes between any pair of fields. Routes are considered separate if they use none of the same paths, even if they visit the same intermediate field along the way. There might already be more than one paths between the same pair of fields, and you may also build a new path that connects the same fields as some other path. 为了从F(1≤F≤5000)个草场中的一个走到另一个，贝茜和她的同伴们有时不得不路过一些她们讨厌的可怕的树．奶牛们已经厌倦了被迫走某一条路，所以她们想建一些新路，使每一对草场之间都会至少有两条相互分离的路径，这样她们就有多一些选择．","text":"题目描述In order to get from one of the F (1 &lt;= F &lt;= 5,000) grazing fields (which are numbered 1..F) to another field, Bessie and the rest of the herd are forced to cross near the Tree of Rotten Apples. The cows are now tired of often being forced to take a particular path and want to build some new paths so that they will always have a choice of at least two separate routes between any pair of fields. They currently have at least one route between each pair of fields and want to have at least two. Of course, they can only travel on Official Paths when they move from one field to another. Given a description of the current set of R (F-1 &lt;= R &lt;= 10,000) paths that each connect exactly two different fields, determine the minimum number of new paths (each of which connects exactly two fields) that must be built so that there are at least two separate routes between any pair of fields. Routes are considered separate if they use none of the same paths, even if they visit the same intermediate field along the way. There might already be more than one paths between the same pair of fields, and you may also build a new path that connects the same fields as some other path. 为了从F(1≤F≤5000)个草场中的一个走到另一个，贝茜和她的同伴们有时不得不路过一些她们讨厌的可怕的树．奶牛们已经厌倦了被迫走某一条路，所以她们想建一些新路，使每一对草场之间都会至少有两条相互分离的路径，这样她们就有多一些选择． 每对草场之间已经有至少一条路径．给出所有R(F-1≤R≤10000)条双向路的描述，每条路连接了两个不同的草场，请计算最少的新建道路的数量, 路径由若干道路首尾相连而成．两条路径相互分离，是指两条路径没有一条重合的道路．但是，两条分离的路径上可以有一些相同的草场． 对于同一对草场之间，可能已经有两条不同的道路，你也可以在它们之间再建一条道路，作为另一条不同的道路． 输入格式Line 1: Two space-separated integers: F and R Lines 2..R+1: Each line contains two space-separated integers which are the fields at the endpoints of some path. 输出格式Line 1: A single integer that is the number of new paths that must be built. 输入样例7 71 22 33 42 54 55 65 7 输出样例2 说明Explanation of the sample: One visualization of the paths is: 1 2 3 +—-+—-+ | | | | 6 +—-+—-+ 4 / 5 / / 7 +Building new paths from 1 to 6 and from 4 to 7 satisfies the conditions. 1 2 3 +—-+—-+: 6 +—-+—-+ 4 / 5 : / : / : 7 + - - - - Check some of the routes: 1 – 2: 1 –&gt; 2 and 1 –&gt; 6 –&gt; 5 –&gt; 2 1 – 4: 1 –&gt; 2 –&gt; 3 –&gt; 4 and 1 –&gt; 6 –&gt; 5 –&gt; 4 3 – 7: 3 –&gt; 4 –&gt; 7 and 3 –&gt; 2 –&gt; 5 –&gt; 7 Every pair of fields is, in fact, connected by two routes. It’s possible that adding some other path will also solve the problem (like one from 6 to 7). Adding two paths, however, is the minimum. Solution将这道题目描述转换成人话：求出最少的加边数量使这个图无割边。 然后就很好理解了，我们可以先将这个图缩点，因为在无向图的环上是没有割边的（总感觉哪里说的不对），然后这个图就变成了一棵树。最后求一下叶子结点的个数+1再除以2就行了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define MAXN 1001000int min(int a, int b) &#123; if (a &lt; b) return a; else return b;&#125;struct Edge &#123; int f, v, nx;&#125;e[MAXN];int head[MAXN], ecnt, dfn[MAXN], low[MAXN], n, m, x, y, tim, st[MAXN], top, g[MAXN];int num, br, in[MAXN];bool mp[5005][5005];void add(int f, int t) &#123; e[++ecnt] = (Edge) &#123;f, t, head[f]&#125;; head[f] = ecnt;&#125;void tarjan(int u, int fa) &#123; dfn[u] = low[u] = ++tim; st[++top] = u; for (int i = head[u]; i; i = e[i].nx) &#123; int v = e[i].v; if (fa == v) continue; if (!dfn[v]) &#123; tarjan(v, u); low[u] = min(low[u], low[v]); &#125; else low[u] = min(dfn[v], low[u]); &#125; if (low[u] == dfn[u]) &#123; int v; num++; do &#123; v = st[top--]; in[v] = num; &#125; while (u != v); &#125;&#125;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf(\"%d%d\", &amp;x, &amp;y); if (mp[x][y] || mp[y][x]) &#123; continue; &#125; add(x, y); add(y, x); mp[x][y] = mp[y][x] = 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) tarjan(i, -1); &#125; for (int i = 1; i &lt;= ecnt; i += 2) &#123; int f = e[i].f, v = e[i].v; if (in[f] != in[v]) &#123; g[in[f]]++; g[in[v]]++; &#125; &#125; for (int i = 1; i &lt;= num; i++) &#123; if (g[i] == 1) br++; &#125; printf(\"%d\", (br + 1) &gt;&gt; 1); return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"图论","slug":"图论","permalink":"https://stevebraveman.github.io/tags/图论/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://stevebraveman.github.io/tags/强连通分量/"}]},{"title":"-二分图-最大匹配-二分- [洛谷 P4251][SCOI2015]小凸玩矩阵","slug":"50","date":"2018-12-11T12:41:00.000Z","updated":"2019-08-08T10:52:45.475Z","comments":true,"path":"2018/12/11/50/","link":"","permalink":"https://stevebraveman.github.io/2018/12/11/50/","excerpt":"题目描述小凸和小方是好朋友，小方给了小凸一个 $n × m$ $(n \\leq m)$ 的矩阵 $A$，并且要求小凸从矩阵中选出 $n$ 个数，其中任意两个数都不能在同一行或者同一列。现在小凸想知道，选出的 $n$ 个数中第 $k$ 大的数的最小值是多少。","text":"题目描述小凸和小方是好朋友，小方给了小凸一个 $n × m$ $(n \\leq m)$ 的矩阵 $A$，并且要求小凸从矩阵中选出 $n$ 个数，其中任意两个数都不能在同一行或者同一列。现在小凸想知道，选出的 $n$ 个数中第 $k$ 大的数的最小值是多少。 输入格式第 $1$ 行读入 $3$ 个整数 $n, m, k$。 接下来 $n$ 行，每一行有 $m$ 个数字，第 $i$ 行第 $j$ 个数字代表矩阵中第 $i$ 行第 $j$ 列的元素 $A_{i,j}$。 输出格式输出包含一行，为选出的 $n$ 个数中第 $k$ 大数的最小值。 输入样例2 3 11 2 42 4 1 输出样例1 说明对于 $20\\%$ 的数据， $1 \\leq n \\leq m \\leq 9$ 对于 $40\\%$ 的数据， $1 \\leq n \\leq m \\leq 22, 1 \\leq n \\leq 12$ 对于 $100\\%$ 的数据， $1 \\leq k \\leq n \\leq m \\leq 250, 1 \\leq A_{i,j} \\leq 10^9$ Solution这道题要求求出第k大数的最小值，所以肯定要用二分，又由于选了这个数就不能选其他数，所以我们可以把行和列连边，再用匈牙利进行匹配就可以了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 1000010namespace STman &#123; inline char gc()&#123; #ifdef ONLINE_JUDGE static char now[1 &lt;&lt; 16], *S, *T; if (T == S) &#123;T = (S = now) + fread(now, 1, 1 &lt;&lt; 16, stdin); if (T == S) return EOF;&#125; return *S++; #else return getchar(); #endif &#125; template &lt;typename Tp&gt; inline void read(Tp &amp;x) &#123; Tp f = 1;x = 0; char k = gc(); while (k &lt; '0' || k &gt; '9') &#123;if (k == '-') f = -1;k = gc();&#125; while (k &gt;= '0' &amp;&amp; k &lt;= '9') &#123;x = x * 10 + k - '0';k = gc();&#125; x = x * f; &#125; template &lt;typename Tp&gt; inline void write(Tp x) &#123; if (x &lt; 0) putchar('-') , x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0'); &#125; template &lt;typename Tp&gt; inline Tp max(Tp a , Tp b) &#123; if (a &gt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline Tp min(Tp a , Tp b) &#123; if (a &lt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline void swap(Tp &amp;a , Tp &amp;b) &#123; Tp t = a; a = b; b = t; &#125; template &lt;typename Tp&gt; inline Tp abs(Tp &amp;a) &#123; if (a &lt; 0) return -a; else return a; &#125; inline void sp() &#123; putchar(32); &#125; inline void et() &#123; putchar(10); &#125;&#125;using namespace STman;struct Edge &#123; int v, nx, w;&#125;e[MAXN];int head[MAXN], mch[MAXN / 100], ecnt, n, m, k, vis[MAXN / 10], l, r, mid, cnt, a, limi = 0;void add(int f, int t, int w) &#123; e[++ecnt] = (Edge) &#123;t, head[f], w&#125;; head[f] = ecnt;&#125;bool Hungary(int k, int t, int w) &#123; for (int i = head[k]; i; i = e[i].nx) &#123; int to = e[i].v; if (vis[to] != t &amp;&amp; e[i].w &lt;= w) &#123; vis[to] = t; if (!mch[to] || Hungary(mch[to], t, w)) &#123; mch[to] = k; return 1; &#125; &#125; &#125; return 0;&#125;int check(int lim) &#123; int ans = 0; memset(vis, 0, sizeof(vis)); memset(mch, 0, sizeof(mch)); for (int i = 1; i &lt;= n; i++) &#123; if (Hungary(i, i, lim)) ans++; &#125; return ans;&#125;int main() &#123; read(n), read(m), read(k); k = n - k + 1; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; read(a); add(i, j, a); limi = max(a, limi); &#125; &#125; l = 1, r = limi; while (l &lt; r) &#123; mid = (l + r) &gt;&gt; 1; if (check(mid) &gt;= k) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; write(l); return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"二分","slug":"二分","permalink":"https://stevebraveman.github.io/tags/二分/"},{"name":"二分图","slug":"二分图","permalink":"https://stevebraveman.github.io/tags/二分图/"},{"name":"最大匹配","slug":"最大匹配","permalink":"https://stevebraveman.github.io/tags/最大匹配/"}]},{"title":"-强连通分量-DFS- [洛谷 P4306][JSOI2010]连通数","slug":"49","date":"2018-12-11T10:23:01.000Z","updated":"2019-08-08T10:52:55.050Z","comments":true,"path":"2018/12/11/49/","link":"","permalink":"https://stevebraveman.github.io/2018/12/11/49/","excerpt":"题目描述度量一个有向图恋情情况的一个指标是连通，指途中可达点对的个数。","text":"题目描述度量一个有向图恋情情况的一个指标是连通，指途中可达点对的个数。下图的连通数是14 现在要你求出连通数 输入格式输入数据第一行是图顶点的数量，一个正整数N。 接下来N行，每行N个字符。第i行第j列的1表示顶点i到j有边，0则表示无边。 输出格式输出一行一个整数，表示该图的连通数。 输入样例3010001100 输出样例9 说明对于100%的数据，N不超过2000。 Solution对于这道题，我们先将这个有向图缩点，然后在进行dfs就可以了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 10010namespace STman &#123; inline char gc()&#123; #ifdef ONLINE_JUDGE static char now[1 &lt;&lt; 16], *S, *T; if (T == S) &#123;T = (S = now) + fread(now, 1, 1 &lt;&lt; 16, stdin); if (T == S) return EOF;&#125; return *S++; #else return getchar(); #endif &#125; template &lt;typename Tp&gt; inline void read(Tp &amp;x) &#123; Tp f = 1;x = 0; char k = gc(); while (k &lt; '0' || k &gt; '9') &#123;if (k == '-') f = -1;k = gc();&#125; while (k &gt;= '0' &amp;&amp; k &lt;= '9') &#123;x = x * 10 + k - '0';k = gc();&#125; x = x * f; &#125; template &lt;typename Tp&gt; inline void write(Tp x) &#123; if (x &lt; 0) putchar('-') , x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0'); &#125; template &lt;typename Tp&gt; inline Tp max(Tp a , Tp b) &#123; if (a &gt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline Tp min(Tp a , Tp b) &#123; if (a &lt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline void swap(Tp &amp;a , Tp &amp;b) &#123; Tp t = a; a = b; b = t; &#125; template &lt;typename Tp&gt; inline Tp abs(Tp &amp;a) &#123; if (a &lt; 0) return -a; else return a; &#125; inline void sp() &#123; putchar(32); &#125; inline void et() &#123; putchar(10); &#125;&#125;using namespace STman;struct Edge &#123; int v, nx;&#125;e[MAXN * 100];int n, m, dfn[MAXN], low[MAXN], num, tim, st[MAXN], top, in[MAXN], si[MAXN], kk;int x[MAXN], y[MAXN], cnt, tot[MAXN], vis[MAXN], p[MAXN], ans, ecnt, head[MAXN];void add(int f, int t) &#123; e[++ecnt] = (Edge) &#123;t, head[f]&#125;; head[f] = ecnt;&#125;void tarjan(int u) &#123; dfn[u] = low[u] = ++tim; st[++top] = u; vis[u] = 1; for (int i = head[u]; i; i = e[i].nx) &#123; int v = e[i].v; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (vis[v]) low[u] = min(low[u], dfn[v]); &#125; if (low[u] == dfn[u]) &#123; num++; int v; do &#123; v = st[top--]; vis[v] = 0; in[v] = num; si[v]++; &#125; while (u != v); &#125;&#125;void dfs(int u, int t) &#123; tot[u] += p[u], vis[u] = t; for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (vis[to] == t) continue; dfs(to, t); &#125;&#125;int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; int c; scanf(\"%1d\", &amp;c); if (c == 1) &#123; x[++cnt] = i, y[cnt] = j; add(i, j); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) tarjan(i); &#125; memset(head, 0, sizeof(head)); memset(e, 0, sizeof(e)); memset(vis, 0, sizeof(vis)); ecnt = 0; for (int i = 1; i &lt;= cnt; i++) &#123; if (in[x[i]] != in[y[i]]) &#123; add(in[x[i]], in[y[i]]); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; p[in[i]]++; &#125; for (int i = 1; i &lt;= n; i++) &#123; dfs(in[i], ++kk); &#125; for (int i = 1; i &lt;= num; i++) &#123; ans += tot[i]; &#125; write(ans), et();&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"DFS","slug":"DFS","permalink":"https://stevebraveman.github.io/tags/DFS/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://stevebraveman.github.io/tags/强连通分量/"}]},{"title":"-图论-强连通分量-LCA- [洛谷 P2783]有机化学之神偶尔会做作弊","slug":"48","date":"2018-12-10T11:25:15.000Z","updated":"2019-08-08T10:53:18.265Z","comments":true,"path":"2018/12/10/48/","link":"","permalink":"https://stevebraveman.github.io/2018/12/10/48/","excerpt":"题目背景XS中学化学竞赛组教练是一个酷爱炉石的人。 有一天他一边搓炉石一边监考，而你作为一个信息竞赛的大神也来凑热闹。 然而你的化竞基友却向你求助了。 “第1354题怎么做”&lt;—手语 他问道。","text":"题目背景XS中学化学竞赛组教练是一个酷爱炉石的人。 有一天他一边搓炉石一边监考，而你作为一个信息竞赛的大神也来凑热闹。 然而你的化竞基友却向你求助了。 “第1354题怎么做”&lt;—手语 他问道。 题目描述你翻到那一题：给定一个烃，只含有单键（给初中生的一个理解性解释：就是一堆碳用横线连起来，横线都是单条的）。 然后炎魔之王拉格纳罗斯用他的火焰净化了一切环（？？？）。所有的环状碳都变成了一个碳。如图所示。 然后指定多组碳，求出它们之间总共有多少碳。如图所示（和上图没有关系）。 但是因为在考试，所以你只能把这个答案用手语告诉你的基友。你决定用二进制来表示最后的答案。如图所示（不要在意，和题目没有什么没关系）。 输入格式第一行两个整数n,m.表示有n个点，m根键 接下来m行每行两个整数u，v表示u号碳和v号碳有一根键 接下来一个整数tot表示询问次数 接下来tot行每行两个整数，a,b表示询问的两个碳的编号 输出格式共tot行 每行一个二进制数 输入样例3 21 22 321 22 3 输出样例1010 Solution先进行无向图的缩点，然后再用倍增求LCA就可以了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 100010#define LOG 30namespace STman &#123; inline char gc()&#123; #ifdef ONLINE_JUDGE static char now[1 &lt;&lt; 16], *S, *T; if (T == S) &#123;T = (S = now) + fread(now, 1, 1 &lt;&lt; 16, stdin); if (T == S) return EOF;&#125; return *S++; #else return getchar(); #endif &#125; template &lt;typename Tp&gt; inline void read(Tp &amp;x) &#123; Tp f = 1;x = 0; char k = gc(); while (k &lt; '0' || k &gt; '9') &#123;if (k == '-') f = -1;k = gc();&#125; while (k &gt;= '0' &amp;&amp; k &lt;= '9') &#123;x = x * 10 + k - '0';k = gc();&#125; x = x * f; &#125; template &lt;typename Tp&gt; inline void write(Tp x) &#123; if (x &lt; 0) putchar('-') , x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0'); &#125; template &lt;typename Tp&gt; inline Tp max(Tp a , Tp b) &#123; if (a &gt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline Tp min(Tp a , Tp b) &#123; if (a &lt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline void swap(Tp &amp;a , Tp &amp;b) &#123; Tp t = a; a = b; b = t; &#125; template &lt;typename Tp&gt; inline Tp abs(Tp &amp;a) &#123; if (a &lt; 0) return -a; else return a; &#125; inline void sp() &#123; putchar(32); &#125; inline void et() &#123; putchar(10); &#125;&#125;using namespace STman;struct Edge &#123; int v, nx;&#125;e[MAXN];int head[MAXN], ecnt, dfn[MAXN], in[MAXN], st[MAXN], q, f, g;int top, num, n, m, x[MAXN], y[MAXN], low[MAXN], tim;int anc[MAXN &lt;&lt; 1][LOG], dep[MAXN &lt;&lt; 1], len;bool vis[MAXN], a[MAXN];void add(int f, int t) &#123; e[++ecnt] = (Edge) &#123;t, head[f]&#125;; head[f] = ecnt;&#125;void tarjan(int u, int fa) &#123; dfn[u] = low[u] = ++tim; st[++top] = u; for (int i = head[u]; i; i = e[i].nx) &#123; int v = e[i].v; if (v == fa) continue; if (!dfn[v]) &#123; tarjan(v, u); low[u] = min(low[u], low[v]); &#125; else low[u] = min(low[u], dfn[v]); &#125; if (low[u] == dfn[u]) &#123; int v; num++; do &#123; v = st[top--]; in[v] = num; &#125; while (u != v); &#125;&#125;void dfs(int u, int p, int d) &#123; anc[u][0] = p; dep[u] = d; for (int i = head[u]; i; i = e[i].nx) &#123; int to = e[i].v; if (to == p) continue; dfs(to, u, d + 1); &#125;&#125;inline void init(int r, int n) &#123; dfs(r, 0, 1); for (int j = 1; j &lt; LOG; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; anc[i][j] = anc[anc[i][j - 1]][j - 1]; &#125; &#125;&#125;inline int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) std::swap(x , y); int h = dep[x] - dep[y]; for (int i = 0; h &gt; 0; i++) &#123; if (h &amp; 1) x = anc[x][i]; h &gt;&gt;= 1; &#125; if (x == y) return x; for (int i = LOG - 1; i &gt;= 0; i--) &#123; if (anc[x][i] != anc[y][i]) &#123; x = anc[x][i]; y = anc[y][i]; &#125; &#125; return anc[x][0];&#125;int main() &#123; read(n), read(m); for (int i = 1; i &lt;= m; i++) &#123; read(x[i]), read(y[i]); add(x[i], y[i]); add(y[i], x[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) tarjan(i, -1); &#125; memset(vis, 0, sizeof(vis)); memset(head, 0, sizeof(head)); memset(e, 0, sizeof(e)); ecnt = 0; for (int i = 1; i &lt;= m; i++) &#123; if (in[x[i]] != in[y[i]]) &#123; add(in[x[i]], in[y[i]]); add(in[y[i]], in[x[i]]); &#125; &#125; init(1, num); read(q); for (int i = 1; i &lt;= q; i++) &#123; read(f), read(g); int ws = 0; f = in[f]; g = in[g]; int lca = dep[f] + dep[g] - 2 * dep[LCA(f, g)] + 1; while (lca) &#123; a[++ws] = lca % 2; lca /= 2; &#125; for (int j = ws; j &gt;= 1; j--) &#123; write(a[j]); &#125; et(); &#125;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"图论","slug":"图论","permalink":"https://stevebraveman.github.io/tags/图论/"},{"name":"LCA","slug":"LCA","permalink":"https://stevebraveman.github.io/tags/LCA/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://stevebraveman.github.io/tags/强连通分量/"}]},{"title":"-二分图-最大匹配- [洛谷 P2417]课程","slug":"47","date":"2018-12-09T13:45:25.000Z","updated":"2019-08-08T10:53:41.895Z","comments":true,"path":"2018/12/09/47/","link":"","permalink":"https://stevebraveman.github.io/2018/12/09/47/","excerpt":"题目描述n个学生去p个课堂，每一个学生都有自己的课堂，并且每个学生只能去一个课堂，题目要求能够安排每一个课堂都有人吗？","text":"题目描述n个学生去p个课堂，每一个学生都有自己的课堂，并且每个学生只能去一个课堂，题目要求能够安排每一个课堂都有人吗？ 输入格式第一行是测试数据的个数， 每组测试数据的开始分别是p和n， 接着p行，每行的开始是这个课堂的学生人数m，接着m个数代表该课堂的学生编号 输出格式如果该组数据能够这样安排就输出YES，否则输出NO。 输入样例23 33 1 2 32 1 21 13 32 1 32 1 31 1 输出样例YESNO 说明对于100%的数据，$n\\le 100,m\\le 20000$ Solution裸的二分图最大匹配。 二分图匹配n倍经验 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 10010namespace STman &#123; inline char gc()&#123; #ifdef ONLINE_JUDGE static char now[1 &lt;&lt; 16], *S, *T; if (T == S) &#123;T = (S = now) + fread(now, 1, 1 &lt;&lt; 16, stdin); if (T == S) return EOF;&#125; return *S++; #else return getchar(); #endif &#125; template &lt;typename Tp&gt; inline void read(Tp &amp;x) &#123; Tp f = 1;x = 0; char k = gc(); while (k &lt; '0' || k &gt; '9') &#123;if (k == '-') f = -1;k = gc();&#125; while (k &gt;= '0' &amp;&amp; k &lt;= '9') &#123;x = x * 10 + k - '0';k = gc();&#125; x = x * f; &#125; template &lt;typename Tp&gt; inline void write(Tp x) &#123; if (x &lt; 0) putchar('-') , x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0'); &#125; template &lt;typename Tp&gt; inline Tp max(Tp a , Tp b) &#123; if (a &gt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline Tp min(Tp a , Tp b) &#123; if (a &lt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline void swap(Tp &amp;a , Tp &amp;b) &#123; Tp t = a; a = b; b = t; &#125; template &lt;typename Tp&gt; inline Tp abs(Tp &amp;a) &#123; if (a &lt; 0) return -a; else return a; &#125; inline void sp() &#123; putchar(32); &#125; inline void et() &#123; putchar(10); &#125;&#125;using namespace STman;struct Edge &#123; int v, nx;&#125;e[MAXN];int head[MAXN], ecnt, n, t, m, mch[MAXN], vis[MAXN], p, x, tot;void add(int f, int t) &#123; e[++ecnt] = (Edge) &#123;t, head[f]&#125;; head[f] = ecnt;&#125;bool Hungary(int k, int t) &#123; for (int i = head[k]; i; i = e[i].nx) &#123; int to = e[i].v; if (vis[to] != t) &#123; vis[to] = t; if (!mch[to] || Hungary(mch[to], t)) &#123; mch[to] = k; return 1; &#125; &#125; &#125; return 0;&#125;int main() &#123; read(t); while (t--) &#123; read(n), read(m); memset(head, 0, sizeof(head)); memset(mch, 0, sizeof(mch)); memset(vis, 0, sizeof(vis)); ecnt = 0, tot = 0; for (int i = 1; i &lt;= n; i++) &#123; read(p); while (p--) &#123; read(x); add(i, x); &#125; &#125; if (n &gt; m) &#123; puts(\"NO\"); continue; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (Hungary(i, i)) &#123; tot++; &#125; &#125; if (tot == n) &#123; puts(\"YES\"); &#125; else &#123; puts(\"NO\"); &#125; &#125;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"二分图","slug":"二分图","permalink":"https://stevebraveman.github.io/tags/二分图/"},{"name":"最大匹配","slug":"最大匹配","permalink":"https://stevebraveman.github.io/tags/最大匹配/"}]},{"title":"-二分图-最大匹配- [洛谷 P5030]长脖子鹿放置","slug":"46","date":"2018-12-03T11:00:45.000Z","updated":"2019-08-08T10:53:52.463Z","comments":true,"path":"2018/12/03/46/","link":"","permalink":"https://stevebraveman.github.io/2018/12/03/46/","excerpt":"题目描述如图所示，西洋棋的“长脖子鹿”，类似于中国象棋的马，但按照“目”字攻击，且没有中国象棋“别马腿”的规则。（因为长脖子鹿没有马腿）","text":"题目描述如图所示，西洋棋的“长脖子鹿”，类似于中国象棋的马，但按照“目”字攻击，且没有中国象棋“别马腿”的规则。（因为长脖子鹿没有马腿） 给定一个 $N * M$ ，的棋盘，有一些格子禁止放棋子。问棋盘上最多能放多少个不能互相攻击的长脖子鹿。 输入格式输入的第一行为两个正整数 $N$，$M$，$K$。其中 $K$ 表示禁止放置长脖子鹿的格子数。 第 $2$ ~第 $K+1$ 行每一行为两个整数 $Xi, Yi$，表示禁止放置的格子。 输出格式一行一个正整数，表示最多能放置的长脖子鹿个数。 输入样例8 7 51 15 42 34 78 3 输出样例28 说明 重要提示：请务必思考对图的遍历顺序对运行速度的影响 对于 $10\\%$ 的数据，$1 ≤ N,M ≤ 5$ 对于 $30\\%$ 的数据，$1 ≤ N,M ≤ 10$ 对于 $60\\%$ 的数据，$1 ≤ N,M ≤ 50$ 对于 $80\\%$ 的数据，$1 ≤ N,M ≤ 100$ 对于 $100\\%$的数据，$1 ≤ N,M ≤ 200$ Solution这道题是一道求二分图最大独立集的题，只是需要改一下建图方式。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define MAXN 1000010namespace STman &#123; template &lt;typename Tp&gt; inline void read(Tp &amp;x) &#123; #define C getchar() Tp f = 1; x = 0; char k = C; while (k &lt; '0' || k &gt; '9') &#123; if (k == '-') f = -1; k = C; &#125; while (k &gt;= '0' &amp;&amp; k &lt;= '9') &#123; x = x * 10 + k - '0'; k = C; &#125; x = x * f; #undef C &#125; template &lt;typename Tp&gt; inline void write(Tp x) &#123; if (x &lt; 0) putchar('-') , x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0'); &#125; template &lt;typename Tp&gt; inline Tp max(Tp a , Tp b) &#123; if (a &gt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline Tp min(Tp a , Tp b) &#123; if (a &lt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline void swap(Tp &amp;a , Tp &amp;b) &#123; Tp t = a; a = b; b = a; &#125; template &lt;typename Tp&gt; inline Tp abs(Tp &amp;a) &#123; if (a &lt; 0) return -a; else return a; &#125; inline void sp() &#123; putchar(32); &#125; inline void et() &#123; putchar(10); &#125;&#125;using namespace STman;struct Edge &#123; int v, nx;&#125;e[MAXN];int head[MAXN], ecnt, n, m, h, G[210][210], x, y, ans, tot, vis[MAXN], mtch[MAXN], cnt;int dx[] = &#123;0, -1, -3, 1, 3, -1, -3, 1, 3&#125;, dy[] = &#123;0, -3, -1, -3, -1, 3, 1, 3, 1&#125;;int g(int i, int j) &#123; return (i - 1) * m + j;&#125;void add(int f, int t) &#123; e[++ecnt] = (Edge) &#123;t, head[f]&#125;; head[f] = ecnt;&#125;bool Hungary(int k, int t) &#123; for (int i = head[k]; i; i = e[i].nx) &#123; int to = e[i].v; if (vis[to] != t) &#123; vis[to] = t; if (!mtch[to] || Hungary(mtch[to], t)) &#123; mtch[to] = k; return 1; &#125; &#125; &#125; return 0;&#125;int main() &#123; read(n), read(m), read(h); for (int i = 1; i &lt;= h; i++) &#123; read(x), read(y); G[x][y] = 1; &#125; for (int i = 1; i &lt;= n; i += 2) &#123; for (int j = 1; j &lt;= m; j++) &#123; if(!G[i][j]) &#123; for (int k = 1; k &lt;= 8; k++) &#123; int tx = i + dx[k], ty = j + dy[k]; if (tx &gt; n || tx &lt; 1 || ty &gt; m || ty &lt; 1 || G[tx][ty]) continue; add(g(i, j), g(tx, ty)); &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i += 2) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (!G[i][j]) &#123; if (Hungary(g(i, j), ++cnt)) &#123; ans++; &#125; &#125; &#125; &#125; write(n * m - h - ans); return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"二分图","slug":"二分图","permalink":"https://stevebraveman.github.io/tags/二分图/"},{"name":"最大匹配","slug":"最大匹配","permalink":"https://stevebraveman.github.io/tags/最大匹配/"}]},{"title":"-图论-强连通分量- [洛谷 P2746][USACO5.3]校园网Network of Schools","slug":"45","date":"2018-11-28T11:03:04.000Z","updated":"2019-08-08T10:54:03.148Z","comments":true,"path":"2018/11/28/45/","link":"","permalink":"https://stevebraveman.github.io/2018/11/28/45/","excerpt":"题目描述一些学校连入一个电脑网络。那些学校已订立了协议：每个学校都会给其它的一些学校分发软件（称作“接受学校”）。注意即使 B 在 A 学校的分发列表中， A 也不一定在 B 学校的列表中。","text":"题目描述一些学校连入一个电脑网络。那些学校已订立了协议：每个学校都会给其它的一些学校分发软件（称作“接受学校”）。注意即使 B 在 A 学校的分发列表中， A 也不一定在 B 学校的列表中。你要写一个程序计算，根据协议，为了让网络中所有的学校都用上新软件，必须接受新软件副本的最少学校数目（子任务 A）。更进一步，我们想要确定通过给任意一个学校发送新软件，这个软件就会分发到网络中的所有学校。为了完成这个任务，我们可能必须扩展接收学校列表，使其加入新成员。计算最少需要增加几个扩展，使得不论我们给哪个学校发送新软件，它都会到达其余所有的学校（子任务 B）。一个扩展就是在一个学校的接收学校列表中引入一个新成员。 输入格式输入文件的第一行包括一个整数 N：网络中的学校数目（2 &lt;= N &lt;= 100）。学校用前 N 个正整数标识。 接下来 N 行中每行都表示一个接收学校列表（分发列表）。第 i+1 行包括学校 i 的接收学校的标识符。每个列表用 0 结束。空列表只用一个 0 表示。 输出格式你的程序应该在输出文件中输出两行。 第一行应该包括一个正整数：子任务 A 的解。 第二行应该包括子任务 B 的解。 输入样例52 4 3 04 5 0001 0 输出样例12 Solution先求一下强连通分量，然后再缩点，最后统计一下出度入度就行了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 100010namespace STman &#123; template &lt;typename Tp&gt; inline void read(Tp &amp;x) &#123; #define C getchar() Tp f = 1;x = 0; char k = C; while (k &lt; '0' || k &gt; '9') &#123;if (k == '-') f = -1;k = C;&#125; while (k &gt;= '0' &amp;&amp; k &lt;= '9') &#123;x = x * 10 + k - '0';k = C;&#125; x = x * f; #undef C &#125; template &lt;typename Tp&gt; inline void write(Tp x) &#123; if (x &lt; 0) putchar('-') , x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0'); &#125; template &lt;typename Tp&gt; inline Tp max(Tp a , Tp b) &#123; if (a &gt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline Tp min(Tp a , Tp b) &#123; if (a &lt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline void swap(Tp &amp;a , Tp &amp;b) &#123; Tp t = a; a = b; b = a; &#125; template &lt;typename Tp&gt; inline Tp abs(Tp &amp;a) &#123; if (a &lt; 0) return -a; else return a; &#125; inline void sp() &#123; putchar(32); &#125; inline void et() &#123; putchar(10); &#125;&#125;using namespace STman;struct Edge &#123; int v , nx;&#125;e[MAXN * 4];int dfn[MAXN] , tot , m , ecnt , st[MAXN] , out[MAXN] , smen;int hd , in[MAXN] , low[MAXN] , en[MAXN] , head[MAXN] , tim , smout , n;bool vis[MAXN];void add(int f , int t) &#123; e[++ecnt] = (Edge) &#123;t , head[f]&#125;; head[f] = ecnt;&#125;void tarjan(int u) &#123; dfn[u] = low[u] = ++tim; st[++hd] = u; vis[u] = 1; for (int i = head[u] ; i ; i = e[i].nx) &#123; int v = e[i].v; if (!dfn[v]) &#123; tarjan(v); low[u] = min(low[u] , low[v]); &#125; else if (vis[v]) &#123; low[u] = min(dfn[v] , low[u]); &#125; &#125; if (low[u] == dfn[u]) &#123; tot++; int v; do &#123; v = st[hd--]; vis[v] = 0; in[v] = tot; &#125; while(v != u); &#125;&#125;int main() &#123; read(n); for (int i = 1 ; i &lt;= n ; i++) &#123; read(m); while (m != 0) &#123; add(i , m); read(m); &#125; &#125; for (int i = 1 ; i &lt;= n ; i++) &#123; if (!dfn[i]) &#123; tarjan(i); &#125; &#125; for (int i = n ; i &gt;= 1 ; i--) &#123; for (int j = head[i] ; j ; j = e[j].nx) &#123; int to = e[j].v; if (in[to] != in[i]) &#123; out[in[i]] = 1; en[in[to]] = 1; &#125; &#125; &#125; for (int i = 1 ; i &lt;= tot ; i++) &#123; smen += en[i] == 1 ? 0 : 1; smout += out[i] == 1 ? 0 : 1; &#125; if (tot == 1) &#123; printf(\"1\\n0\"); return 0; &#125; printf(\"%d\\n%d\" , smen , max(smen , smout));&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"图论","slug":"图论","permalink":"https://stevebraveman.github.io/tags/图论/"},{"name":"强连通分量","slug":"强连通分量","permalink":"https://stevebraveman.github.io/tags/强连通分量/"}]},{"title":"-网络流-最大流- [洛谷 P1343]地震逃生","slug":"44","date":"2018-11-28T10:52:07.000Z","updated":"2019-08-08T10:54:13.446Z","comments":true,"path":"2018/11/28/44/","link":"","permalink":"https://stevebraveman.github.io/2018/11/28/44/","excerpt":"题目描述汶川地震发生时，四川**中学正在上课，一看地震发生，老师们立刻带领x名学生逃跑，整个学校可以抽象地看成一个有向图，图中有n个点，m条边。","text":"题目描述汶川地震发生时，四川**中学正在上课，一看地震发生，老师们立刻带领x名学生逃跑，整个学校可以抽象地看成一个有向图，图中有n个点，m条边。1号点为教室，n号点为安全地带，每条边都只能容纳一定量的学生，超过楼就要倒塌，由于人数太多，校长决定让同学们分成几批逃生，只有第一批学生全部逃生完毕后，第二批学生才能从1号点出发逃生，现在请你帮校长算算，每批最多能运出多少个学生，x名学生分几批才能运完。输入输出格式输入格式： 第一行3个整数n,m,x(x","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"网络流","slug":"网络流","permalink":"https://stevebraveman.github.io/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"https://stevebraveman.github.io/tags/最大流/"}]},{"title":"-二分图-最大匹配- [洛谷 P2319][HNOI2006]超级英雄","slug":"43","date":"2018-11-28T10:40:07.000Z","updated":"2019-08-08T10:54:42.473Z","comments":true,"path":"2018/11/28/43/","link":"","permalink":"https://stevebraveman.github.io/2018/11/28/43/","excerpt":"题目描述现在电视台有一种节目叫做超级英雄，大概的流程就是每位选手到台上回答主持人的几个问题，然后根据回答问题的多少获得不同数目的奖品或奖金。主持人问题准备了若干道题目，只有当选手正确回答一道题后，才能进入下一题，否则就被淘汰。为了增加节目的趣味性并适当降低难度，主持人总提供给选手几个“锦囊妙计”，比如求助现场观众，或者去掉若干个错误答案（选择题）等等。","text":"题目描述现在电视台有一种节目叫做超级英雄，大概的流程就是每位选手到台上回答主持人的几个问题，然后根据回答问题的多少获得不同数目的奖品或奖金。主持人问题准备了若干道题目，只有当选手正确回答一道题后，才能进入下一题，否则就被淘汰。为了增加节目的趣味性并适当降低难度，主持人总提供给选手几个“锦囊妙计”，比如求助现场观众，或者去掉若干个错误答案（选择题）等等。这里，我们把规则稍微改变一下。假设主持人总共有m道题，选手有n种不同的“锦囊妙计”。主持人规定，每道题都可以从两种“锦囊妙计”中选择一种，而每种“锦囊妙计”只能用一次。我们又假设一道题使用了它允许的锦囊妙计后，就一定能正确回答，顺利进入下一题。现在我来到了节目现场，可是我实在是太笨了，以至于一道题也不会做，每道题只好借助使用“锦囊妙计”来通过。如果我事先就知道了每道题能够使用哪两种“锦囊妙计”，那么你能告诉我怎样选择才能通过最多的题数吗？ 输入格式：输入的第一行是两个正整数 $n$ 和 $m$ $(0&lt;n&lt;1001,0&lt;m&lt;1001)$,表示总共有 n 种“锦囊妙计”，编号为 $0…n−1$，总共有 $m$ 个问题。 以下的 $m$ 行，每行两个数，分别表示第 $m$ 个问题可以使用的“锦囊妙计”的编号。 注意，每种编号的“锦囊妙计”只能使用一次，同一个问题的两个“锦囊妙计”可能一样。 输出格式输出的第一行为最多能通过的题数 $p$，接下来 $p$ 行，每行为一个整数，第 $i$ 行表示第 $i$ 题使用的“锦囊妙计的编号”。 如果有多种答案，那么任意输出一种，本题使用 Special Judge 评判答案。 输入样例5 63 22 00 30 43 23 2 输出样例43204 Solution最近学了一下二分图匹配，找了几道题目练练手。。。。 这道题可以很容易看出是一道二分图最大匹配的一道题，但是有一个地方需要注意，我们需要在答不出题的情况下直接退出循环。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 100010namespace STman &#123; template &lt;typename Tp&gt; inline void read(Tp &amp;x) &#123; #define C getchar() Tp f = 1;x = 0; char k = C; while (k &lt; '0' || k &gt; '9') &#123;if (k == '-') f = -1; k = C;&#125; while (k &gt;= '0' &amp;&amp; k &lt;= '9') &#123;x = x * 10 + k - '0'; k = C;&#125; x = x * f; #undef C &#125; template &lt;typename Tp&gt; inline void write(Tp x) &#123; if (x &lt; 0) putchar('-') , x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0'); &#125; template &lt;typename Tp&gt; inline Tp max(Tp a, Tp b) &#123; if (a &gt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline Tp min(Tp a, Tp b) &#123; if (a &lt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline void swap(Tp &amp;a, Tp &amp;b) &#123; Tp t = a; a = b; b = t; &#125; template &lt;typename Tp&gt; inline Tp abs(Tp &amp;a) &#123; if (a &lt; 0) return -a; else return a; &#125; inline void sp() &#123; putchar(32); &#125; inline void et() &#123; putchar(10); &#125;&#125;using namespace STman;struct Edge &#123; int v, nx;&#125;e[MAXN];int head[MAXN], ecnt, n, m, mtch[MAXN], ans[MAXN], x, y, tot;bool vis[MAXN];void add(int f, int t) &#123; e[++ecnt] = (Edge) &#123;t, head[f]&#125;; head[f] = ecnt;&#125;bool Hungary(int k) &#123; for (int i = head[k]; i; i = e[i].nx) &#123; int to = e[i].v; if (!vis[to]) &#123; vis[to] = 1; if (!mtch[to] || Hungary(mtch[to])) &#123; mtch[to] = k; ans[k] = to; return 1; &#125; &#125; &#125; return 0;&#125;int main() &#123; read(n), read(m); for (int i = 1; i &lt;= m; i++) &#123; read(x), read(y); add(i, x); add(i, y); &#125; for (int i = 1; i &lt;= m; i++) &#123; memset(vis, 0, sizeof(vis)); if (Hungary(i)) &#123; tot++; &#125; else break; &#125; write(tot), et(); for (int i = 1; i &lt;= tot; i++) &#123; write(ans[i]), et(); &#125;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"二分图","slug":"二分图","permalink":"https://stevebraveman.github.io/tags/二分图/"},{"name":"最大匹配","slug":"最大匹配","permalink":"https://stevebraveman.github.io/tags/最大匹配/"}]},{"title":"-其它- RiverFun的专用namespace","slug":"42","date":"2018-11-08T07:00:36.000Z","updated":"2019-08-08T10:54:51.781Z","comments":true,"path":"2018/11/08/42/","link":"","permalink":"https://stevebraveman.github.io/2018/11/08/42/","excerpt":"这个代码主要就是在平常装逼的 后天都要NOIp了我却还在研究这东西估计NOIp要凉 支持各种整型读入，各种整型的大小比较，但是不能在变量类型不同的两个变量间比较。","text":"这个代码主要就是在平常装逼的 后天都要NOIp了我却还在研究这东西估计NOIp要凉 支持各种整型读入，各种整型的大小比较，但是不能在变量类型不同的两个变量间比较。废话不多说，直接上代码： 12345678910111213141516171819202122232425262728293031namespace STman &#123; #define C getchar() #define P(a) putchar(a + '0') template &lt;typename Tp&gt; inline void read(Tp &amp;x) &#123; Tp f = 1;x = 0; char k = C; while (k &lt; '0' || k &gt; '9') &#123;if (k == '-') f = -1;k = C;&#125; while (k &gt;= '0' &amp;&amp; k &lt;= '9') &#123;x = x * 10 + k - '0';k = C;&#125; x = x * f; &#125; template &lt;typename Tp&gt; inline void write(Tp x) &#123; if (x &lt; 0) P(-3) , x = -x; if (x &gt; 9) write(x / 10); P(x % 10); &#125; template &lt;typename Tp&gt; inline Tp max(Tp a , Tp b) &#123; if (a &gt; b) return a; else return b; &#125; template &lt;typename Tp&gt; inline Tp min(Tp a , Tp b) &#123; if (a &lt; b) return a; else return b; &#125; #undef C #undef P(a)&#125;using namespace STman; 也许会报Warning但绝对不会CE。 如果我不退役的话时常会有咕咕咕的更新","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"https://stevebraveman.github.io/tags/其它/"}]},{"title":"-并查集- [洛谷 P1196][NOI2002]银河英雄传说","slug":"41","date":"2018-11-07T04:34:23.000Z","updated":"2019-08-08T10:55:05.030Z","comments":true,"path":"2018/11/07/41/","link":"","permalink":"https://stevebraveman.github.io/2018/11/07/41/","excerpt":"题目描述公元五八○一年，地球居民迁至金牛座α第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。","text":"题目描述公元五八○一年，地球居民迁至金牛座α第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。宇宙历七九九年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。 杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成$30000$列，每列依次编号为$1, 2, …, 30000$。之后，他把自己的战舰也依次编号为$1, 2, …, 30000$，让第ii号战舰处于第$i$列$(i = 1, 2, …, 30000)$，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为$M_{i,j}$，含义为第$i$号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第j号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。 然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。 在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：$C_{i,j}$。该指令意思是，询问电脑，杨威利的第$i$号战舰与第$j$号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。 作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。 最终的决战已经展开，银河的历史又翻过了一页…… 输入格式第一行有一个整数$T(1 \\le T \\le 500,000)$，表示总共有TT条指令。 以下有$T$行，每行有一条指令。指令有两种格式： $M_{i,j}$：$i和j$是两个整数$(1 \\le i,j \\le 30000)$，表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第$i$号战舰与第$j$号战舰不在同一列。 $C_{i,j}$：$i$和$j$是两个整数$(1 \\le i,j \\le 30000)$，表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。 输出格式依次对输入的每一条指令进行分析和处理： 如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息； 如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第$i$号战舰与第$j$号战舰之间布置的战舰数目。如果第$i$号战舰与第$j$号战舰当前不在同一列上，则输出$-1$。 输入样例4M 2 3C 1 2M 2 4C 4 2 输出样例-11 Solution这道题一眼就能看出来是道关于并查集的题目，但是该如何保存舰船的数量呢？这时候就可以开一个数组来保存，合并时相加，路径压缩时传递。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 30005int fa[MAXN] , n , u , v , size[MAXN] , d[MAXN] , p , q;char a;inline int abs(int x) &#123; if (x &lt; 0) x = -x; return x;&#125;int find(int x) &#123; if (x == fa[x]) return x; int r = find(fa[x]); d[x] += d[fa[x]]; return fa[x] = r;&#125;inline void un(int x , int y) &#123; x = find(x) , y = find(y); fa[x] = y , d[x] = size[y]; size[y] += size[x];&#125;void init() &#123; for (int i = 1 ; i &lt;= 30000 ; i++) &#123; fa[i] = i; size[i] = 1; &#125;&#125;int main() &#123; scanf(\"%d\" , &amp;n); init(); for (int i = 1 ; i &lt;= n ; i++) &#123; std::cin &gt;&gt; a; if (a == 'C') &#123; scanf(\"%d%d\" , &amp;u , &amp;v); p = find(u); q = find(v); if (p != q) &#123; printf(\"-1\\n\"); &#125; else printf(\"%d\\n\" , abs(d[u] - d[v]) - 1); &#125; else &#123; scanf(\"%d%d\" , &amp;u , &amp;v); un(u , v); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"并查集","slug":"并查集","permalink":"https://stevebraveman.github.io/tags/并查集/"}]},{"title":"-LCA-前缀和-差分-[BZOJ 1832][AHOI2008]聚会","slug":"40","date":"2018-10-26T04:08:09.000Z","updated":"2019-08-08T10:40:18.647Z","comments":true,"path":"2018/10/26/40/","link":"","permalink":"https://stevebraveman.github.io/2018/10/26/40/","excerpt":"题目描述Y岛风景美丽宜人，气候温和，物产丰富。Y岛上有N个城市，有N-1条城市间的道路连接着它们。每一条道路都连接某两个城市。幸运的是，小可可通过这些道路可以走遍Y岛的所有城市。神奇的是，乘车经过每条道路所需要的费用都是一样的。","text":"题目描述Y岛风景美丽宜人，气候温和，物产丰富。Y岛上有N个城市，有N-1条城市间的道路连接着它们。每一条道路都连接某两个城市。幸运的是，小可可通过这些道路可以走遍Y岛的所有城市。神奇的是，乘车经过每条道路所需要的费用都是一样的。小可可，小卡卡和小YY经常想聚会，每次聚会，他们都会选择一个城市，使得3个人到达这个城市的总费用最小。 由于他们计划中还会有很多次聚会，每次都选择一个地点是很烦人的事情，所以他们决定把这件事情交给你来完成。他们会提供给你地图以及若干次聚会前他们所处的位置，希望你为他们的每一次聚会选择一个合适的地点。 输入格式第一行两个正整数，N和M。分别表示城市个数和聚会次数。后面有N-1行，每行用两个正整数A和B表示编号为A和编号为B的城市之间有一条路。城市的编号是从1到N的。再后面有M行，每行用三个正整数表示一次聚会的情况：小可可所在的城市编号，小卡卡所在的城市编号以及小YY所在的城市编号。 输出格式一共有M行，每行两个数Pos和Cost，用一个空格隔开。表示第i次聚会的地点选择在编号为Pos的城市，总共的费用是经过Cost条道路所花费的费用。 样例输入6 41 22 32 44 55 64 5 66 3 12 4 46 6 6 样例输出5 22 54 16 0 说明100%的数据中，N&lt;=500000，M&lt;=500000。 40%的数据中N&lt;=2000，M&lt;=2000。 Solution一眼就能看出这肯定是个求LCA的问题，但是，这个题不是那么单纯地求LCA，因为一共有三个人，所以我们还要稍微运用一下前缀和/差分的知识 （依然坚持用倍增求LCA） Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define MAXN 1000010#define LOG 30int anc[MAXN &lt;&lt; 1][LOG];int val[MAXN &lt;&lt; 1] , dep[MAXN &lt;&lt; 1] , len , ecnt , x , y , z , u , v , s , p , n , m , head[MAXN] , h , l , fa[MAXN];int dis[MAXN];struct Edge &#123; int v , nx , w;&#125;e[MAXN];inline void add(int f , int t , int w) &#123; e[++ecnt] = (Edge)&#123;t , head[f] , w&#125;; head[f] = ecnt;&#125;void dfs(int u , int p , int d) &#123; anc[u][0] = p; dep[u] = d; for (int i = head[u] ; i ; i = e[i].nx) &#123; int to = e[i].v; if (to == p) continue; dis[to] = dis[u] + e[i].w; dfs(to , u , d + 1); &#125;&#125;inline void init(int r , int n) &#123; dis[r] = 0; dfs(r , 0 , 1); for (int j = 1 ; j &lt; LOG ; j++) &#123; for (int i = 1 ; i &lt;= n ; i++) &#123; anc[i][j] = anc[anc[i][j - 1]][j - 1]; &#125; &#125;&#125;inline int query(int x , int y) &#123; if (dep[x] &lt; dep[y]) std::swap(x , y); h = dep[x] - dep[y]; for (int i = 0 ; h &gt; 0 ; i++) &#123; if (h &amp; 1) x = anc[x][i]; h &gt;&gt;= 1; &#125; if (x == y) return x; for (int i = LOG - 1 ; i &gt;= 0 ; i--) &#123; if (anc[x][i] != anc[y][i]) &#123; x = anc[x][i]; y = anc[y][i]; &#125; &#125; return anc[x][0];&#125;int main() &#123; scanf(\"%d%d\" , &amp;n , &amp;m); for (int i = 1 ; i &lt; n ; i++) &#123; scanf(\"%d%d\" , &amp;u , &amp;v); add(u , v , 1); add(v , u , 1); fa[u]++; fa[v]++; &#125; for (int i = 1 ; i &lt;= n ; i++)&#123; if (fa[i] == 1) &#123; s = i; break; &#125; &#125; init(s , n); for (int i = 1 ; i &lt;= m ; i++) &#123; scanf(\"%d%d%d\" , &amp;x , &amp;y , &amp;z); int a1 = query(x , y); int a2 = query(x , z); int a3 = query(y , z); if (a1 == a2) &#123; l = a3; &#125; else if (a1 == a3) &#123; l = a2; &#125; else if (a2 == a3) &#123; l = a1; &#125; p = dep[x] + dep[y] + dep[z] - dep[a1] - dep[a2] - dep[a3]; printf(\"%d %d\\n\" , l , p); &#125;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://stevebraveman.github.io/tags/BZOJ/"},{"name":"前缀和","slug":"前缀和","permalink":"https://stevebraveman.github.io/tags/前缀和/"},{"name":"差分","slug":"差分","permalink":"https://stevebraveman.github.io/tags/差分/"},{"name":"LCA","slug":"LCA","permalink":"https://stevebraveman.github.io/tags/LCA/"}]},{"title":"-数论-欧拉定理- [BZOJ 3884]上帝与集合的正确用法","slug":"39","date":"2018-10-25T04:30:28.000Z","updated":"2019-08-08T10:39:58.089Z","comments":true,"path":"2018/10/25/39/","link":"","permalink":"https://stevebraveman.github.io/2018/10/25/39/","excerpt":"题目描述根据一些书上的记载，上帝的一次失败的创世经历是这样的：第一天，上帝创造了一个世界的基本元素，称做“元”。第二天，上帝创造了一个新的元素，称作“α”。“α”被定义为“元”构成的集合。容易发现，一共有两种不同的“α”。","text":"题目描述根据一些书上的记载，上帝的一次失败的创世经历是这样的：第一天，上帝创造了一个世界的基本元素，称做“元”。第二天，上帝创造了一个新的元素，称作“α”。“α”被定义为“元”构成的集合。容易发现，一共有两种不同的“α”。第三天，上帝又创造了一个新的元素，称作“β”。“β”被定义为“α”构成的集合。容易发现，一共有四种不同的“β”。第四天，上帝创造了新的元素“γ”，“γ”被定义为“β”的集合。显然，一共会有16种不同的“γ”。如果按照这样下去，上帝创造的第四种元素将会有65536种，第五种元素将会有2^65536种。这将会是一个天文数字。然而，上帝并没有预料到元素种类数的增长是如此的迅速。他想要让世界的元素丰富起来，因此，日复一日，年复一年，他重复地创造着新的元素……然而不久，当上帝创造出最后一种元素“θ”时，他发现这世界的元素实在是太多了，以致于世界的容量不足，无法承受。因此在这一天，上帝毁灭了世界。至今，上帝仍记得那次失败的创世经历，现在他想问问你，他最后一次创造的元素“θ”一共有多少种？上帝觉得这个数字可能过于巨大而无法表示出来，因此你只需要回答这个数对p取模后的值即可。你可以认为上帝从“α”到“θ”一共创造了10^9次元素，或10^18次，或者干脆∞次。一句话题意：求2^{2^{2^{^{...}}}} \\mod p 输入格式接下来T行，每行一个正整数p，代表你需要取模的值 输出格式T行，每行一个正整数，为答案对p取模后的值 样例输入3236 样例输出014 提示对于100%的数据，T&lt;=1000,p&lt;=10^7 SolutionBZOJ的UI真的很令人不舒服 这道题主要就是关于这个公式： a^b \\equiv a^{b \\mod \\varphi(p) + \\varphi(p)} \\pmod p所以用一下快速幂然后在写一个函数递归求解就可以了 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAXN 10000000#define ll long longll p[MAXN] , tot , phi[MAXN] , t , pl;bool chk[MAXN];void euler() &#123; phi[1] = 1; for (ll i = 2 ; i &lt;= MAXN ; i++) &#123; if (!chk[i]) &#123; p[++tot] = i; phi[i] = i - 1; &#125; for (ll j = 1; j &lt;= tot ; j++) &#123; if (i * p[j] &gt; MAXN) break; chk[i * p[j]] = 1; if (i % p[j] == 0) &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; else phi[i * p[j]] = phi[i] * (p[j] - 1); &#125; &#125;&#125;ll qpow(ll a , ll b , ll m) &#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = (ans * a) % m; b &gt;&gt;= 1; a = (a * a) % m; &#125; return ans;&#125;ll sol(ll p) &#123; if (p == 1) return 0; else return qpow(2 , sol(phi[p]) + phi[p] , p);&#125;int main() &#123; euler(); scanf(\"%lld\" , &amp;t); while (t--) &#123; scanf(\"%lld\" , &amp;pl); printf(\"%lld\\n\" , sol(pl)); &#125;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"},{"name":"欧拉定理","slug":"欧拉定理","permalink":"https://stevebraveman.github.io/tags/欧拉定理/"}]},{"title":"-数论- [BZOJ 1041][HAOI2008]圆上的整点","slug":"38","date":"2018-10-25T04:20:23.000Z","updated":"2019-08-08T10:39:43.128Z","comments":true,"path":"2018/10/25/38/","link":"","permalink":"https://stevebraveman.github.io/2018/10/25/38/","excerpt":"题目描述求一个给定的圆(x^2+y^2=r^2)，在圆周上有多少个点的坐标是整数。","text":"题目描述求一个给定的圆(x^2+y^2=r^2)，在圆周上有多少个点的坐标是整数。 输入格式只有一个正整数n,n&lt;=2000 000 000 输出格式整点个数 样例输入4 样例输出4 Solution主要就是这个视频：https://www.bilibili.com/video/av12131743/ 视频里原理已经讲得hin明白，时间复杂度：O(分解质因数)。 如果不看这个视频估计谁也想不到圆竟然和质因数有关系 Code12345678910111213141516171819202122232425262728293031#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define ll long long#define MAXN 50000ll n , k , p , tot = 0 , ans = 1;bool gauss(ll a) &#123; if (a % 4 != 3) return 1; return 0;&#125;int main() &#123; scanf(\"%lld\" , &amp;n); while (!(n &amp; 1)) n &gt;&gt;= 1; for (ll i = 2; i &lt;= sqrt(n) ; i++) &#123; p = 0; while (n % i == 0) &#123; if (gauss(i)) p += 2; n /= i; &#125; ans *= (p + 1); &#125; if (n != 1) &#123; if (gauss(n)) &#123; ans *= 3; &#125; &#125; printf(\"%d\" , ans * 4); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://stevebraveman.github.io/tags/BZOJ/"},{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"}]},{"title":"-DP-前缀和- [BZOJ 1218][HNOI2003]激光炸弹","slug":"37","date":"2018-10-16T08:24:57.000Z","updated":"2019-08-08T10:39:30.574Z","comments":true,"path":"2018/10/16/37/","link":"","permalink":"https://stevebraveman.github.io/2018/10/16/37/","excerpt":"题目描述一种新型的激光炸弹，可以摧毁一个边长为R的正方形内的所有的目标。现在地图上有n(N&lt;=10000)个目标，用整数Xi,Yi(其值在[0,5000])表示目标在地图上的位置，每个目标都有一个价值。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为R的正方形的边必须和x，y轴平行。若目标位于爆破正方形的边上，该目标将不会被摧毁。","text":"题目描述一种新型的激光炸弹，可以摧毁一个边长为R的正方形内的所有的目标。现在地图上有n(N&lt;=10000)个目标，用整数Xi,Yi(其值在[0,5000])表示目标在地图上的位置，每个目标都有一个价值。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为R的正方形的边必须和x，y轴平行。若目标位于爆破正方形的边上，该目标将不会被摧毁。 输入格式输入文件的第一行为正整数n和正整数R，接下来的n行每行有3个正整数，分别表示xi,yi,vi 输出格式输出文件仅有一个正整数，表示一颗炸弹最多能炸掉地图上总价值为多少的目标（结果不会超过32767）。 输入样例2 10 0 11 1 1 输出样例1 Solution首先这道题用前缀和预处理一下，然后再用$O(n^2)$的DP来解决。 Code123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define re registerint n , p , q , k , f[5005][5005] = &#123;0&#125;, ans = 0;inline int max(int a , int b) &#123; if (a &gt; b) return a; else return b;&#125;int main() &#123; scanf(\"%d%d\" , &amp;n , &amp;k); p = q = k; for (re int i = 1 ; i &lt;= n ; i++) &#123; int x , y , z; scanf(\"%d%d%d\" , &amp;x , &amp;y , &amp;z); x++; y++; p = max(x , p); q = max(y , q); f[x][y] = z; &#125; for (re int i = 1 ; i &lt;= p ; i++) &#123; for (re int j = 1 ; j &lt;= q ; j++) &#123; f[i][j] = f[i][j] + f[i][j - 1] + f[i - 1][j] - f[i - 1][j - 1]; &#125; &#125; for (re int i = k ; i &lt;= p ; i++) &#123; for (re int j = k ; j &lt;= q ; j++) &#123; ans = max(ans , f[i][j] + f[i - k][j - k] - f[i - k][j] - f[i][j - k]); &#125; &#125; printf(\"%d\" , ans);&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://stevebraveman.github.io/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"https://stevebraveman.github.io/tags/DP/"},{"name":"前缀和","slug":"前缀和","permalink":"https://stevebraveman.github.io/tags/前缀和/"}]},{"title":"-矩阵运算-递推- [洛谷 P1349]广义斐波那契数列","slug":"36","date":"2018-10-08T12:41:43.000Z","updated":"2019-08-08T10:39:17.434Z","comments":true,"path":"2018/10/08/36/","link":"","permalink":"https://stevebraveman.github.io/2018/10/08/36/","excerpt":"题目描述广义的斐波那契数列是指形如 $an=p \\times a{n-1} + q \\times a_{n-2}$ 的数列。今给定数列的两系数 $p$ 和 $q$ ，以及数列的最前两项 $a_1$ 和 $a_2$ ，另给出两个整数 $n$ 和 $m$ ，试求数列的第 $n$ 项除以 $m$ 的余数。","text":"题目描述广义的斐波那契数列是指形如 $an=p \\times a{n-1} + q \\times a_{n-2}$ 的数列。今给定数列的两系数 $p$ 和 $q$ ，以及数列的最前两项 $a_1$ 和 $a_2$ ，另给出两个整数 $n$ 和 $m$ ，试求数列的第 $n$ 项除以 $m$ 的余数。 输入格式输入包含一行6个整数。依次是 $p,q,a_1,a_2$ ，其中在 $p,q,a_1,a_2$ 整数范围内， $n$ 和 $m$ 在长整数范围内。 输出格式输出包含一行一个整数，即$a_n$除以$m$的余数。 输入样例1 1 1 1 10 7 输出样例6 说明数列第10项是55，除以7的余数为6。 Solution最近刚学了矩阵快速幂，便想找几道题练练手。 这道题其实就是斐波那契的变种（好像是句废话），所以我们只需要将那个式子改一改就可以了。 而且我个人比较喜欢重载运算符。 注意：千万不要把 $p$ 和 $q$ 写反！ 还有，要开long long。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define ll long longll n , m , p , q , a_1 , a_2;struct Mat&#123; ll a[2][2]; void clear() &#123; memset(a , 0 , sizeof(a)); &#125; void init() &#123; memset(a , 0 , sizeof(a)); for (int i = 0 ; i &lt;= 1 ; i++) &#123; a[i][i] = 1; &#125; &#125;&#125;;ll mula(ll x , ll y) &#123; x += y; if (x &gt;= m) x -= m; return x;&#125;ll mult(ll x , ll y) &#123; ll p = 0; while (y) &#123; if (y &amp; 1) p = (p + x) % m; x = (x + x) % m; y &gt;&gt;= 1; &#125; return p;&#125;Mat operator * (Mat a , Mat b) &#123; Mat c; c.clear(); for (int i = 0 ; i &lt; 2 ; i++) &#123; for (int j = 0 ; j &lt; 2 ; j++) &#123; for (int k = 0 ; k &lt; 2 ; k++) &#123; c.a[i][j] = mula(c.a[i][j] %m , mult(a.a[i][k] , b.a[k][j]) % m) % m; &#125; &#125; &#125; return c;&#125;Mat qpow(Mat a , ll n) &#123; Mat b; b.init(); while (n) &#123; if (n &amp; 1) b = b * a; n &gt;&gt;= 1; a = a * a; &#125; return b;&#125;int main() &#123; scanf(\"%lld%lld%lld%lld%lld%lld\" , &amp;q , &amp;p , &amp;a_1 , &amp;a_2 , &amp;n , &amp;m); Mat f , a , w; f.clear(); a.clear(); w.clear(); f.a[0][0] = a_1; f.a[0][1] = a_2; a.a[0][0] = 0; a.a[1][0] = 1; a.a[0][1] = p; a.a[1][1] = q; w = f * qpow(a , n - 2); std::cout &lt;&lt; w.a[0][1] % m;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"递推","slug":"递推","permalink":"https://stevebraveman.github.io/tags/递推/"},{"name":"矩阵运算","slug":"矩阵运算","permalink":"https://stevebraveman.github.io/tags/矩阵运算/"}]},{"title":"-期望-递推- [洛谷 P1291][SHOI2002]百事世界杯之旅","slug":"35","date":"2018-10-07T12:06:19.000Z","updated":"2019-08-08T10:39:05.594Z","comments":true,"path":"2018/10/07/35/","link":"","permalink":"https://stevebraveman.github.io/2018/10/07/35/","excerpt":"题目描述“……在2002年6月之前购买的百事任何饮料的瓶盖上都会有一个百事球星的名字。只要凑齐所有百事球星的名字，就可参加百事世界杯之旅的抽奖活动，获得球星背包，随声听，更克赴日韩观看世界杯。还不赶快行动！”","text":"题目描述“……在2002年6月之前购买的百事任何饮料的瓶盖上都会有一个百事球星的名字。只要凑齐所有百事球星的名字，就可参加百事世界杯之旅的抽奖活动，获得球星背包，随声听，更克赴日韩观看世界杯。还不赶快行动！”你关上电视，心想：假设有n个不同的球星名字，每个名字出现的概率相同，平均需要买几瓶饮料才能凑齐所有的名字呢？ 输入格式整数n（2≤n≤33），表示不同球星名字的个数。 输出格式输出凑齐所有的名字平均需要买的饮料瓶数。如果是一个整数，则直接输出，否则应该直接按照分数格式输出，例如五又二十分之三应该输出为（复制到记事本）： $5 \\frac{3}{20}$ 第一行是分数部分的分子，第二行首先是整数部分，然后是由减号组成的分数线，第三行是分母。减号的个数应等于分母的为数。分子和分母的首位都与第一个减号对齐。 分数必须是不可约的。 输入样例2 输出样例3 Solution首先，我们可以用 $f[n][k]$ 来表示一共有 $n$ 个球星还剩下 $k$ 个球星没有收集到，依此我们可以推出一个方程： f[n][k]=\\frac{(n-k) \\times f[n][k]}{n}+\\frac{k \\times f[n][k-1]}{n}+1然后经过一些变换： f[n][k]=f[n][k]+\\frac{n}{k}但这样计算太麻烦了，所以又经过一系列玄学操作，就变成了： n\\sum^n_{k=1}\\frac{1}{k}（虽然还是很难计算）以上，就是对本题的推导。最后，我还要说一句： \\text{我从未见过有如此毒瘤的输出！}光是是输出就调了好长时间。如果是输出小数的话我早就A了 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#define ll long long ll gcd(ll a , ll b) &#123; if (b == 0) return a; else return gcd(b , a % b);&#125;ll lcm(ll a , ll b) &#123; return a * b / gcd(a , b);&#125;ll n , ans , ws1 = 0 , ws2 = 0 , fm = 1 , fz = 0 , yfz = 1 , d = 0 , k , r;int main() &#123; scanf(\"%lld\" , &amp;n); for (ll i = 1 ; i &lt;= n ; i++) &#123; fz = fz * i + fm * n; fm *= i; r = gcd(fm , fz); fm /= r; fz /= r; &#125; r = fz / fm; if (fm == 1) &#123; printf(\"%lld\" , fz); &#125; else &#123; ll y = r; while (y != 0) &#123; y /= 10; ws1++; &#125; ll fmn = fm; while (fmn != 0) &#123; fmn /= 10; ws2++; &#125; for (ll i = 1 ; i &lt;= ws1 ; i++) &#123; printf(\" \"); &#125; printf(\"%lld\" , fz % fm); puts(\"\"); printf(\"%lld\" , r); for (ll i = 1 ; i &lt;= ws2 ; i++) &#123; printf(\"-\"); &#125; puts(\"\"); for (ll i = 1 ; i &lt;= ws1 ; i++) &#123; printf(\" \"); &#125; printf(\"%lld\" , fm); &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"递推","slug":"递推","permalink":"https://stevebraveman.github.io/tags/递推/"},{"name":"期望","slug":"期望","permalink":"https://stevebraveman.github.io/tags/期望/"}]},{"title":"-RMQ-ST表- [洛谷 P1198][JSOI2008]最大数","slug":"34","date":"2018-10-05T06:28:08.000Z","updated":"2019-08-08T10:38:47.851Z","comments":true,"path":"2018/10/05/34/","link":"","permalink":"https://stevebraveman.github.io/2018/10/05/34/","excerpt":"题目描述 现在请求你维护一个数列，要求提供以下两种操作：1、 查询操作。语法：Q L 功能：查询当前数列中末尾L个数中的最大的数，并输出这个数的值。限制：L不超过当前数列的长度。2、 插入操作。语法：A n 功能：将n加上t，其中t是最近一次查询操作的答案（如果还未执行过查询操作，则t=0)，并将所得结果对一个固定的常数D取模，将所得答案插入到数列的末尾。限制：n是非负整数并且在长整范围内。注意：初始时数列是空的，没有一个数。","text":"题目描述 现在请求你维护一个数列，要求提供以下两种操作：1、 查询操作。语法：Q L 功能：查询当前数列中末尾L个数中的最大的数，并输出这个数的值。限制：L不超过当前数列的长度。2、 插入操作。语法：A n 功能：将n加上t，其中t是最近一次查询操作的答案（如果还未执行过查询操作，则t=0)，并将所得结果对一个固定的常数D取模，将所得答案插入到数列的末尾。限制：n是非负整数并且在长整范围内。注意：初始时数列是空的，没有一个数。 输入格式 第一行两个整数，M和D，其中M表示操作的个数(M &lt;= 200,000)，D如上文中所述，满足D在longint内。接下来M行，查询操作或者插入操作。 输出格式 对于每一个询问操作，输出一行。该行只有一个数，即序列中最后L个数的最大数。 样例输入5 100A 96Q 1A 97Q 1Q 2 样例输出969396 Solution这道题其实是可以用ST表过去的，因为每次更新的数都在最后面，所以就可以根据ST表的原理来做。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int D , m , n , d[200002] = &#123;0&#125; , dp[200002][30] , t = 0;int max(int a , int b) &#123;if (a &gt; b) return a;else return b;&#125;void ch(int x) &#123; dp[x][0] = d[x]; for(int i = 1 ; x - (1 &lt;&lt; i) &gt;= 0 ; i++) dp[x][i] = max(dp[x][i - 1] , dp[x - (1 &lt;&lt; (i - 1))][i - 1]);&#125;int find(int ll , int rr) &#123; double u = log(rr - ll + 1) / log(2); int k = u; int maxi = max(dp[rr][k] , dp[ll + (1 &lt;&lt; k) - 1][k]); return maxi;&#125;int main() &#123; memset(dp , 0 , sizeof(dp)); memset(d , 0 , sizeof(d)); scanf(\"%d%d\" , &amp; m , &amp; D); while(m--) &#123; int b = 0; int f = 0; char p; cin &gt;&gt; p; if (p == 'A') &#123; scanf(\"%d\" , &amp; b); n++; d[n] = (b + t) % D; ch(n); &#125; else &#123; scanf(\"%d\" , &amp; f); if (f == 1) &#123; printf(\"%d\" , d[n]); t = d[n]; &#125; else &#123; t = find(n - f + 1 , n); printf(\"%d\" , t); &#125; puts(\"\"); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"RMQ","slug":"RMQ","permalink":"https://stevebraveman.github.io/tags/RMQ/"},{"name":"ST表","slug":"ST表","permalink":"https://stevebraveman.github.io/tags/ST表/"}]},{"title":"-RMQ-ST表- [洛谷 P2880][USACO07JAN]平衡的阵容Balanced Lineup","slug":"33","date":"2018-10-05T05:28:09.000Z","updated":"2019-08-08T10:38:19.064Z","comments":true,"path":"2018/10/05/33/","link":"","permalink":"https://stevebraveman.github.io/2018/10/05/33/","excerpt":"题目描述每天,农夫 John 的N(1 &lt;= N &lt;= 50,000)头牛总是按同一序列排队. 有一天, John 决定让一些牛们玩一场飞盘比赛. 他准备找一群在对列中为置连续的牛来进行比赛. 但是为了避免水平悬殊,牛的身高不应该相差太大. John 准备了Q (1 &lt;= Q &lt;= 180,000) 个可能的牛的选择和所有牛的身高 (1 &lt;= 身高 &lt;= 1,000,000). 他想知道每一组里面最高和最低的牛的身高差别.","text":"题目描述每天,农夫 John 的N(1 &lt;= N &lt;= 50,000)头牛总是按同一序列排队. 有一天, John 决定让一些牛们玩一场飞盘比赛. 他准备找一群在对列中为置连续的牛来进行比赛. 但是为了避免水平悬殊,牛的身高不应该相差太大. John 准备了Q (1 &lt;= Q &lt;= 180,000) 个可能的牛的选择和所有牛的身高 (1 &lt;= 身高 &lt;= 1,000,000). 他想知道每一组里面最高和最低的牛的身高差别. 输入格式第1行：N,Q 第2到N+1行：每头牛的身高 第N+2到N+Q+1行：两个整数A和B，表示从A到B的所有牛。（1&lt;=A&lt;=B&lt;=N） 输出格式输出每行一个数，为最大数与最小数的差 输入样例6 31734251 54 62 2 输出样例630 Solution这道题完全用ST表来解决就行了（反正也没有区间修改，况且我也懒得打线段树）。 Code1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;int n,m;int d[180002];int dp1[180002][55];int dp2[180002][55];int main() &#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) &#123; scanf(\"%d\",&amp;d[i]); &#125; for(int i=1; i&lt;=n; i++) &#123; dp1[i][0]=d[i]; dp2[i][0]=d[i]; &#125; for(int j=1; (1&lt;&lt;j)&lt;=n; j++) &#123; for(int i=1; i+(1&lt;&lt;j)-1&lt;=n; i++) &#123; dp1[i][j]=max(dp1[i][j-1],dp1[i+(1&lt;&lt;j-1)][j-1]); dp2[i][j]=min(dp2[i][j-1],dp2[i+(1&lt;&lt;j-1)][j-1]); &#125; &#125; while(m--) &#123; int ll,rr; scanf(\"%d%d\",&amp;ll,&amp;rr); int k=0; while((1&lt;&lt;k+1)&lt;=rr-ll+1)k++; int maxi=max(dp1[ll][k],dp1[rr-(1&lt;&lt;k)+1][k]); int mini=min(dp2[ll][k],dp2[rr-(1&lt;&lt;k)+1][k]); printf(\"%d\",maxi-mini); printf(\"\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"RMQ","slug":"RMQ","permalink":"https://stevebraveman.github.io/tags/RMQ/"},{"name":"ST表","slug":"ST表","permalink":"https://stevebraveman.github.io/tags/ST表/"}]},{"title":"-DP-[BZOJ 1057][ZJOI2007]棋盘制作","slug":"32","date":"2018-09-29T22:43:04.000Z","updated":"2019-08-08T10:37:34.496Z","comments":true,"path":"2018/09/30/32/","link":"","permalink":"https://stevebraveman.github.io/2018/09/30/32/","excerpt":"题目描述 国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个 $8 * 8$ 大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。而我们的主人公小Q，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友小W决定将棋盘扩大以适应他们的新规则。小Q找到了一张由 $N * M$ 个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。","text":"题目描述 国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个 $8 * 8$ 大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。而我们的主人公小Q，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友小W决定将棋盘扩大以适应他们的新规则。小Q找到了一张由 $N * M$ 个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。小Q想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。不过小Q还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。于是小Q找到了即将参加全国信息学竞赛的你，你能帮助他么？ 输入格式 第一行包含两个整数N和M，分别表示矩形纸片的长和宽。接下来的N行包含一个N * M的01矩阵，表示这张矩形纸片的颜色（0表示白色，1表示黑色）。 输出格式 包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积（注意正方形和矩形是可以相交或者包含的）。 样例输入3 31 0 10 1 01 0 0 样例输出46 说明N, M ≤ 2000 Solution这道题求正方形很好求，状态转移方程f[i][j]=min{f[i][j-1],f[i-1][j-1],f[i-1][j]}；但长方形很难求，我本知道要用悬线法，但我仍然硬推方程，最后推了一个小时没推出来，被逼用悬线法。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define MAXN 2002using namespace std;int max(int a,int b) &#123; if(a&gt;b) return a; else return b;&#125;int min(int a,int b) &#123; if(a&lt;b) return a; else return b;&#125;int a[MAXN][MAXN],f[MAXN][MAXN],l[MAXN][MAXN],r[MAXN][MAXN],L[MAXN][MAXN],R[MAXN][MAXN],h[MAXN][MAXN],n,m,ans=0,ansj=0,tmp;int solve() &#123; memset(f,0,sizeof(f)); memset(l,0,sizeof(f)); memset(r,0,sizeof(f)); memset(L,0,sizeof(f)); memset(R,0,sizeof(f)); memset(h,0,sizeof(f)); for (int i=1; i&lt;=n; i++) &#123; tmp=0; for (int j=1; j&lt;=m; j++)&#123; if (a[i][j])&#123; l[i][j]=tmp; &#125; else &#123; tmp=j; L[i][j]=0; &#125; &#125; tmp=m+1; for (int j=m; j&gt;=1; j--)&#123; if (a[i][j]) &#123; r[i][j]=tmp; &#125; else &#123; tmp=j; R[i][j]=m+1; &#125; &#125; &#125; for (int i=1; i&lt;=m; i++) &#123; R[0][i]=m+1; &#125; for (int i=1; i&lt;=n; i++) &#123; for (int j=1; j&lt;=m; j++) &#123; if (a[i][j]) &#123; h[i][j]=h[i-1][j]+1; L[i][j]=max(L[i-1][j],l[i][j]); R[i][j]=min(R[i-1][j],r[i][j]); ansj=max(ansj,h[i][j]*(R[i][j]-L[i][j]-1)); &#125; &#125; &#125;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; scanf(\"%d\",&amp;a[i][j]); f[i][j]=1; if(i&gt;=2&amp;&amp;j&gt;=2) &#123; if(((a[i][j-1]^a[i][j])==1)&amp;&amp;(a[i-1][j-1]==a[i][j])&amp;&amp;(a[i-1][j]==a[i][j-1])) &#123; f[i][j]=min(f[i-1][j],min(f[i][j-1],f[i-1][j-1]))+1; ans=max(ans,f[i][j]*f[i][j]); &#125; &#125; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; if((i&amp;1)==(j&amp;1)) &#123; a[i][j]^=1; &#125; &#125; &#125; solve(); for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=m; j++) &#123; a[i][j]^=1; &#125; &#125; solve(); printf(\"%d\\n%d\",ans,ansj); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://stevebraveman.github.io/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"https://stevebraveman.github.io/tags/DP/"}]},{"title":"-图论-最短路- [洛谷 P3003][USACO10DEC]苹果交货Apple Delivery","slug":"31","date":"2018-09-28T01:52:53.000Z","updated":"2019-08-08T10:35:56.949Z","comments":true,"path":"2018/09/28/31/","link":"","permalink":"https://stevebraveman.github.io/2018/09/28/31/","excerpt":"题目描述贝西有两个又香又脆的红苹果要送给她的两个朋友。当然她可以走的C（1&lt;=C&lt;=200000）条“牛路”都被包含在一种常用的图中，包含了P（1&lt;=P&lt;=100000）个牧场，分别被标为1..P。没有“牛路”会从一个牧场又走回它自己。“牛路”是双向的，每条牛路都会被标上一个距离。最重要的是，每个牧场都可以通向另一个牧场。每条牛路都连接着两个不同的牧场P1_i和P2_i（1&lt;=P1_i,p2_i&lt;=P)，距离为D_i。所有“牛路”的距离之和不大于2000000000。","text":"题目描述贝西有两个又香又脆的红苹果要送给她的两个朋友。当然她可以走的C（1&lt;=C&lt;=200000）条“牛路”都被包含在一种常用的图中，包含了P（1&lt;=P&lt;=100000）个牧场，分别被标为1..P。没有“牛路”会从一个牧场又走回它自己。“牛路”是双向的，每条牛路都会被标上一个距离。最重要的是，每个牧场都可以通向另一个牧场。每条牛路都连接着两个不同的牧场P1_i和P2_i（1&lt;=P1_i,p2_i&lt;=P)，距离为D_i。所有“牛路”的距离之和不大于2000000000。现在，贝西要从牧场PB开始给PA_1和PA_2牧场各送一个苹果（PA_1和PA_2顺序可以调换），那么最短的距离是多少呢？当然，PB、PA_1和PA_2各不相同。 输入格式Line 1: Line 1 contains five space-separated integers: C, P, PB, PA1, and PA2 Lines 2..C+1: Line i+1 describes cowpath i by naming two pastures it connects and the distance between them: P1_i, P2_i, D_i 输出格式Line 1: The shortest distance Bessie must travel to deliver both apples 输入样例9 7 5 1 45 1 76 7 24 7 25 6 15 2 44 3 21 2 33 2 22 6 3 输出样例12 Solution这道题可用最短路解决，要么从1跑到p1再跑到p2，要么从1跑到p2再跑到p1，所以我们可以跑两遍dijkstra解决。 因为SPFA在今年的NOI那啥了，所以只要没有负边权我就坚持不用SPFA。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define SIZE 1000100using namespace std;int head[SIZE],n,m,s,ecnt,dis[SIZE];bool vis[SIZE];int min(int a,int b)&#123; return a&lt;b?a:b;&#125;struct node &#123; int id,w;&#125;;struct edge &#123; int v,nxt,dist;&#125; e[4*SIZE];bool operator &lt;(node a,node b) &#123; return (a.w&gt;b.w);&#125;void add_edge(int from,int to,int dis) &#123; e[++ecnt]=(edge) &#123; to,head[from],dis &#125;; head[from]=ecnt;&#125;void dijkstra(int u) &#123; memset(dis,0x7f,sizeof(dis)); memset(vis,0,sizeof(vis)); priority_queue&lt;node&gt;q; dis[u]=0; q.push((node) &#123;u,0&#125;); while(!q.empty()) &#123; node flag=q.top(); q.pop(); int v=flag.id; if(vis[v]) continue; vis[v]=1; for(int i=head[v]; i; i=e[i].nxt) &#123; int to=e[i].v; if(dis[to]&gt;dis[v]+e[i].dist) &#123; dis[to]=dis[v]+e[i].dist; q.push((node)&#123;to,dis[to]&#125;); &#125; &#125; &#125;&#125;int main() &#123; int p1,p2; scanf(\"%d%d%d%d%d\",&amp;m,&amp;n,&amp;s,&amp;p1,&amp;p2); int x,y,z; for(int i=1; i&lt;=m; i++) &#123; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); add_edge(x,y,z); add_edge(y,x,z); &#125; dijkstra(p1); int ans1=dis[s]+dis[p2]; dijkstra(p2); int ans2=dis[s]+dis[p1]; printf(\"%d\",min(ans2,ans1)); return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"图论","slug":"图论","permalink":"https://stevebraveman.github.io/tags/图论/"},{"name":"最短路","slug":"最短路","permalink":"https://stevebraveman.github.io/tags/最短路/"}]},{"title":"-贪心-[洛谷 P2114][NOI2014]起床困难综合症","slug":"30","date":"2018-09-12T12:12:36.000Z","updated":"2019-08-08T10:35:44.520Z","comments":true,"path":"2018/09/12/30/","link":"","permalink":"https://stevebraveman.github.io/2018/09/12/30/","excerpt":"题目描述21世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因： 在深邃的太平洋海底中，出现了一条名为drd的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。 正是由于drd的活动，起床困难综合症愈演愈烈， 以惊人的速度在世界上传播。为了彻底消灭这种病，atm决定前往海底，消灭这条恶龙。历经千辛万苦，atm终于来到了drd所在的地方，准备与其展开艰苦卓绝的战斗。drd有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd的防御战线由n扇防御门组成。每扇防御门包括一个运算op和一个参数t，其中运算一定是OR,XOR,AND中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为x，则其通过这扇防御门后攻击力将变为x op t。最终drd受到的伤害为对方初始攻击力x依次经过所有n扇防御门后转变得到的攻击力。","text":"题目描述21世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因： 在深邃的太平洋海底中，出现了一条名为drd的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。 正是由于drd的活动，起床困难综合症愈演愈烈， 以惊人的速度在世界上传播。为了彻底消灭这种病，atm决定前往海底，消灭这条恶龙。历经千辛万苦，atm终于来到了drd所在的地方，准备与其展开艰苦卓绝的战斗。drd有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd的防御战线由n扇防御门组成。每扇防御门包括一个运算op和一个参数t，其中运算一定是OR,XOR,AND中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为x，则其通过这扇防御门后攻击力将变为x op t。最终drd受到的伤害为对方初始攻击力x依次经过所有n扇防御门后转变得到的攻击力。由于atm水平有限，他的初始攻击力只能为0到m之间的一个整数（即他的初始攻击力只能在 0, 1, … , m中任选，但在通过防御门之后的攻击力不受m的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让drd受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使drd受到多少伤害。 输入格式输入文件的第 1 行包含 2 个整数，依次为n, m，表示 drd 有n扇防御门，atm 的初始攻击力为0到m之间的整数。 接下来n行，依次表示每一扇防御门。每行包括一个字符串op和一个非负整数t，两者由一个空格隔开，且op在前，t在后，op表示该防御门所对应的操作，t表示对应的参数。 输出格式输出一行一个整数，表示atm的一次攻击最多使drd受到多少伤害。 输入样例3 10AND 5OR 6XOR 7 输出样例1 说明atm可以选择的初始攻击力为 0,1, … ,10。 假设初始攻击力为 4，最终攻击力经过了如下计算 4 AND 5 = 4 4 OR 6 = 6 6 XOR 7 = 1 类似的，我们可以计算出初始攻击力为 1,3,5,7,9 时最终攻击力为 0，初始攻击力为 0,2,4,6,8,10 时最终攻击力为 1，因此atm的一次攻击最多使drd受到的伤害值为1。 Solution这道题可用贪心做，用两个数分别赋最大值和最小值，每个二进制位能变为1就变为1，然后再判断是否在 0~m 以内就可以了。 Code1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;bitset&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#define re registerusing namespace std;int MAXN=/*0x7fffffff*/-1,MINN=0,n,m;int main() &#123; scanf(\"%d%d\",&amp;n,&amp;m); for(re int i=1; i&lt;=n; i++) &#123; char ch[5]; int x; cin&gt;&gt;ch;cin&gt;&gt;x; if(ch[0]=='A') &#123;MAXN=MAXN&amp;x;MINN=MINN&amp;x;&#125; if(ch[0]=='O') &#123;MAXN=MAXN|x;MINN=MINN|x;&#125; if(ch[0]=='X') &#123;MAXN=MAXN^x;MINN=MINN^x;&#125; &#125; int y=log2(m); bitset&lt;30&gt; bs1(MAXN),bs2(MINN); int ans=0; int b=0; for(re int i=0; i&lt;30; i++) &#123; int k=1&lt;&lt;i; if((bs1[i]==1&amp;&amp;k&lt;=m)||bs2[i]==1)&#123; ans+=k; &#125; &#125; cout&lt;&lt;ans;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"贪心","slug":"贪心","permalink":"https://stevebraveman.github.io/tags/贪心/"}]},{"title":"-单调队列- [洛谷 P1886]滑动窗口","slug":"29","date":"2018-08-30T04:46:26.000Z","updated":"2019-08-08T10:35:31.092Z","comments":true,"path":"2018/08/30/29/","link":"","permalink":"https://stevebraveman.github.io/2018/08/30/29/","excerpt":"题目描述现在有一堆数字共N个数字（N&lt;=10^6），以及一个大小为k的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。","text":"题目描述现在有一堆数字共N个数字（N&lt;=10^6），以及一个大小为k的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。例如： The array is [1 3 -1 -3 5 3 6 7], and k = 3. Window position Minimum value Maximum value [1 3 -1] -3 5 3 6 7 -1 3 1 [3 -1 -3] 5 3 6 7 -3 3 1 3 [-1 -3 5] 3 6 7 -3 5 1 3 -1 [-3 5 3] 6 7 -3 5 1 3 -1 -3 [5 3 6] 7 3 6 1 3 -1 -3 5 [3 6 7] 3 7 输入格式输入一共有两行，第一行为n,k。 第二行为n个数(&lt;INT_MAX)。 输出格式输出共两行，第一行为每次窗口滑动的最小值 第二行为每次窗口滑动的最大值 输入样例8 31 3 -1 -3 5 3 6 7 输出样例-1 -3 -3 -3 3 33 3 5 5 6 7 说明50%的数据，n&lt;=10^5 100%的数据，n&lt;=10^6 Solution这道RMQ题可用单调队列做，如果用树状数组和线段树会被卡掉，所以单调队列是这道题的不二选择。 基本上单调队列模板连变都不用变，但是我特判了一个点。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int a[1000001],q[1000001],p[1000001];void init()&#123; memset(p,0,sizeof(p)); memset(q,0,sizeof(q));&#125;void maxq(int g[],int len,int le) &#123; init(); int h=1,t=0,l=0; for (int i=1; i&lt;=len; i++) &#123; while (i-p[h]&gt;=le&amp;&amp;(h&lt;t)) h++; while (t&gt;=h&amp;&amp;t&gt;0&amp;&amp;t&gt;=l&amp;&amp;q[t]&lt;a[i]) t--; t++; q[t]=a[i]; p[t]=i; if (i&gt;=le) cout&lt;&lt;q[h]&lt;&lt;' '; &#125;&#125;void minq(int g[],int len,int le) &#123; int h=1,t=0,l=0; init(); for (int i=1; i&lt;=len; i++) &#123; while (i-p[h]&gt;=le&amp;&amp;(h&lt;t)) h++; while (t&gt;=h&amp;&amp;t&gt;0&amp;&amp;t&gt;=l&amp;&amp;q[t]&gt;a[i]) t--; t++; q[t]=a[i]; p[t]=i; if (i&gt;=le) cout&lt;&lt;q[h]&lt;&lt;' '; &#125;&#125;int main() &#123; int n,k; cin&gt;&gt;n&gt;&gt;k; for (int i=1; i&lt;=n; i++) cin&gt;&gt;a[i]; if(k==1)&#123; for (int i=1; i&lt;=n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; cout&lt;&lt;\"\\n\"; for (int i=1; i&lt;=n; i++) cout&lt;&lt;a[i]&lt;&lt;\" \"; return 0; &#125; minq(a,n,k); cout&lt;&lt;\"\\n\"; maxq(a,n,k);&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"单调队列","slug":"单调队列","permalink":"https://stevebraveman.github.io/tags/单调队列/"}]},{"title":"-并查集- [洛谷 P3420][POI2005]SKA-Piggy Banks","slug":"28","date":"2018-08-29T10:26:28.000Z","updated":"2019-08-08T10:35:18.537Z","comments":true,"path":"2018/08/29/28/","link":"","permalink":"https://stevebraveman.github.io/2018/08/29/28/","excerpt":"题目描述Byteazar the Dragon拥有N个小猪存钱罐。每一个存钱罐能够用相应的钥匙打开或者被砸开。Byteazar已经将钥匙放入到一些存钱罐中。现在已知每个钥匙所在的存钱罐，Byteazar想要买一辆小汽车，而且需要打开所有的存钱罐。然而，他想要破坏尽量少的存钱罐，帮助Byteazar去决策最少要破坏多少存钱罐。","text":"题目描述Byteazar the Dragon拥有N个小猪存钱罐。每一个存钱罐能够用相应的钥匙打开或者被砸开。Byteazar已经将钥匙放入到一些存钱罐中。现在已知每个钥匙所在的存钱罐，Byteazar想要买一辆小汽车，而且需要打开所有的存钱罐。然而，他想要破坏尽量少的存钱罐，帮助Byteazar去决策最少要破坏多少存钱罐。读入存钱罐的数量以及相应的钥匙的位置，求出能打开所有存钱罐的情况下，需要破坏的存钱罐的最少数量并将其输出。 输入格式第一行：包括一个整数N（1&lt;=N&lt;=1000000)，这是Byteazar the Dragon拥有的存钱罐的数量。 存钱罐（包括它们对应的钥匙）从1到N编号。 接下来有N行：第i+1行包括一个整数x，表示第i个存钱罐对应的钥匙放置在了第x个存钱罐中。 输出格式仅一行：包括一个整数，表示能打开所有存钱罐的情况下，需要破坏的存钱罐的最少数量。 输入样例42124 输出样例2 Solution这道题可用并查集来做，把有对应钥匙的存钱罐和存这个钥匙的存钱罐合并到一个集合内，然后再求连通块的个数。 Code1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int fa[1000003];int find(int a)&#123; if(fa[a]==a) return a; else return fa[a]=find(fa[a]);&#125;void un(int a,int b)&#123; a=find(a); b=find(b); fa[b]=a;&#125;int main()&#123; int n,a; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; fa[i]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;a); un(i,a); &#125; int ans=0; for(int i=1;i&lt;=n;i++)&#123; if(fa[i]==i) ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"并查集","slug":"并查集","permalink":"https://stevebraveman.github.io/tags/并查集/"}]},{"title":"-线段树- [洛谷 P2023][AHOI2009]维护序列","slug":"27","date":"2018-08-28T04:54:17.000Z","updated":"2019-08-08T10:35:00.168Z","comments":true,"path":"2018/08/28/27/","link":"","permalink":"https://stevebraveman.github.io/2018/08/28/27/","excerpt":"题目描述老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。","text":"题目描述老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。有长为N的数列，不妨设为a1,a2,…,aN 。有如下三种操作形式： (1)把数列中的一段数全部乘一个值; (2)把数列中的一段数全部加一个值; (3)询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模P的值。 输入格式第一行两个整数N和P(1≤P≤1000000000）。 第二行含有N个非负整数,从左到右依次为a1,a2,…,aN, (0≤ai≤1000000000,1≤i≤N)。 第三行有一个整数M，表示操作总数。 从第四行开始每行描述一个操作，输入的操作有以下三种形式： 操作1：“1 t g c”(不含双引号)。表示把所有满足t≤i≤g的ai改为ai×c (1≤t≤g≤N,0≤c≤1000000000)。 操作2：“2 t g c”(不含双引号)。表示把所有满足t≤i≤g的ai改为ai+c (1≤t≤g≤N,0≤c≤1000000000)。 操作3：“3 t g”(不含双引号)。询问所有满足t≤i≤g的ai的和模P的值 (1≤t≤g≤N)。 同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。 输出格式对每个操作3，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。 输入样例7 431 2 3 4 5 6 751 2 5 53 2 42 3 7 93 1 33 4 7 输出样例2358 说明【样例说明】 初始时数列为(1,2,3,4,5,6,7)。 经过第1次操作后，数列为(1,10,15,20,25,6,7)。 对第2次操作，和为10+15+20=45，模43的结果是2。 经过第3次操作后，数列为(1,10,24,29,34,15,16} 对第4次操作，和为1+10+24=35，模43的结果是35。 对第5次操作，和为29+34+15+16=94,模43的结果是8。 测试数据规模如下表所示 数据编号 1 2 3 4 5 6 7 8 9 10 N= 10 1000 1000 10000 60000 70000 80000 90000 100000 100000 M= 10 1000 1000 10000 60000 70000 80000 90000 100000 100000 Solution这道题读一遍就知道是线段树模板题，所以不多说，直接上代码 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define lson l,m,rt&lt;&lt;1#define rson m+1,r,rt&lt;&lt;1|1#define ls(x) ((x)&lt;&lt;1)#define rs(x) (((x)&lt;&lt;1)|(1))#define MAXN 1000100#define LL long long using namespace std;LL mod;struct Segment_Tree &#123; LL sum[MAXN&lt;&lt;2],add[MAXN&lt;&lt;2],mul[MAXN&lt;&lt;2]; void p_u(int rt) &#123; sum[rt]=sum[ls(rt)]+sum[rs(rt)]; &#125; void p_d(LL rt,LL len) &#123; if(add[rt]!=0||mul[rt]!=1) &#123; add[ls(rt)]=((add[ls(rt)]%mod)*(mul[rt]%mod)+add[rt])%mod; add[rs(rt)]=((add[rs(rt)]%mod)*(mul[rt]%mod)+add[rt])%mod;/*********************************************************************************************/ mul[ls(rt)]=(mul[rt&lt;&lt;1]*mul[rt])%mod; mul[rs(rt)]=(mul[rs(rt)]*mul[rt])%mod;/*********************************************************************************************/ sum[ls(rt)]=((add[rt]%mod)*(len-(len&gt;&gt;1))%mod+(sum[ls(rt)]%mod)*mul[rt]%mod)%mod; sum[rs(rt)]=(((add[rt]%mod)*(len&gt;&gt;1))%mod+(sum[rs(rt)]%mod)*mul[rt]%mod)%mod;/*********************************************************************************************/ add[rt]=0; mul[rt]=1; &#125; &#125; void build(LL l,LL r,LL rt) &#123; add[rt]=0; mul[rt]=1; if(l==r) &#123; scanf(\"%lld\",&amp;sum[rt]); return ; &#125; int m=(l+r)&gt;&gt;1; build(lson); build(rson); p_u(rt); &#125; void update1(LL L,LL R,LL c,LL l,LL r,LL rt) &#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; add[rt]=add[rt]*c%mod; mul[rt]=mul[rt]*c%mod; sum[rt]=sum[rt]*c%mod; return ; &#125; p_d(rt,r-l+1); LL m=(l+r)&gt;&gt;1; if(L&lt;=m) update1(L,R,c,lson); if(m&lt;R) update1(L,R,c,rson); p_u(rt); &#125; void update2(LL L,LL R,LL c,LL l,LL r,LL rt) &#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; add[rt]=(add[rt]+c)%mod; sum[rt]=(sum[rt]+(r-l+1)*c)%mod; return ; &#125; p_d(rt,r-l+1); LL m=(l+r)&gt;&gt;1; if(L&lt;=m) update2(L,R,c,lson); if(m&lt;R) update2(L,R,c,rson); p_u(rt); &#125; LL query(LL L,LL R,LL l,LL r,LL rt) &#123; if(L&lt;=l&amp;&amp;r&lt;=R) return sum[rt]%mod; p_d(rt,r-l+1); LL ret=0; int m=(l+r)&gt;&gt;1; if(L&lt;=m)ret+=query(L,R,lson)%mod; if(R&gt;m) ret+=query(L,R,rson)%mod; return ret%mod; &#125;&#125;Tree;int main() &#123; LL n,m; scanf(\"%lld%lld\",&amp;n,&amp;mod); Tree.build(1,n,1); LL op,a,b,c; scanf(\"%lld\",&amp;m); while(m--) &#123; scanf(\"%lld\",&amp;op); if(op==1) &#123; scanf(\"%lld%lld%lld\",&amp;a,&amp;b,&amp;c); Tree.update1(a,b,c,1,n,1); &#125; else if(op==2) &#123; scanf(\"%lld%lld%lld\",&amp;a,&amp;b,&amp;c); Tree.update2(a,b,c,1,n,1); &#125; else &#123; scanf(\"%lld%lld\",&amp;a,&amp;b); printf(\"%lld\\n\",Tree.query(a,b,1,n,1)%mod); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"线段树","slug":"线段树","permalink":"https://stevebraveman.github.io/tags/线段树/"}]},{"title":"-递推- [BZOJ 2173]整数的lqp拆分","slug":"26","date":"2018-08-27T04:07:06.000Z","updated":"2019-08-08T10:34:44.922Z","comments":true,"path":"2018/08/27/26/","link":"","permalink":"https://stevebraveman.github.io/2018/08/27/26/","excerpt":"题目描述lqp在为出题而烦恼，他完全没有头绪，好烦啊… 他首先想到了整数拆分。整数拆分是个很有趣的问题。给你一个正整数N，对于N的一个整数拆分就是满足任意m&gt;0，a1 ,a2 ,a3…am&gt;0，且a1+a2+a3+…+am=N的一个有序集合。通过长时间的研究我们发现了计算对于N的整数拆分的总数有一个很简单的递推式，但是因为这个递推式实在太简单了，如果出这样的题目，大家会对比赛毫无兴趣的。","text":"题目描述lqp在为出题而烦恼，他完全没有头绪，好烦啊… 他首先想到了整数拆分。整数拆分是个很有趣的问题。给你一个正整数N，对于N的一个整数拆分就是满足任意m&gt;0，a1 ,a2 ,a3…am&gt;0，且a1+a2+a3+…+am=N的一个有序集合。通过长时间的研究我们发现了计算对于N的整数拆分的总数有一个很简单的递推式，但是因为这个递推式实在太简单了，如果出这样的题目，大家会对比赛毫无兴趣的。然后lqp又想到了斐波那契数。定义F0=0，F1=1，Fn=Fn-1+Fn-2 (n&gt;1)，Fn就是斐波那契数的第n项。但是求出第n项斐波那契数似乎也不怎么困难… lqp为了增加选手们比赛的欲望，于是绞尽脑汁，想出了一个有趣的整数拆分，我们暂且叫它：整数的lqp拆分。和一般的整数拆分一样，整数的lqp拆分是满足任意m&gt;0，a1 ,a2 ,a3…am&gt;0，且a1+a2+a3+…+am=N的一个有序集合。但是整数的lqp拆分要求的不是拆分总数，相对更加困难一些。对于每个拆分，lqp定义这个拆分的权值Fa1Fa2…Fam，他想知道对于所有的拆分，他们的权值之和是多少？简单来说，就是求 由于这个数会十分大，lqp稍稍简化了一下题目，只要输出对于N的整数lqp拆分的权值和mod 109（10的9次方）+7输出即可。 输入输入的第一行包含一个整数N。 输出输出一个整数，为对于N的整数lqp拆分的权值和mod 109（10的9次方）+7。 样例输入3 样例输出5 说明$ F_0 = 0, F_1 = 1, F_2 = 1, F_3 = 2 $。 对于$ N = 3 $，有这样几种lqp拆分： $ 3 = 1 + 1 + 1 $, 权值是$ 1 \\times 1 \\times 1=1 $。 $ 3 = 1 + 2 $，权值是$ 1 \\times 2 = 2 $。 $ 3 = 2 + 1 $，权值是$2 \\times 1 = 2 $。 所以答案是 $ 1 \\times 1 \\times 1+1 \\times 2+2 \\times 1 = 5 $。提示 20%数据满足：$ 1 ≤ N ≤ 25 $ $ 50% $数据满足：$ 1 ≤ N ≤ 1000 $ $ 100% $数据满足：$ 1 ≤ N ≤ 1000000$ Solution首先这道题我读懂它就花了一个小时，明白了其实说明是错的，应该是这样： 对于 $ 3 $ 对于 $ N = 3 $，有这样几种lqp拆分： $ 3 = 1 + 1 + 1 $, 权值是$1 \\times 1 \\times 1=1$。 $ 3 = 1 + 2 $ ，权值是 $ 1 \\times 1 = 1 $。 $ 3 = 2 + 1 $ ，权值是 $ 1 \\times 1 = 1 $。 $3=3$，权值是$2$。 所以答案是 $ 1 \\times 1 \\times 1+1 \\times 1+1 \\times 1 + 2 = 5 $。 然后，由于我没有学过生成函数，所以硬推公式花了我一个晚上+一个上午。。。。 然而我还是没推出来，于是人工在纸上打表，又花了好长时间。。。。 最后，终于从打表上找出了规律！ 公式是： F_i = 2 \\times F_{i-1} + F_{i-2}真的是堪比小凯的疑惑啊！ 代码十分短小。 Code1234567891011121314#include&lt;iostream&gt;#define MOD 1000000007using namespace std;long long f[1000005];int main()&#123; int n; cin&gt;&gt;n; f[0]=0; f[1]=1; for(int i=2;i&lt;=n;i++)&#123; f[i]=(f[i-1]*2+f[i-2])%MOD; &#125; cout&lt;&lt;f[n]&lt;&lt;endl;&#125; 据说这是国家集训队的题","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://stevebraveman.github.io/tags/BZOJ/"},{"name":"递推","slug":"递推","permalink":"https://stevebraveman.github.io/tags/递推/"}]},{"title":"-树状数组-[洛谷 P4514]上帝造题的七分钟","slug":"25","date":"2018-08-27T04:06:56.000Z","updated":"2019-08-08T10:34:31.841Z","comments":true,"path":"2018/08/27/25/","link":"","permalink":"https://stevebraveman.github.io/2018/08/27/25/","excerpt":"题目背景裸体就意味着身体。 题目描述“第一分钟，X说，要有矩阵，于是便有了一个里面写满了 00 的 n×mn×m 矩阵。第二分钟，L说，要能修改，于是便有了将左上角为 (a,b)(a,b) ，右下角为 (c,d)(c,d) 的一个矩形区域内的全部数字加上一个值的操作。第三分钟，k说，要能查询，于是便有了求给定矩形区域内的全部数字和的操作。第四分钟，彩虹喵说，要基于二叉树的数据结构，于是便有了数据范围。第五分钟，和雪说，要有耐心，于是便有了时间限制。第六分钟，吃钢琴男说，要省点事，于是便有了保证运算过程中及最终结果均不超过32位有符号整数类型的表示范围的限制。第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”——《上帝造裸题的七分钟》","text":"题目背景裸体就意味着身体。 题目描述“第一分钟，X说，要有矩阵，于是便有了一个里面写满了 00 的 n×mn×m 矩阵。第二分钟，L说，要能修改，于是便有了将左上角为 (a,b)(a,b) ，右下角为 (c,d)(c,d) 的一个矩形区域内的全部数字加上一个值的操作。第三分钟，k说，要能查询，于是便有了求给定矩形区域内的全部数字和的操作。第四分钟，彩虹喵说，要基于二叉树的数据结构，于是便有了数据范围。第五分钟，和雪说，要有耐心，于是便有了时间限制。第六分钟，吃钢琴男说，要省点事，于是便有了保证运算过程中及最终结果均不超过32位有符号整数类型的表示范围的限制。第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”——《上帝造裸题的七分钟》所以这个神圣的任务就交给你了。 输入格式输入数据的第一行为X n m，代表矩阵大小为 $n \\times m$ 。从输入数据的第二行开始到文件尾的每一行会出现以下两种操作： L a b c d delta —— 代表将 $(a,b),(c,d)$ 为顶点的矩形区域内的所有数字加上$delta$。k a b c d —— 代表求 $(a,b),(c,d)$ 为顶点的矩形区域内所有数字的和。请注意， $ k $ 为小写。 输出格式针对每个 $k$ 操作，在单独的一行输出答案。 输入样例X 4 4L 1 1 3 3 2L 2 2 4 4 1k 2 2 3 3 输出样例12 说明对于10%的数据， $ 1 ≤ n ≤ 16, 1 ≤ m ≤ 16 $ , 操作不超过200个.对于60%的数据， $1 ≤ n ≤ 512, 1 ≤ m ≤ 512$ .对于100%的数据， $1 ≤ n ≤ 2048, 1 ≤ m ≤ 2048, -500 ≤ delta ≤ 500$ ,操作不超过200000个,保证运算过程中及最终结果均不超过32位带符号整数类型的表示范围。by XLk Solution这道题真的是哔了狗了，一大堆玄学卡常及优化，最后还开了O2，才勉强AC。 这道题差不多就是个二维树状数组的模板，但有1个坑点要注意： 区间修改坐标要+1，区间查询坐标不能+1 就因为这个被卡了好久。。。。 直接上代码 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iomanip&gt;#define lowbit(x) ((x)&amp;(-(x)))#define R register#define ll long longusing namespace std;inline void read(int &amp;w) &#123; int f=1; w=0; char s=getchar(); while(s&lt;'0'||s&gt;'9') &#123;if(s=='-')f=-1;s=getchar();&#125; while(s&gt;='0'&amp;&amp;s&lt;='9') &#123;w=w*10+s-'0';s=getchar();&#125; w*=f;&#125;inline void write(int x) &#123; if(x&lt;0) &#123;putchar('-');x=-x;&#125; if(x&gt;9)write(x/10); putchar(x%10+'0');&#125;int n,m;struct BIT_2D &#123; int a[4][2049][2049]; void up(int x,int y,int delta) &#123; if (x&lt;1 || n&lt;x || y&lt;1 || m&lt;y) return; for (int i=x; i&lt;=n; i+=lowbit(i)) &#123; for (int j=y; j&lt;=m; j+=lowbit(j)) &#123; a[0][i][j]+=delta; a[1][i][j]+=delta*y; a[2][i][j]+=delta*x; a[3][i][j]+=delta*x*y; &#125; &#125; &#125; int sum(int x,int y) &#123; int res=0; for (int i=x; i; i-=lowbit(i)) &#123; for (int j=y; j; j-=lowbit(j)) &#123; res=res+(x+1)*(y+1)*a[0][i][j]-(x+1)*a[1][i][j]-(y+1)*a[2][i][j]+a[3][i][j]; &#125; &#125; return res; &#125;&#125;tree;int main() &#123; char flag; cin&gt;&gt;flag; cin&gt;&gt;n&gt;&gt;m; while(scanf(\"\\n%c \",&amp;flag)!=EOF) &#123; int x1,y1,x2,y2; int k; if(flag=='L') &#123; read(x1);read(y1);read(x2);read(y2);read(k); x1++;x2++;y1++;y2++; tree.up(x2,y2,k); tree.up(x1-1,y2,-k); tree.up(x2,y1-1,-k); tree.up(x1-1,y1-1,k); &#125; else &#123; read(x1);read(y1);read(x2);read(y2); int p=tree.sum(x2,y2)-tree.sum(x1-1,y2)-tree.sum(x2,y1-1)+tree.sum(x1-1,y1-1); write(p); puts(\"\"); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"树状数组","slug":"树状数组","permalink":"https://stevebraveman.github.io/tags/树状数组/"}]},{"title":"-线段树- [洛谷 P3353]在你窗外闪耀的星星","slug":"24","date":"2018-08-23T23:54:50.000Z","updated":"2019-08-08T10:34:17.290Z","comments":true,"path":"2018/08/24/24/","link":"","permalink":"https://stevebraveman.github.io/2018/08/24/24/","excerpt":"题目描述飞逝的的时光不会模糊我对你的记忆。难以相信从我第一次见到你以来已经过去了3年。我仍然还生动地记得，3年前，在美丽的集美中学，从我看到你微笑着走出教室，你将头向后仰，柔和的晚霞照耀着你玫瑰色的脸颊。我明白，我已经沉醉于你了。之后，经过几个月的观察和窥探，你的优雅与智慧，你对待生活的态度和你对未来的愿望深切地在我心中留下了印象。你是迷人的阳光女孩，我总是梦想着与你分享余生。唉，实际上你远远超过了我最疯狂的梦想。我不知道如何桥起我与你之间的鸿沟。所以我没有任何计划，仅仅只是等待，等待一个适当的机会到来。直到现在，毕业的到来，我意识到我是个傻瓜，我应该创造机会并且抓住它而不只是等待。","text":"题目描述飞逝的的时光不会模糊我对你的记忆。难以相信从我第一次见到你以来已经过去了3年。我仍然还生动地记得，3年前，在美丽的集美中学，从我看到你微笑着走出教室，你将头向后仰，柔和的晚霞照耀着你玫瑰色的脸颊。我明白，我已经沉醉于你了。之后，经过几个月的观察和窥探，你的优雅与智慧，你对待生活的态度和你对未来的愿望深切地在我心中留下了印象。你是迷人的阳光女孩，我总是梦想着与你分享余生。唉，实际上你远远超过了我最疯狂的梦想。我不知道如何桥起我与你之间的鸿沟。所以我没有任何计划，仅仅只是等待，等待一个适当的机会到来。直到现在，毕业的到来，我意识到我是个傻瓜，我应该创造机会并且抓住它而不只是等待。 这些日子里，我和我的朋友、室友、同学一个接一个地分开。我仍无法相信，在挥手之后，这些熟悉的面孔很快就会从我们的生活中消失，仅仅留下回忆。我明天就将离开学校。你已经计划远走高飞，追求你的未来，实现你的梦想。如果没有命运，也许我们不会再次相遇。所以今晚，我正在你的宿舍楼下徘徊，希望能偶然遇见你。但矛盾的是，你的美貌一定会使我心跳加速，我笨拙的舌头也许无法吐出一个字。我不记得我曾多少次经过你的宿舍楼，每次都希望看到你出现在阳台上或是窗台上。我不记得这个想法曾多少次在我的脑海中涌出：打电话叫她一起吃晚饭或是聊聊天。但每次，考虑到你的优秀和我的平凡，胆怯的优势超越勇气驱使我静静地离开。 毕业，意味着中学生活的终结。这些光荣与浪漫的时代结束。你可爱的微笑是我原来努力学习的动力，这单相思的爱情会被密封，作为一个我心灵深处的记忆。毕业，也意味着新生活的开始，一个到达光明未来的足迹。我真希望你在国外天天开心，一切顺利。同时，我将努力从幼稚中走出来，变得更加成熟。我的理想将是在现实中追求我的爱与幸福，我永远不会放弃。 再见了，我的公主！ 如果有一天，在某个天涯海角，我们有机会相聚，即使是白发苍苍的男人和女人，在那个时候，我希望我们可以成为好朋友来自豪地分享这个记忆，重温年轻快乐的激情。如果这个机会永远没有到来，我希望我是天空中的星星，在你的窗外闪烁。远远地保佑着你，就像一个朋友，每天晚上陪伴在你左右，一同分享甜美的梦亦或是一同经历可怕的梦。 现在问题来了：天空可以理解为一条数轴，在这条数轴上分布着许多颗星星，对于每颗星星都有它的位置Xi和自身的亮度Bi。而窗户所能看到的范围是一个给出的参数W，我们看到的星星也包括窗户边缘的星星。现在，要你求出调整窗户位置后能看到星星的亮度之和最大值。 输入格式一行N,W，分别代表星星的数量和窗户的宽度 余下N行，输入Xi和Bi，代表星星的坐标和亮度 输出格式一个数字，代表能看到星星的最大亮度和 输入输出样例 输入样例6 31 22 43 84 45 21000 1 输出样例16 说明对于10%的数据，W=0（没有边缘） 对于40%的数据，W&lt;=1000 对于100%的数据，N&lt;=100000，W&lt;=100000，Xi&lt;=100000，1&lt;=Bi&lt;=100 除W=0的情况外，W均为&gt;=3的奇数 Solution看完这个题面我都快要被甜死了，不得不说原题作者的文笔非常好。 他也许能得全国作文比赛一等奖 好了，下面进入正题 这道题直接用线段树可做，把星星的坐标和位置表示出来就可以了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#define MAX 1000005#define ll long long#define ls(x) ((x)&lt;&lt;1)#define rs(x) (((x)&lt;&lt;1)+1)using namespace std;unsigned ll a[MAX],ans[MAX*4],t[MAX*4];ll max(ll a,ll b)&#123; return a&gt;b?a:b;&#125;inline void pd(ll p) &#123; ans[p]=ans[ls(p)]+ans[rs(p)];&#125;void build(ll p,ll l,ll r) &#123; t[p]=0; if(l==r) &#123; ans[p]=a[l]; return; &#125; ll mid=(l+r)/2; build(ls(p),l,mid); build(rs(p),mid+1,r); pd(p);&#125;inline void f(ll p,ll l,ll r,ll k) &#123; t[p]=t[p]+k; ans[p]=ans[p]+k*(r-l+1);&#125;inline void p_d(ll p,ll l,ll r) &#123; ll mid=(l+r)&gt;&gt;1; f(ls(p),l,mid,t[p]); f(rs(p),mid+1,r,t[p]); t[p]=0;&#125;ll sum(ll x,ll y,ll l,ll r,ll p) &#123; ll s=0; if(x&lt;=l&amp;&amp;r&lt;=y)&#123; return ans[p]; &#125; ll mid=(l+r)&gt;&gt;1; p_d(p,l,r); if(x&lt;=mid)s+=sum(x,y,l,mid,ls(p)); if(y&gt;mid) s+=sum(x,y,mid+1,r,rs(p)); return s;&#125;int main() &#123; ll a1,b,c,d,f,m,n; int e; cin&gt;&gt;n&gt;&gt;m; ll len=0; if(m==0)&#123; cout&lt;&lt;0&lt;&lt;endl; return 0; &#125; for(ll i=1;i&lt;=n;i++)&#123; scanf(\"%d%lld\",&amp;e,&amp;f); a[e]+=f; len=max(len,e); &#125; build(1,1,len); ll maxa=0; for(ll i=1;i&lt;=len-m+1;i++)&#123; ll q=sum(i,i+m-1,1,len,1); maxa=max(q,maxa); &#125; printf(\"%lld\\n\",maxa); return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://stevebraveman.github.io/tags/线段树/"}]},{"title":"-数论-二分- [洛谷 P2759]奇怪的函数","slug":"23","date":"2018-08-22T09:58:31.000Z","updated":"2019-08-08T10:33:55.604Z","comments":true,"path":"2018/08/22/23/","link":"","permalink":"https://stevebraveman.github.io/2018/08/22/23/","excerpt":"题目描述使得 $x^x$ 达到或超过 $n$ 位数字的最小正整数 $x$ 是多少？","text":"题目描述使得 $x^x$ 达到或超过 $n$ 位数字的最小正整数 $x$ 是多少？ 输入格式一个正整数 $n$ 输出格式使得 $x^x$ 达到 $n$ 位数字的最小正整数 $x$ 输入样例11 输出样例10 说明n&lt;=2000000000 Solution直接暴力枚举当然不可取，不仅会TLE而且还会精度爆炸，所以我们要做一些优化 显而易见，$x^x$的位数是$\\log{10}{x^x}$，也就是$n=\\log{10}{x^x}$。 而且我们还知道$\\log{a}{b^m}=m\\log{a}{b}$； 所以$\\log{10}{x^x}=x\\log{10}{x}$。 因为n&lt;=20000000000，所以我们要用二分。 Code123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#define MAX 100000000#define lg(x) (x)*(log10((x)))//因为以10为底的对数都简写作lg，所以我就用lg表示了，而且使用define时千万不要吝惜括号！！(重要)using namespace std;int main() &#123; long long n,p,m,l=1,h=20*MAX; scanf(\"%lld\",&amp;n); while(l&lt;=h) &#123; m=(l+h)/2; if(n&lt;=(lg(m)+1)) &#123; p=m; h=m-1; &#125; else &#123; l=m+1; &#125; &#125; cout&lt;&lt;p&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"},{"name":"二分","slug":"二分","permalink":"https://stevebraveman.github.io/tags/二分/"}]},{"title":"-图论-并查集- [洛谷 P1536]村村通","slug":"22","date":"2018-08-22T09:48:40.000Z","updated":"2019-08-08T10:30:46.487Z","comments":true,"path":"2018/08/22/22/","link":"","permalink":"https://stevebraveman.github.io/2018/08/22/22/","excerpt":"题目描述某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府“村村通工程”的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？","text":"题目描述某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府“村村通工程”的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？ 输入格式每个输入文件包含若干组测试测试数据，每组测试数据的第一行给出两个用空格隔开的正整数，分别是城镇数目N（N&lt;1000）和道路数目M；随后的M行对应M条道路，每行给出一对用空格隔开的正整数，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从1到N编号。 注意：两个城市间可以有多条道路相通。例如： 3 31 21 22 1 这组数据也是合法的。当N为0时，输入结束。 输出格式：对于每组数据，对应一行一个整数。表示最少还需要建设的道路数目。 输入样例 4 21 34 33 31 21 32 35 21 23 5999 00 输出样例 102998 Solution我们知道，一个有n个点的连通图最少有n-1条边。 所以我们只需要删去重边，并且不生成环。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n,m,fa[20005];int find(int x)&#123; if(fa[x]!=x) fa[x]=find(fa[x]); return fa[x];&#125;void un(int x,int y)&#123; x=find(x); y=find(y); fa[x]=y;&#125;void init()&#123; memset(fa,0,sizeof(fa)); for(int i=1;i&lt;=n;i++)&#123; fa[i]=i; &#125;&#125;int main()&#123; while(cin&gt;&gt;n)&#123; if(n==0) break; cin&gt;&gt;m; init(); if(m==0)&#123; cout&lt;&lt;n-1&lt;&lt;endl; continue; &#125; int x,y; int p=0; int t=1; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;x&gt;&gt;y; if(find(x)==find(y))&#123; t=1; &#125; else&#123; un(x,y); p++; &#125; &#125; cout&lt;&lt;n-1-p&lt;&lt;endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"图论","slug":"图论","permalink":"https://stevebraveman.github.io/tags/图论/"},{"name":"并查集","slug":"并查集","permalink":"https://stevebraveman.github.io/tags/并查集/"}]},{"title":"-图论-并查集-最小生成树- [洛谷 P1195]口袋的天空","slug":"21","date":"2018-08-21T06:22:07.000Z","updated":"2019-08-08T10:32:30.837Z","comments":true,"path":"2018/08/21/21/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/21/","excerpt":"题目背景小杉坐在教室里，透过口袋一样的窗户看口袋一样的天空。 有很多云飘在那里，看起来很漂亮，小杉想摘下那样美的几朵云，做成棉花糖。","text":"题目背景小杉坐在教室里，透过口袋一样的窗户看口袋一样的天空。 有很多云飘在那里，看起来很漂亮，小杉想摘下那样美的几朵云，做成棉花糖。 题目描述给你云朵的个数 $N$ ，再给你 $M$ 个关系，表示哪些云朵可以连在一起。 现在小杉要把所有云朵连成 $K$ 个棉花糖，一个棉花糖最少要用掉一朵云，小杉想知道他怎么连，花费的代价最小。 输入格式、每组测试数据的 第一行有三个数 $ N,M,K(1 \\le N \\le 1000,1 \\le M \\le 10000,1 \\le K \\le 10) $ 接下来 $M$ 个数每行三个数 $X,Y,L$ ，表示 $X$ 云和 $Y$ 云可以通过 $L$ 的代价连在一起。 $(1 \\le X,Y \\le N,0 \\le L&lt;10000)$ $30%$ 的数据 $N \\le 100,M \\le 1000N≤100,M≤1000$ 输出格式对每组数据输出一行，仅有一个整数，表示最小的代价。 如果怎么连都连不出 $K$ 个棉花糖，请输出No Answer。 输入样例3 1 21 2 1 输出样例1 Solution这道题可用并查集来做，先把代价排序，然后合并，如果在同一集合，则不合并。 每合并一次就会减少一个连通块。 其实这就是Kruskal最小生成树的思想。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct Edge&#123; int u,v,w;&#125; e[200002];int fa[200002]=&#123;0&#125;;int find(int x)&#123; if(fa[x]!=x) fa[x]=find(fa[x]); return fa[x];&#125;int un(int x,int y)&#123; fa[x]=y;&#125;bool cmp(Edge a,Edge b)&#123; return a.w&lt;b.w;&#125;int main()&#123; int n,m,k,ans=0; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=n;i++)&#123; fa[i]=i; &#125; for(int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d%d\",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); &#125; int u=0; int p=n-k; int q=0; sort(e+1,e+1+m,cmp); for(int i=1;i&lt;=m;i++)&#123; int x,y; x=find(e[i].u); y=find(e[i].v); if(x==y)&#123; goto exit; &#125; else&#123; un(x,y); q++; ans+=e[i].w; &#125; if(q==p)&#123; break; &#125; exit: u=0; &#125; cout&lt;&lt;ans;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"图论","slug":"图论","permalink":"https://stevebraveman.github.io/tags/图论/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://stevebraveman.github.io/tags/最小生成树/"},{"name":"并查集","slug":"并查集","permalink":"https://stevebraveman.github.io/tags/并查集/"}]},{"title":"-并查集- [BZOJ  4195][NOI 2015]程序自动分析","slug":"20","date":"2018-08-21T05:10:43.000Z","updated":"2019-08-08T10:32:13.467Z","comments":true,"path":"2018/08/21/20/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/20/","excerpt":"题目描述在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。","text":"题目描述在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。 考虑一个约束满足问题的简化版本：假设x1,x2,x3…代表程序中出现的变量，给定n个形如xi=xj或xi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2,x2=x3,x3=x4,x4≠x1，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。 现在给出一些约束满足问题，请分别对它们进行判定。 输入格式输入文件的第1行包含1个正整数t，表示需要判定的问题个数。注意这些问题之间是相互独立的。 对于每个问题，包含若干行： 第1行包含1个正整数n，表示该问题中需要被满足的约束条件个数。接下来n行，每行包括3个整数i,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1，则该约束条件为xi=xj；若e=0，则该约束条件为xi≠xj； 输出格式输出文件包括t行。 输出文件的第 k行输出一个字符串“ YES” 或者“ NO”（不包含引号，字母全部大写），“ YES” 表示输入中的第k个问题判定为可以被满足，“ NO” 表示不可被满足。 样例输入221 2 11 2 021 2 12 1 1 样例输出NOYES 提示在第一个问题中，约束条件为：x1=x2,x1≠x2。这两个约束条件互相矛盾，因此不可被同时满足。 Solution思路：这道题我们可以使用并查集来做，把相等的合并到一个集合里，如果出现不等判定一下是否在一个集合里； 注意：千万别用map，千万别用map，会超时，所以还是乖乖写离散化吧。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define MOD 10000019using namespace std;int m;struct node &#123; int x,y,e;&#125; bcj[MOD*2];int disa=0;bool cmp(node a,node b) &#123; return a.e&gt;b.e;&#125;int fa[200005];int find(int x) &#123; if(fa[x]!=x) return fa[x]=find(fa[x]); else return x;&#125;void un(int r1,int r2) &#123; fa[r1]=r2;&#125;int main() &#123; int t; cin&gt;&gt;t; for(int q=1; q&lt;=t; q++) &#123; disa=-1; bool flag=1; memset(ls,0,sizeof(ls)); memset(fa,0,sizeof(fa)); cin&gt;&gt;m; for(int i=1; i&lt;=m; i++) &#123; scanf(\"%d %d %d\",&amp;bcj[i].x,&amp;bcj[i].y,&amp;bcj[i].e); ls[disa++]=bcj[i].x; ls[disa++]=bcj[i].y; &#125; sort(ls,ls+disa); int x=unique(ls,ls+disa)-ls; for(int i=1; i&lt;=m; i++) &#123; bcj[i].x=lower_bound(ls,ls+x,bcj[i].x)-ls; bcj[i].y=lower_bound(ls,ls+x,bcj[i].y)-ls; &#125; for(int i=1; i&lt;=x; i++) &#123; fa[i]=i; &#125; sort(bcj+1,bcj+1+m,cmp); for(int i=1; i&lt;=m; i++) &#123; int g=find(bcj[i].x); int h=find(bcj[i].y); if(bcj[i].e) &#123; un(g,h); &#125; else &#123; if(g==h) &#123; printf(\"NO\\n\"); flag=0; break; &#125; else &#123; flag=1; &#125; &#125; &#125; if(flag) printf(\"YES\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://stevebraveman.github.io/tags/BZOJ/"},{"name":"并查集","slug":"并查集","permalink":"https://stevebraveman.github.io/tags/并查集/"}]},{"title":"-队列- [洛谷 P1540][NOIp 2010]机器翻译","slug":"17","date":"2018-08-21T05:09:08.000Z","updated":"2019-08-08T10:31:11.614Z","comments":true,"path":"2018/08/21/17/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/17/","excerpt":"题目背景小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。","text":"题目背景小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。 题目描述这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。假设内存中有 $M$ 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 $M-1$ ，软件会将新单词存入一个未使用的内存单元；若内存中已存入 $M$ 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。假设一篇英语文章的长度为 $N$ 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。 输入格式共 $2$ 行。每行中两个数之间用一个空格隔开。第一行为两个正整数 $M,N$ ，代表内存容量和文章的长度。第二行为 $N$ 个非负整数，按照文章的顺序，每个数（大小不超过 $1000$ ）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。 输出格式一个整数，为软件需要查词典的次数。 输入样例3 71 2 1 5 4 4 1 输出样例5 说明每个测试点 $1s$对于 $10%$ 的数据有 $M=1,N≤5$ 。对于 $100%$ 的数据有$ 0≤M≤100,0≤N≤10000$ 。整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：空：内存初始状态为空。1． $1$ ：查找单词$1$并调入内存。2． $1 2$ ：查找单词 $2$ 并调入内存。3． $1 2$ ：在内存中找到单词 $1$ 。4． $1 2 5$ ：查找单词 $5$ 并调入内存。5． $2 5 4$ ：查找单词 $4$ 并调入内存替代单词 $1$ 。6． $2 5 4$ ：在内存中找到单词 $4$ 。7． $5 4 1$ ：查找单词1并调入内存替代单词 $2$ 。共计查了 55 次词典。 Solution没什么说的，就是队列模板题。 注意：千万不要把查找和找到搞混了！ Code12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,m;int q[1005]=&#123;0&#125;;int chk=0;int head=1,tail=0;int main()&#123; cin&gt;&gt;m&gt;&gt;n; if(n==0||m==0)&#123; return 0; &#125; for(int i=1;i&lt;=n;i++)&#123; int x; cin&gt;&gt;x; bool flag=0; for(int j=head;j&lt;=tail;j++)&#123; if(q[j]==x)&#123; flag=1; break; &#125; &#125; if(flag)&#123; continue; &#125; if(tail-head+1==m)&#123; head++; tail++; chk++; q[tail]=x; &#125; else&#123; tail++; chk++; q[tail]=x; &#125; &#125; cout&lt;&lt;chk&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"队列","slug":"队列","permalink":"https://stevebraveman.github.io/tags/队列/"}]},{"title":"-DP- [洛谷 P1091][NOIp 2004]合唱队形","slug":"18","date":"2018-08-21T05:09:08.000Z","updated":"2019-08-08T10:31:28.368Z","comments":true,"path":"2018/08/21/18/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/18/","excerpt":"题目描述$N$ 位同学站成一排，音乐老师要请其中的( $N−K$ )位同学出列，使得剩下的 $K$ 位同学排成合唱队形。","text":"题目描述$N$ 位同学站成一排，音乐老师要请其中的( $N−K$ )位同学出列，使得剩下的 $K$ 位同学排成合唱队形。合唱队形是指这样的一种队形：设K位同学从左到右依次编号为 $1,2,…,K$ ，他们的身高分别为 $T1,T_2,…,T_K$ ， 则他们的身高满足 $T_1&lt;…T{i+1}&gt;…&gt;T_K(1 \\le i \\le K)$ 。你的任务是，已知所有$N$位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。 输入格式共二行。第一行是一个整数 $N(2 \\le N \\le 100)$ ，表示同学的总数。第二行有 $n$ 个整数，用空格分隔，第 $i$ 个整数 $T_i(130 \\le T_i \\le 230)$ 是第 $i$ 位同学的身高（厘米）。 输出格式一个整数，最少需要几位同学出列。 输入样例8186 186 150 200 160 130 197 220 输出样例4 Solution思路：首先分析一下题目，题目的意思是找出几个人排成一个先单调递增后单调递减的队伍； 所以我们可以这样求：先枚举到第 $i$ 个人然后求出第 $i$ 个人前的最长上升子序列，再求出第 $i$ 个人后最长下降子序列。 注：需要特判一下当出现只单调递增或只单调递减的情况。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int max(int a,int b) &#123; return (a&gt;=b)?a:b;&#125;int main() &#123; int a[105],ans=0; int n; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125; bool flag=1; for(int i=0; i&lt;n; i++) &#123; if(a[i]&lt;=a[i-1]) &#123; flag=0; &#125; &#125; if(flag)&#123; cout&lt;&lt;'0'&lt;&lt;endl; return 0; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i]&gt;=a[i-1]) &#123; flag=0; &#125; &#125; if(flag)&#123; cout&lt;&lt;'0'&lt;&lt;endl; return 0; &#125; int b[105],c[105]; int maxn=0; for(int k=0; k&lt;n; k++) &#123; memset(b,0,sizeof(b)); memset(c,0,sizeof(c)); c[0]=1; b[0]=1; for (int i=1; i&lt;k; i++) &#123; b[i] = 1; for (int j=0; j&lt;i; j++) &#123; if (a[i]&gt;a[j]&amp;&amp;b[j]+1&gt;b[i]) b[i]=b[j]+1; &#125; &#125; for (int i=k+1; i&lt;n; i++) &#123; c[i] = 1; for (int j=k; j&lt;i; j++) &#123; if (a[i]&lt;a[j]&amp;&amp;c[j]+1&gt;c[i]) c[i]=c[j]+1; &#125; &#125; int maxb=0,maxc=0; for (int i=0; i&lt;k; i++) &#123; maxb=max(b[i],maxb); &#125; for (int i=k; i&lt;n; i++) &#123; maxc=max(c[i],maxc); &#125; maxn=max(maxn,maxb+maxc); &#125; cout&lt;&lt;n-maxn&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"DP","slug":"DP","permalink":"https://stevebraveman.github.io/tags/DP/"}]},{"title":"-图论-最小生成树- [洛谷 P1546][USACO]最短网络","slug":"19","date":"2018-08-21T05:09:08.000Z","updated":"2019-08-08T10:31:52.320Z","comments":true,"path":"2018/08/21/19/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/19/","excerpt":"题目背景农民约翰被选为他们镇的镇长！他其中一个竞选承诺就是在镇上建立起互联网，并连接到所有的农场。当然，他需要你的帮助。","text":"题目背景农民约翰被选为他们镇的镇长！他其中一个竞选承诺就是在镇上建立起互联网，并连接到所有的农场。当然，他需要你的帮助。 题目描述约翰已经给他的农场安排了一条高速的网络线路，他想把这条线路共享给其他农场。为了用最小的消费，他想铺设最短的光纤去连接所有的农场。 你将得到一份各农场之间连接费用的列表，你必须找出能连接所有农场并所用光纤最短的方案。每两个农场间的距离不会超过 $100000$ 。 输入格式第一行： 农场的个数，$N（3&lt;=N&lt;=100）$。 第二行..结尾: 后来的行包含了一个$N \\times N$的矩阵,表示每个农场之间的距离。理论上，他们是N行，每行由N个用空格分隔的数组成，实际上，他们限制在$80$个字符，因此，某些行会紧接着另一些行。当然，对角线将会是$0$，因为不会有线路从第 $i$ 个农场到它本身。 输出格式只有一个输出，其中包含连接到每个农场的光纤的最小长度。 输入样例40 4 9 214 0 8 179 8 0 1621 17 16 0 输出样例28 Solution这道题就是个最小生成树的模板题，但如果你用Kruskal，需要注意两点 1.数组一定要开大 2.手写cmp函数时一定要注意是a.w&lt;b.w千万别带等号，不然会T。。。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;typedef struct &#123; int u,v; int w;&#125; Edge;Edge e[2000002];int fa[2000002];bool cmp(const Edge &amp;a,const Edge &amp;b) &#123; if(a.w&lt;b.w) return true; else return false;&#125;int find(int n) &#123; if(fa[n]==0) return n; else return find(fa[n]);&#125;int uion(int r1,int r2) &#123; r1=find(r1); r2=find(r2); if(r1==r2) return 0; if(r1&lt;r2) fa[r2]=r1; else fa[r1]=r2; return 1;&#125;int main() &#123; int n,p; int sum,count; cin&gt;&gt;n; int k=1; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; int x; scanf(\"%d\",&amp;x); if(j&gt;i) &#123; e[k].w=x; e[k].u=i; e[k].v=j; k++; &#125; &#125; &#125; k--; sort(e+1,e+1+k,cmp); memset(fa,0,sizeof(fa)); sum=0; count=1; for(int i=1; i&lt;=k; i++) &#123; if(uion(e[i].u,e[i].v)) &#123; sum+=e[i].w; count++; &#125; if(count==n) break; &#125; printf(\"%d\",sum); return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"图论","slug":"图论","permalink":"https://stevebraveman.github.io/tags/图论/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://stevebraveman.github.io/tags/最小生成树/"}]},{"title":"-图论-最小生成树- [BZOJ 1083][SCOI 2005]繁忙的都市","slug":"16","date":"2018-08-21T05:08:40.000Z","updated":"2019-08-08T10:30:10.206Z","comments":true,"path":"2018/08/21/16/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/16/","excerpt":"题目描述城市C是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。","text":"题目描述城市C是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市C的道路是这样分布的：城市中有$n$个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求： 1． 改造的那些道路能够把所有的交叉路口直接或间接的连通起来。 2． 在满足要求1的情况下，改造的道路尽量少。 3． 在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小。任务：作为市规划局的你，应当作出最佳的决策，选择那些道路应当被修建。 输入格式第一行有两个整数$n$,$m$表示城市有$n$个交叉路口，$m$条道路。接下来$m$行是对每条道路的描述，$u$，$v$，$c$表示交叉路口$u$和$v$之间有道路相连，分值为$c$。$(1≤n≤300，1≤c≤10000)$ 输出样例两个整数$s$，$max$，表示你选出了几条道路，分值最大的那条道路的分值是多少。 样例输入4 51 2 31 4 52 4 72 3 63 4 8 样例输出3 6 Solution首先让我们看看要求： 1． 改造的那些道路能够把所有的交叉路口直接或间接的连通起来。 2． 在满足要求1的情况下，改造的道路尽量少。 3． 在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小。任务：作为市规划局的你，应当作出最佳的决策，选择那些道路应当被修建。 分析完之后，我们可以发现，这就是一道最小生成树的模板题。 由于我比较喜欢使用Kruskal，所以我写的是kruskal代码； Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;struct edge&#123; int u, v; int w;&#125; ;edge e[200002];int fa[200002];bool cmp(edge a, edge b) &#123; if (a.w&lt;b.w) return 1; else return 0;&#125;int find(int n) &#123; if (fa[n] == 0) return n; else return find(fa[n]);&#125;int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;bool un(int a, int b) &#123; a = find(a); b = find(b); if (a == b) return 0; if (a&lt;b) fa[b] = a; else fa[a] = b; return 1;&#125;int main() &#123; int n, p; int sum, ct;// scanf(\"%d%d\", &amp;n, &amp;p); cin &gt;&gt; n &gt;&gt; p; for (int i = 1; i &lt;= p; i++) &#123;// scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w); cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w; &#125; sort(e + 1, e + 1 + p, cmp); memset(fa, 0, sizeof(fa)); sum = 0; ct = 1; int tot = 0; int maxa = 0; for (int i = 1; i &lt;= p; i++) &#123; if (un(e[i].u, e[i].v)) &#123;// sum += e[i].w; tot++; maxa = max(maxa,e[i].w); ct++; &#125; if (ct == n) break; &#125; printf(\"%d %d\", tot,maxa); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://stevebraveman.github.io/tags/BZOJ/"},{"name":"图论","slug":"图论","permalink":"https://stevebraveman.github.io/tags/图论/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://stevebraveman.github.io/tags/最小生成树/"}]},{"title":"-数论- 唯一分解定理","slug":"4","date":"2018-08-21T04:38:00.000Z","updated":"2019-08-09T02:44:17.532Z","comments":true,"path":"2018/08/21/4/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/4/","excerpt":"","text":"这有一个非常重要的公式： \\prod_{i=1}^n p_i^{a_i}其中 $p_i$ 为质因数，$a_i$ 为每个质因数的指数","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"}]},{"title":"-DP-递推- [洛谷 P1006][NOIp 2008]传纸条","slug":"15","date":"2018-08-21T04:18:00.000Z","updated":"2019-08-08T10:29:52.878Z","comments":true,"path":"2018/08/21/15/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/15/","excerpt":"题目描述小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个 $m$ 行 $n$ 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 $(1,1)$，小轩坐在矩阵的右下角，坐标 $(m,n)$ 。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。","text":"题目描述小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个 $m$ 行 $n$ 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 $(1,1)$，小轩坐在矩阵的右下角，坐标 $(m,n)$ 。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。 还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 $0$ 表示），可以用一个 $0−100$ 的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这 $2$ 条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的 $2$ 条路径。 输入格式输入文件，第一行有 $2$ 个用空格隔开的整数 $m$ 和 $n$ ，表示班里有 $m$ 行 $n$ 列。 接下来的 $m$ 行是一个 $m \\times n$ 的矩阵，矩阵中第 $i$ 行 $j$ 列的整数表示坐在第 $i$ 行 $j$ 列的学生的好心程度。每行的 $n$ 个整数之间用空格隔开。 输出格式输出文件共一行，包含一个整数，表示来回 $2$ 条路上参与传递纸条的学生的好心程度之和的最大值。 输入样例3 30 3 92 8 55 7 0 输出样例34 Solution首先让我们把问题转化一下，小渊给小轩传纸条，小轩也要给小渊传纸条，而且路径不能一样，其实就是相当于 小渊选择两个不同的路径，给小轩传两张纸条 。所以让我们来开一个四维数组f[i][j][p][q]，表示两张纸条传到$(i,j)$，$(p,q)$的最大总价值。一张处于$(i,j)$的纸条一定是从$(i-1,j)$或$(i,j-1)$传过来，因为要最大，所以$f[i][j]=max(f[i-1][j],f[i][j-1])$。于是我们可以写一个四重循环，时间复杂度为$O(n^4)$。但是有一个地方需要注意！当$i=p$，$j=q$时，一定要特殊处理一下，不然就会出错。 Code1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;int max(int a,int b)&#123;\\\\手写max函数 return a&gt;b?a:b;&#125;int mp[50][50]=&#123;0&#125;;int f[52][52][52][52]=&#123;0&#125;;int main()&#123; int n,v,m; cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; cin&gt;&gt;v; mp[i][j]=v; &#125; &#125; for(int i=1;i&lt;=m;i++)&#123;//下面开始四重循环 for(int j=1;j&lt;=n;j++)&#123; for(int p=1;p&lt;=m;p++)&#123; for(int q=1;q&lt;=n;q++)&#123; f[i][j][p][q]=max(max(f[i-1][j][p-1][q],f[i][j-1][p-1][q]),max(f[i-1][j][p][q-1],f[i][j-1][p][q-1]))+mp[i][j]+mp[p][q]; if(i==p&amp;&amp;j==q) f[i][j][p][q]-=mp[p][q];//特殊处理，不然会多加 &#125; &#125; &#125; &#125; cout&lt;&lt;f[m][n][m][n]&lt;&lt;endl; return 0;//完美结束&#125; 顺便说一句，如果你这道题A了，那么P1004也就能A了，并且P1004(方格取数)的数据还比P1006弱。。。。。。","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"递推","slug":"递推","permalink":"https://stevebraveman.github.io/tags/递推/"},{"name":"DP","slug":"DP","permalink":"https://stevebraveman.github.io/tags/DP/"}]},{"title":"-奇技淫巧- C++ 手动开O2优化","slug":"14","date":"2018-08-21T04:17:56.000Z","updated":"2019-08-08T10:28:55.432Z","comments":true,"path":"2018/08/21/14/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/14/","excerpt":"觉得自己的程序耗时太长？ 费尽心思也卡不进那要命的时限？","text":"觉得自己的程序耗时太长？ 费尽心思也卡不进那要命的时限？ 那就来这个吧，大幅度提升程序速度！ 手动开启O2优化！ 1#pragma GCC optimize(2) PS：在一些特殊情况下O2会起到反作用，会使能AC的程序RE。。。。。 PS2：NOIp禁止使用O2及其他类似优化，会禁赛，不过NOI允许开。","categories":[],"tags":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://stevebraveman.github.io/tags/奇技淫巧/"}]},{"title":"-奇技淫巧- C++ 读入输出优化","slug":"13","date":"2018-08-21T04:17:52.000Z","updated":"2019-08-08T10:28:39.982Z","comments":true,"path":"2018/08/21/13/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/13/","excerpt":"有一种比scanf和printf更快的输入输出，那就是读入输出优化！","text":"有一种比scanf和printf更快的输入输出，那就是读入输出优化！快读模板：1234567void read(int &amp;x)&#123; int f=1,x=0;char s=getchar(); while(s&lt;'0'||s&gt;'9')&#123;if(s=='-')f=-1;s=getchar();&#125; while(s&gt;='0'&amp;&amp;s&lt;='9')&#123;x=x*10+s-'0';s=getchar();&#125; x*=f;&#125; 快速输出模板： 1234567891011void write(int x)&#123; if(x&lt;0) &#123; putchar('-'); x=-x; &#125; if(x&gt;9) write(x/10); putchar(x%10+'0');&#125; 当输入输出的数据非常非常多时，就可用这个！ 当然如果你懒得手敲读入输出优化代码，还是用scanf和printf吧","categories":[],"tags":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://stevebraveman.github.io/tags/奇技淫巧/"}]},{"title":"-DFS- [CodeVS P3880]环素数","slug":"12","date":"2018-08-21T04:17:47.000Z","updated":"2019-08-08T10:28:14.883Z","comments":true,"path":"2018/08/21/12/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/12/","excerpt":"题目描述给定一个N(1&lt;=N&lt;=10)，求1——N组成的环，使得环上相邻的元素和为素数。","text":"题目描述给定一个N(1&lt;=N&lt;=10)，求1——N组成的环，使得环上相邻的元素和为素数。 输入描述一个整数N 输出描述把1放在第一位置，按照字典顺序不重复地输出所有解（顺时针，逆时针算不同的两种），相邻两数之间严格用一个空格隔开，每一行的末尾不能有多余的空格。如果无解，则输出“no”。 样例输入8 样例输出1 2 3 8 5 6 7 41 2 5 8 3 4 7 61 4 7 6 5 8 3 21 6 7 4 3 8 5 2 Solution运用DFS，代码中会详细解释。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std;int n,a[15]= &#123;0&#125;;bool used[15]= &#123;0&#125;,flag=0;bool chk_prime(int a) &#123;//用于判断素数的函数 if(a==2) return 1; if(a==1) return 0; if(a==0) return 0; for(int i=2; i&lt;=sqrt(a); i++) &#123; if(a%i==0) return 0; &#125; return 1;&#125;bool chk() &#123;//用于判断是否符合条件的函数 int p=0; for(int i=1; i&lt;=n-1; i++) &#123; if(chk_prime(a[i]+a[i+1])==1) &#123; p++; &#125; &#125; if(chk_prime(a[n]+a[1])==1) p++; if(p==n) return 1; else return 0;&#125;void print() &#123;//用于打印的函数 for(int i=1; i&lt;=n-1; i++) &#123; printf(\"%d \",a[i]); &#125; printf(\"%d\\n\",a[n]); flag=1;//标记存在答案&#125;void dfs(int i) &#123;//进行深度优先搜索(DFS)// print(); for(int j=2; j&lt;=n; j++) &#123; if(used[j]==0) &#123;//如果这个数没用过 a[i]=j;//那就使用这个数 used[j]=1;//把这个数标记为用过 if(i==n) &#123; if(chk()==1) &#123; print();//打印答案 &#125; &#125; else dfs(i+1); /*回溯部分*/ used[j]=0; a[i]=0; &#125; &#125;&#125;int main() &#123; cin&gt;&gt;n; a[1]=1; used[1]=1; dfs(2);//进行DFS if(flag==0)&#123;//如果没有答案，就输出no cout&lt;&lt;\"no\"; &#125; return 0;//程序结束&#125;","categories":[],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://stevebraveman.github.io/tags/DFS/"},{"name":"CodeVS","slug":"CodeVS","permalink":"https://stevebraveman.github.io/tags/CodeVS/"}]},{"title":"-其它- 几种常见的排序","slug":"11","date":"2018-08-21T04:17:42.000Z","updated":"2019-08-08T10:27:56.420Z","comments":true,"path":"2018/08/21/11/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/11/","excerpt":"冒泡排序冒泡排序的原理总的来说就是小的浮上来，大的沉底。 思路：如果$ai &lt; a{i+1}$，则交换。","text":"冒泡排序冒泡排序的原理总的来说就是小的浮上来，大的沉底。 思路：如果$ai &lt; a{i+1}$，则交换。 原理示意图： 冒泡排序的平均情况时间复杂度为$O(n^2)$。 代码如下： 1234567891011121314void Bubble_Sort(int a[],int length) &#123; for(int i=1; i&lt;=n-1; i++) &#123; int m=1; for(int j=1; j&lt;=n-i; j++) &#123; if(a[j]&gt;a[j+1]) &#123; m=0; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; if(m==1) break; &#125;&#125; 快速排序快排的思路是：先选取一个基准，然后将比基准小的放在左边，将比基准大的放在右边，然后再分小区间，重复以上操作。 原理示意图： 快速排序的平均情况时间复杂度为$O(n\\log_2 n)$。 代码： 1234567891011121314151617181920void Quick_Sort(int s[], int l, int r) &#123; if(l&lt;r) &#123; int low=l; int high=r; int pivot = s[l]; while(low&lt;high) &#123; while(low&lt;high&amp;&amp;s[high]&gt;= pivot) high--; if(low&lt;high) s[low++] = s[high]; while(low&lt;high&amp;&amp;s[low]&lt;pivot) low++; if(low&lt;high) s[high--] = s[low]; &#125; s[low]=pivot; QuickSort(s, l, low - 1); QuickSort(s, low + 1, r); &#125;&#125; 插入排序首先回忆一下你是怎么玩牌的，每次摸到一张牌，都要把它插入到正确位置。 插入排序的原理一样，首先查找一下它的正确位置$a_i$，然后将$a_i$后数向后移动一位，将这个数插入进去。 原理示意图： 插入排序的平均情况时间复杂度是$O(n^2)$。 代码： 1234567891011121314void Insertion_Sort(int arr[],int length) &#123; int i,j,key; for(i=0; i&lt;length; i++) &#123; key=arr[i]; for(j=i-1; j&gt;=0; j--) &#123; if (arr[j]&gt;key) &#123; arr[j+1]=arr[j]; &#125; else &#123; break; &#125; &#125; arr[j+1]=key; &#125;&#125; 选择排序选择排序原理：首先找出最小值，然后放在数列的最前面，如此反复。 原理示意图： 选择排序的平均情况时间复杂度为$O(n^2)$。 代码如下 12345678910111213void Selection_Sort(int a[],int length)&#123; for(int i=0;i&lt;n;i++)&#123; int k=i; for(int j=i;j&lt;n;j++)&#123; if(a[j]&lt;a[k])&#123; k=j; &#125; &#125; int t=a[i]; a[i]=a[k]; a[k]=t; &#125;&#125; 桶排序设一个数组为桶，数组的大小为待排序数列的最大值加1，桶号即为数列的每一个值，当出现这个数时，对应的桶就加1。 原理示意图： 桶排序的平均情况时间复杂度为$O(n)$，但空间复杂度为$O(n)$。 代码：123456789101112131415void Bucket_Sort(int a[], int max, int length) &#123; int B[max+1]= &#123;0&#125;; int i,j,count=0; for (i=0; i&lt;length; i++) &#123; B[a[i]]+=1; &#125; for(i=0; i&lt;=max; i++) &#123; if (B[i]&gt;0) &#123; for(j=0; j&lt;B[i]; j++) &#123; a[count]=i; count++; &#125; &#125; &#125;&#125; 终极の排序不需要任何算法，直接一个函数搞定！ 1sort(a+1,a+1+n) 别忘了加这个头文件：1#include&lt;algorithm&gt; 还可以通过写一个函数来决定从大到小排还是从小到大排。","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"https://stevebraveman.github.io/tags/其它/"}]},{"title":"-DFS- [洛谷 P1025][NOIp 2001]数的划分","slug":"10","date":"2018-08-21T04:17:38.000Z","updated":"2019-08-09T07:40:08.836Z","comments":true,"path":"2018/08/21/10/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/10/","excerpt":"题目描述将整数 $n$ 分成$k$份，且每份不能为空，任意两个方案不相同(不考虑顺序)。","text":"题目描述将整数 $n$ 分成$k$份，且每份不能为空，任意两个方案不相同(不考虑顺序)。例如： $n=7$ ， $k=3$ ，下面三种分法被认为是相同的。 $1,1,5$;$1,5,1$;$5,1,1$; 问有多少种不同的分法。 输入格式$n$,$k$ $(6&lt;n≤200,2≤k≤6)$ 输出格式$1$ 个整数，即不同的分法。 输入样例7 3 输出样例4 Solution这道题十分简单，就是裸的DFS，代码也只有十多行，不过需要一个小小的剪枝。 Code123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int a[10001]=&#123;1&#125;,n,tot,k;void dfs(int,int,int);int main()&#123; cin&gt;&gt;n&gt;&gt;k; dfs(1,0,0); cout&lt;&lt;tot;&#125;void dfs(int s,int t,int p)&#123;//一共三个参数，分别是：当前拆分出来的数、数的总和、分的第几份 if(p==k)&#123; if(t==n) tot++; return; &#125; for(int i=s;t+i*(k-p)&lt;=n;i++)&#123;//剪枝 dfs(i,t+i,p+1); &#125;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"DFS","slug":"DFS","permalink":"https://stevebraveman.github.io/tags/DFS/"}]},{"title":"-递推- [洛谷 P1096][NOIp 2007]Hanoi双塔问题","slug":"9","date":"2018-08-21T04:17:34.000Z","updated":"2019-08-08T10:27:40.191Z","comments":true,"path":"2018/08/21/9/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/9/","excerpt":"题目描述给定$A$、$B$、$C$三根足够长的细柱，在$A$柱上放有$2n$个中间有孔的圆盘，共有$n$个不同的尺寸，每个尺寸都有两个相同的圆盘，注意这两个圆盘是不加区分的。","text":"题目描述给定$A$、$B$、$C$三根足够长的细柱，在$A$柱上放有$2n$个中间有孔的圆盘，共有$n$个不同的尺寸，每个尺寸都有两个相同的圆盘，注意这两个圆盘是不加区分的。现要将这些圆盘移到$C$柱上，在移动过程中可放在$B$柱上暂存。要求：（1）每次只能移动一个圆盘；（2）$A$、$B$、$C$三根细柱上的圆盘都要保持上小下大的顺序；任务：设$A_n$为$2_n$个圆盘完成上述任务所需的最少移动次数，对于输入的$n$，输出$A_n$。 输入格式一个正整数$n$，表示在$A$柱上放有$2n$个圆盘。 输出格式一个正整数, 为完成上述任务所需的最少移动次数$A_n$。 样例输入2 样例输入6 Solution首先我们知道如果是单个盘子，设$n$个盘子所需步数为$F(n)$ 则$F(n)=2*F(n-1)+1$ 然而这道题是双盘，所以相当于把单盘移动次数乘2。 我们可以得出单盘的通项公式为$2^p-1$； 所以双盘的通项公式为$2^{p+1}-2$ 这道题数据范围贼大，所以我们需要高精度 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344//Hanoi双塔问题.cpp#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int a[100010];int main()&#123; int n; cin&gt;&gt;n; int j=1; int k=1; memset(a,-1,sizeof(a)); a[1]=1; for(int i=1;i&lt;=n+1;i++)&#123; while(a[j]&gt;=0)&#123; a[j]*=2; j++; &#125; while(a[k]&gt;=0)&#123; if(a[k]&gt;=10)&#123; a[k]%=10; if(a[k+1]&lt;0)&#123; a[k+1]=0; a[k+1]++; break; &#125; else&#123; a[k+1]++; &#125; &#125; k++; &#125; j=1;k=1; &#125; int y=0; a[1]-=2; for(int i=1;i&lt;=100000;i++)&#123; if(a[i]&gt;=0)&#123; y++; &#125; &#125; for(int i=y;i&gt;=1;i--)&#123; cout&lt;&lt;a[i]; &#125;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"递推","slug":"递推","permalink":"https://stevebraveman.github.io/tags/递推/"}]},{"title":"-其它- A+B|A-B|A*B Problem","slug":"8","date":"2018-08-21T04:17:28.000Z","updated":"2019-08-08T10:27:24.100Z","comments":true,"path":"2018/08/21/8/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/8/","excerpt":"当long long不够用时，就得用高精度了！","text":"当long long不够用时，就得用高精度了！ 高精度加法123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;char a1[500001],b1[500001];int a[500001],b[500001],c[500001],x,lenc,la,lb,i;int main()&#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(c,0,sizeof(c)); gets(a1); gets(b1); la=strlen(a1); lb=strlen(b1); for(i=0;i&lt;=la-1;i++)&#123; a[la-i]=a1[i]-'0'; &#125; for(i=0;i&lt;=lb-1;i++)&#123; b[lb-i]=b1[i]-'0'; &#125; lenc=1; x=0; while(lenc&lt;=la||lenc&lt;=lb)&#123; c[lenc]=a[lenc]+b[lenc]+x; x=c[lenc]/10; c[lenc]%=10; lenc++; &#125; c[lenc]=x; if(c[lenc]==0) lenc--; for(i=lenc;i&gt;=1;i--) cout&lt;&lt;int(c[i]); return 0;&#125; 高精度减法12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int a[10001],b[10001],c[10001],la,lb,lc,i; char n[10001],n1[10001],n2[10001]; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(c,0,sizeof(c)); cin&gt;&gt;n1&gt;&gt;n2; if(strlen(n1)&lt;strlen(n2)||(strlen(n1)==strlen(n2)&amp;&amp;strcmp(n1,n2)&lt;0))&#123; strcpy(n,n1); strcpy(n1,n2); strcpy(n2,n); cout&lt;&lt;\"-\"; &#125; la=strlen(n1); lb=strlen(n2); for(i=0;i&lt;=la-1;i++)&#123; a[la-i]=int(n1[i]-'0'); &#125; for(i=0;i&lt;=lb-1;i++)&#123; b[lb-i]=int(n2[i]-'0'); &#125; i=1; while(i&lt;=la||i&lt;=lb)&#123; if(a[i]&lt;b[i])&#123; a[i]+=10; a[i+1]--; &#125; c[i]=a[i]-b[i]; i++; &#125; lc=i; while((c[lc]==0)&amp;&amp;(lc&gt;1)) lc--; for(i=lc;i&gt;=1;i--) cout&lt;&lt;c[i]; cout&lt;&lt;endl; return 0;&#125; 高精度乘法12345678910111213141516171819202122232425262728293031323334353637383940//A*B problem.cpp#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char a1[2006],b1[2006];int a[2006]=&#123;0&#125;,b[2006]=&#123;0&#125;,c[20000050]=&#123;0&#125;,lena,lenb,lenc,i,j,x;int main()&#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(c,0,sizeof(c)); scanf(\"%s\",a1); scanf(\"%s\",b1); lena=strlen(a1); lenb=strlen(b1); for(i=0;i&lt;lena;i++)&#123; a[lena-i]=a1[i]-'0'; &#125; for(i=0;i&lt;lenb;i++)&#123; b[lenb-i]=b1[i]-'0'; &#125; for(i=1;i&lt;=lena;i++)&#123; x=0; for(j=1;j&lt;=lenb;j++)&#123; c[i+j-1]=a[i]*b[j]+x+c[i+j-1]; x=c[i+j-1]/10; c[i+j-1]%=10; &#125; c[i+lenb]=x; &#125; lenc=lena+lenb; while(c[lenc]==0&amp;&amp;lenc&gt;1)&#123; lenc--; &#125; for(i=lenc;i&gt;=1;i--)&#123; cout&lt;&lt;c[i]; &#125; cout&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"https://stevebraveman.github.io/tags/其它/"}]},{"title":"-贪心- [洛谷 P1106]删数问题","slug":"7","date":"2018-08-21T04:17:23.000Z","updated":"2019-08-08T10:26:53.116Z","comments":true,"path":"2018/08/21/7/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/7/","excerpt":"题目描述键盘输入一个高精度的正整数 $N$，去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的正整数。编程对给定的 $N$ 和 $k$ ，寻找一种方案使得剩下的数字组成的新数最小。","text":"题目描述键盘输入一个高精度的正整数 $N$，去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的正整数。编程对给定的 $N$ 和 $k$ ，寻找一种方案使得剩下的数字组成的新数最小。输出应包括所去掉的数字的位置和组成的新的整数。（ $N$ 不超过 $250$ 位） 输入数据均不需判错。 输入格式$n$(高精度的正整数) $k$(需要删除的数字个数) 输出格式最后剩下的最小数。 样例输入175438 4 样例输出13 Solution这道题是贪心算法经典问题，思路：每次都选取一个使得剩下的数最小的数字。 注意：每次都选取最大的数字是错误的！ 我因为这个错了5次 废话不多说，代码简单易懂，直接上代码 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; char a[260],b[260],k[260]; int p; scanf(\"%s\",a); cin&gt;&gt;p; while(p&gt;=1)&#123; for(int i=0;i&lt;strlen(a);i++)&#123; strcpy(k,a); for(int j=i;j&lt;strlen(a);j++)&#123; k[j]=k[j+1]; &#125; int j=0; int d; sscanf(k,\"%d\",&amp;d); if(d!=0)&#123; while(k[j]=='0')&#123; for(int t=j;t&lt;strlen(a)-1;t++)&#123; k[t]=k[t+1]; &#125; j++; &#125; &#125; if(i==0) &#123; strcpy(b,k); continue; &#125; if(strlen(b)&gt;strlen(k)) &#123; strcpy(b,k); continue; &#125; if(strcmp(b,k)&gt;0)&#123; strcpy(b,k); &#125; &#125; strcpy(a,b); p--; &#125; cout&lt;&lt;a;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://stevebraveman.github.io/tags/洛谷/"},{"name":"贪心","slug":"贪心","permalink":"https://stevebraveman.github.io/tags/贪心/"}]},{"title":"-其它- 对拍模板","slug":"6","date":"2018-08-21T04:17:19.000Z","updated":"2019-08-08T10:26:36.705Z","comments":true,"path":"2018/08/21/6/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/6/","excerpt":"","text":"1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; while(1) &#123; system(\"data &gt; input.txt\"); system(\"a+b &lt; input.txt &gt; 1.out\"); system(\"test &lt; input.txt &gt; 2.out\"); if(system(\"fc 1.out 2.out\")) &#123; system(\"pause\"); break; &#125; &#125; return 0;&#125; 在找不出自己的输出有什么问题的情况下，可使用这个对拍程序","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"https://stevebraveman.github.io/tags/其它/"}]},{"title":"-数论- 数论中重要公式[整理]","slug":"5","date":"2018-08-21T04:17:11.000Z","updated":"2019-08-08T10:26:13.212Z","comments":true,"path":"2018/08/21/5/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/5/","excerpt":"1、\\sum_{i=1}^n {2i-1} = i^2 2、\\sum_{i=1}^n {i(i+1)} =\\frac {n(n+1)(n+2)}{3}","text":"1、\\sum_{i=1}^n {2i-1} = i^2 2、\\sum_{i=1}^n {i(i+1)} =\\frac {n(n+1)(n+2)}{3}3、\\sum_{i=1}^n {i^2(i-1)!} = (n+1)!+1 4、\\sum_{i=1}^n {i^2} =\\frac {n(n+1)(2n+1)}{6} 5、\\sum_{i=1}^n {i^3} = (\\frac{i(i+1)}{2})^2","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"}]},{"title":"-数论- C++ 线性筛素数","slug":"3","date":"2018-08-21T04:16:53.000Z","updated":"2019-08-08T09:29:42.967Z","comments":true,"path":"2018/08/21/3/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/3/","excerpt":"在C++中，筛素数是一个非常重要算法。","text":"在C++中，筛素数是一个非常重要算法。我花了半天时间才明白的欧拉筛（我实在是太蒻了）。 最愚蠢的方法123456789101112#include&lt;cstdio&gt;int main()&#123; int n,k; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; if(n%i==0)&#123; printf(\"yes\"); return 0; &#125; &#125; printf(\"no\");&#125; 普通方法123456789101112#include&lt;cstdio&gt;int main()&#123; int n,k; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=sqrt(n);i++)&#123; if(n%i==0)&#123; printf(\"yes\"); return 0; &#125; &#125; printf(\"no\");&#125; 以上两种方法其实都是判定方法，并不是筛法，下面说真正的筛法： 埃筛法1234567891011121314#include&lt;iostream&gt;#define MAXN 1000010using namespace std;int chk[MAXN]=&#123;0&#125;;int p[MAXN]=&#123;0&#125;;int main()&#123; int t=0; for (int i=2;i&lt;MAXN;i++)&#123; if (!chk[i]) p[t++]=i; for (int j=0;j&lt;t&amp;&amp; i*p[j]&lt;MAXN;j++) &#123; chk[i*p[j]] = 1; &#125; &#125;&#125; 思路：首先将所有2的倍数标为1，再将所有3的倍数标为1……以此类推。 欧拉筛12345678910111213#define MAXN 1000000int chk[MAXN]=&#123;0&#125;;int p[MAXN]=&#123;0&#125;;int main()&#123; int t=0; for (int i=2;i&lt;MAXN;i++)&#123; if (!chk[i]) p[t++]=i; for (int j=0;j&lt;t&amp;&amp; i*p[j]&lt;MAXN;j++) &#123; chk[i*p[j]] = 1; if (i%p[j]==0) break; &#125; &#125;&#125; 思路：由于埃筛法做了许多不必要的循环，所以欧拉筛在埃筛法的基础上，省去了一些步骤，时间复杂度O(n)。","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"https://stevebraveman.github.io/tags/数论/"}]},{"title":"-其它- 名字竞技场C++","slug":"2","date":"2018-08-21T04:16:44.000Z","updated":"2019-08-08T09:29:40.155Z","comments":true,"path":"2018/08/21/2/","link":"","permalink":"https://stevebraveman.github.io/2018/08/21/2/","excerpt":"","text":"自己写的，dalao勿喷 V1.1 有了名字判重系统，以及可以循环玩游戏了！ V1.2 可以多人玩游戏了！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;#include&lt;windows.h&gt;using namespace std;struct note&#123; char a[10]; int hp; int gj;&#125;;note player[16];int hit1,hit2,g[11],pdh1=0,pdh2=0,n;void shuru();void gj();void youxi();void slowsay(char a[])&#123; for(int i=0;i&lt;strlen(a);i++)&#123; cout&lt;&lt;a[i]; Sleep(25); &#125;&#125;int main()&#123; srand((unsigned)time(NULL)); slowsay(\"欢迎来到名字竞技场！ by Steve_bm\"); cout&lt;&lt;endl; slowsay(\"V 1.2\"); cout&lt;&lt;endl; cout&lt;&lt;\"请输入人数：\"; cin&gt;&gt;n; shuru(); youxi(); return 0;&#125;void gj()&#123; int op1,op2; op1=rand()%n+1; op2=rand()%n+1; if((op1==op2)||(player[op1].hp==0||player[op2].hp==0))&#123; while(1)&#123; op1=rand()%n+1; op2=rand()%n+1; if((op1!=op2)&amp;&amp;(player[op1].hp!=0&amp;&amp;player[op2].hp!=0)) break; &#125; &#125; hit1=rand()%player[op1].gj+1; player[op2].hp-=hit1; if(player[op2].hp&lt;=0) player[op2].hp=0; cout&lt;&lt;player[op1].a&lt;&lt;\"对\"&lt;&lt;player[op2].a&lt;&lt;\"发起了攻击\"&lt;&lt;endl; Sleep(500); if(hit1&gt;=((player[op1].gj/3)*2)) cout&lt;&lt;player[op1].a&lt;&lt;\"暴击！\"&lt;&lt;endl; cout&lt;&lt;player[op2].a&lt;&lt;\"受到了\"&lt;&lt;hit1&lt;&lt;\"点伤害\"&lt;&lt;endl; Sleep(250); cout&lt;&lt;player[op2].a&lt;&lt;\"现在的生命值是\"&lt;&lt;player[op2].hp&lt;&lt;endl; cout&lt;&lt;endl;&#125;void youxi()&#123; Sleep(1200); for(int t=1;t&lt;=n;t++)&#123; int n1=player[t].a[0]+200; int q1=player[t].a[strlen(player[t].a)-1]; player[t].hp=(rand()%n1+30)*9; player[t].gj=(rand()%q1+30)*7; &#125; system(\"cls\"); for(int b=1;b&lt;=n;b++)&#123; cout&lt;&lt;player[b].a&lt;&lt;\" \"&lt;&lt;\"HP:\"&lt;&lt;player[b].hp&lt;&lt;\" \"&lt;&lt;\"攻击力:\"&lt;&lt;player[b].gj&lt;&lt;endl; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; Sleep(3000); cout&lt;&lt;\"现在开始!\"&lt;&lt;endl; Sleep(1500); int w; int f=0; while(1)&#123; gj(); Sleep(1000); cout&lt;&lt;endl; for(int i=1;i&lt;=n;i++)&#123; if(player[i].hp==0) f++; if(player[i].hp&gt;0) w=i; &#125; if(f==n-1) break; f=0; &#125; Sleep(1500); cout&lt;&lt;\"胜利者是\"; cout&lt;&lt;player[w].a&lt;&lt;\"!\"&lt;&lt;endl; for(int m=1;m&lt;=n;m++)&#123; if(player[m].hp==0)&#123; cout&lt;&lt;player[m].a&lt;&lt;\"完败!\"&lt;&lt;endl; &#125; &#125; char l; Sleep(3000); cout&lt;&lt;\"Do you want to play again?(Y/N)\"&lt;&lt;endl; cin&gt;&gt;l; if(l=='Y'||l=='y')&#123; system(\"cls\"); for(int h=1;h&lt;=n;h++)&#123; memset(player[h].a,0,sizeof(player[h].a)); &#125; youxi(); &#125; else&#123; exit(0); &#125;&#125;void shuru()&#123; for(int l=1;l&lt;=n;l++)&#123; cout&lt;&lt;\"请输入玩家\"&lt;&lt;l&lt;&lt;\"的名字（名字不超过10字符，最小3字符，不能有汉字!）：\"&lt;&lt;endl; scanf(\"%s\",player[l].a); &#125; int yy[11]=&#123;0&#125;; for(int i=1;i&lt;n;i++)&#123; for(int o=i+1;o&lt;=n;o++)&#123; for(int q=0;q&lt;strlen(player[i].a);q++)&#123; if(player[i].a[q]==player[o].a[q]) yy[i]++; &#125; &#125; &#125; for(int u=1;u&lt;=n;u++)&#123; if(yy[u]==strlen(player[u].a))&#123; system(\"cls\"); cout&lt;&lt;\"输入的名字不能相同！\"&lt;&lt;endl; Sleep(100); cout&lt;&lt;\"请重新输入！\"&lt;&lt;endl; shuru(); &#125; else youxi(); &#125;&#125;","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"https://stevebraveman.github.io/tags/其它/"}]}]}